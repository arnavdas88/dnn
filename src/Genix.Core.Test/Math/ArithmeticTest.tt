<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Core.Test
{
    using System;
    using System.Linq;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
<#    foreach (string type in "float;double".Split(';')) { #>

    [TestClass]
    public class ArithmeticTest_<#=type#>
    {
        private readonly RandomNumberGenerator<<#=type#>> random = new RandomGenerator<#=type.Substring(0, 1).ToUpperInvariant()#>();

        [TestMethod]
        public void AddTest_<#=type#>()
        {
            const int offx = 5;
            const int offy0 = 8;
            const int offy = 10;

            foreach (int length in new[] { 24, 128 })
            {
                <#=type#>[] x = this.random.Generate(length, null);
                <#=type#>[] y0 = this.random.Generate(length, null);

                <#=type#>[] y = y0.ToArray();
                Mathematics.Add(length, x, 0, y, 0);
                GenixAssert.AreArraysEqual(x.Zip(y0, (a, b) => a + b).ToArray(), y);

                y = y0.ToArray();
                int count = length - Math.Max(offx, offy);
                Mathematics.Add(count, x, offx, y, offy);
                GenixAssert.AreArraysEqual(offy, y0, 0, y, 0);
                GenixAssert.AreArraysEqual(count, x.Skip(offx).Zip(y0.Skip(offy), (a, b) => a + b).ToArray(), 0, y, offy);

                y = y0.ToArray();
                Mathematics.Add(length, x, 0, y0, 0, y, 0);
                GenixAssert.AreArraysEqual(x.Zip(y0, (a, b) => a + b).ToArray(), y);

                y = y0.ToArray();
                count = length - Math.Max(offx, Math.Max(offy, offy0));
                Mathematics.Add(count, x, offx, y0, offy0, y, offy);
                GenixAssert.AreArraysEqual(offy, y0, 0, y, 0);
                GenixAssert.AreArraysEqual(count, x.Skip(offx).Zip(y0.Skip(offy0), (a, b) => a + b).ToArray(), 0, y, offy);
            }
        }

        [TestMethod]
        public void AddCTest_<#=type#>()
        {
            foreach (int length in new[] { 24, 128 })
            {
                <#=type#>[] a = new <#=type#>[length];
                <#=type#>[] y = new <#=type#>[length];

                Vectors.Set(length, 0, a, 0);
                Mathematics.AddC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => x == 1));

                Vectors.Set(length, <#=type#>.NegativeInfinity, a, 0);
                Mathematics.AddC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => <#=type#>.IsNegativeInfinity(x)));

                Vectors.Set(length, <#=type#>.PositiveInfinity, a, 0);
                Mathematics.AddC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => <#=type#>.IsPositiveInfinity(x)));

                Vectors.Set(length, <#=type#>.MinValue, a, 0);
                Mathematics.AddC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => x == <#=type#>.MinValue));

                Vectors.Set(length, <#=type#>.MaxValue, a, 0);
                Mathematics.AddC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => x == <#=type#>.MaxValue));

                Vectors.Set(length, <#=type#>.NaN, a, 0);
                Mathematics.AddC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => <#=type#>.IsNaN(x)));
            }
        }

        [TestMethod]
        public void SubCTest_<#=type#>()
        {
            foreach (int length in new[] { 24, 128 })
            {
                <#=type#>[] a = new <#=type#>[length];
                <#=type#>[] y = new <#=type#>[length];

                Vectors.Set(length, 0, a, 0);
                Mathematics.SubC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => x == -1));

                Vectors.Set(length, <#=type#>.NegativeInfinity, a, 0);
                Mathematics.SubC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => <#=type#>.IsNegativeInfinity(x)));

                Vectors.Set(length, <#=type#>.PositiveInfinity, a, 0);
                Mathematics.SubC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => <#=type#>.IsPositiveInfinity(x)));

                Vectors.Set(length, <#=type#>.MinValue, a, 0);
                Mathematics.SubC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => x == <#=type#>.MinValue));

                Vectors.Set(length, <#=type#>.MaxValue, a, 0);
                Mathematics.SubC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => x == <#=type#>.MaxValue));

                Vectors.Set(length, <#=type#>.NaN, a, 0);
                Mathematics.SubC(length, a, 0, 1, y, 0);
                Assert.IsTrue(y.All(x => <#=type#>.IsNaN(x)));
            }
        }
    }
<#  } #>
}