<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
// -----------------------------------------------------------------------
// <copyright file="BitUtils.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Core
{
    using System;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;

    /// <summary>
    /// Provides bit manipulation methods for 32- and 64-bit little-endian architecture.
    /// </summary>
    [CLSCompliant(false)]
    public static class BitUtils
    {
<#
    Tuple<string, int, string, string>[] types = 
    {
        Tuple.Create("uint", 32, "32", "32-bit unsigned integers"),
        Tuple.Create("ulong", 64, "64", "64-bit unsigned integers"),
    };

    foreach (Tuple<string, int, string, string> type in types)
    {
        string typeName = type.Item1;
        int bitCount = type.Item2;
#>

        /// <summary>
        /// The first bit.
        /// </summary>
        public const <#=typeName#> LSB<#=bitCount#> = 1;
<#
    }

    foreach (Tuple<string, int, string, string> type in types)
    {
        string typeName = type.Item1;
        int bitCount = type.Item2;
        string nativeSuffix = type.Item3;
        string typeDescription = type.Item4;
#>

        /// <summary>
        /// Examines the bit at the specified position.
        /// </summary>
        /// <param name="bits">The bits to examine.</param>
        /// <param name="position">The bit position to test.</param>
        /// <returns>
        /// <b>true</b> if the bit at the specified position is set; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TestBit(<#=typeName#> bits, int position)
        {
            Debug.Assert(position < <#=bitCount#>, "The bit position must be less than <#=bitCount#>.");
            return (bits & (BitUtils.LSB<#=bitCount#> << position)) != 0;
        }

        /// <summary>
        /// Sets the bit at the specified position.
        /// </summary>
        /// <param name="bits">The bits to set.</param>
        /// <param name="position">The bit position to set.</param>
        /// <returns>The changed bits.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> SetBit(<#=typeName#> bits, int position)
        {
            Debug.Assert(position < <#=bitCount#>, "The bit position must be less than <#=bitCount#>.");
            return bits | (BitUtils.LSB<#=bitCount#> << position);
        }

        /// <summary>
        /// Resets the bit at the specified position.
        /// </summary>
        /// <param name="bits">The bits to reset.</param>
        /// <param name="position">The bit position to reset.</param>
        /// <returns>The changed bits.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> ResetBit(<#=typeName#> bits, int position)
        {
            Debug.Assert(position < <#=bitCount#>, "The bit position must be less than <#=bitCount#>.");
            return bits & ~(BitUtils.LSB<#=bitCount#> << position);
        }

        /// <summary>
        /// Examines the bit at the specified position in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="bits">The bits to examine.</param>
        /// <param name="position">The bit position to test.</param>
        /// <returns>
        /// <b>true</b> if the bit at the specified position is set; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TestBit(<#=typeName#>[] bits, int position)
        {
            return (bits[position >> <#=(int)Math.Log(bitCount, 2)#>] & (BitUtils.LSB<#=bitCount#> << (position & <#=bitCount - 1#>))) != 0;
        }

        /// <summary>
        /// Sets the bit at the specified position in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="bits">The bits to reset.</param>
        /// <param name="position">The bit position to reset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetBit(<#=typeName#>[] bits, int position)
        {
            bits[position >> <#=(int)Math.Log(bitCount, 2)#>] |= BitUtils.LSB<#=bitCount#> << (position & <#=bitCount - 1#>);
        }

        /// <summary>
        /// Resets the bit at the specified position in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="bits">The bits to reset.</param>
        /// <param name="position">The bit position to reset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ResetBit(<#=typeName#>[] bits, int position)
        {
            bits[position >> <#=(int)Math.Log(bitCount, 2)#>] &= ~(BitUtils.LSB<#=bitCount#> << (position & <#=bitCount - 1#>));
        }

        /// <summary>
        /// Sets the range bits at the specified starting position in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="count">The number of bits to set.</param>
        /// <param name="bits">The bits to set.</param>
        /// <param name="position">The starting bit position to set.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetBits(int count, <#=typeName#>[] bits, int position)
        {
            NativeMethods.bits_set_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Sets the range bits at the specified starting position in the array of <#=typeDescription#> to the specified mask.
        /// </summary>
        /// <param name="count">The number of bits to set.</param>
        /// <param name="mask">The bit mask to set.</param>
        /// <param name="bits">The bits to set.</param>
        /// <param name="position">The starting bit position to set.</param>
        /// <remarks>
        /// <para>The method sets all elements in <paramref name="bits"/> to <paramref name="mask"/>.</para>
        /// <para>If range starting or ending position do not match element boundaries, the required bits for partial elements are taken from <paramref name="mask"/>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetBits(int count, <#=typeName#> mask, <#=typeName#>[] bits, int position)
        {
            NativeMethods.bits_set_mask_<#=nativeSuffix#>(count, mask, bits, position);
        }

        /// <summary>
        /// Resets the range bits at the specified starting position in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="count">The number of bits to reset.</param>
        /// <param name="bits">The bits to reset.</param>
        /// <param name="position">The starting bit position to reset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ResetBits(int count, <#=typeName#>[] bits, int position)
        {
            NativeMethods.bits_reset_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Gets the specified number of bits at the specified position.
        /// </summary>
        /// <param name="bits">The bits to examine.</param>
        /// <param name="position">The bits index; in the range of 0 - <#=bitCount - 1#>.</param>
        /// <param name="count">The number of bits to get.</param>
        /// <returns>
        /// The value at the index specified.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> GetBits(<#=typeName#> bits, int position, int count)
        {
            Debug.Assert(position + count <= <#=bitCount#>, "The position+count must be less than or equal to <#=bitCount#>.");
            return (bits >> position) & ~(<#=typeName#>.MaxValue << count);
        }

        /// <summary>
        /// Sets the specified number of bits at the specified position.
        /// </summary>
        /// <param name="bits">The bits to set.</param>
        /// <param name="position">The bits index; in the range of 0 - <#=bitCount - 1#>.</param>
        /// <param name="count">The number of bits to set.</param>
        /// <returns>The changed bits.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> SetBits(<#=typeName#> bits, int position, int count)
        {
            Debug.Assert(position + count <= <#=bitCount#>, "The position+count must be less than or equal to <#=bitCount#>.");
            <#=typeName#> mask = position + count == <#=bitCount#> ?
                <#=typeName#>.MaxValue << position :
                (<#=typeName#>.MaxValue << position) & ~(<#=typeName#>.MaxValue << (position + count));
            return bits | mask;
        }

        /// <summary>
        /// Determines whether the range of bits in two arrays of <#=typeDescription#> at the specified positions
        /// are equal.
        /// </summary>
        /// <param name="count">The number of bits to test.</param>
        /// <param name="x">The first source bits.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        /// <param name="y">The second source bits.</param>
        /// <param name="posy">The starting bit position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if the bits are equal; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int count, <#=typeName#>[] x, int posx, <#=typeName#>[] y, int posy)
        {
            return NativeMethods.bits_equals_<#=nativeSuffix#>(count, x, posx, y, posy);
        }

        /// <summary>
        /// Copies the specified number of bits to the specified position.
        /// </summary>
        /// <param name="bits">The bits to set.</param>
        /// <param name="position">The bits index; in the range of 0 - <#=bitCount - 1#>.</param>
        /// <param name="count">The number of bits to set.</param>
        /// <param name="source">The bits to copy.</param>
        /// <returns>The changed bits.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> CopyBits(<#=typeName#> bits, int position, int count, <#=typeName#> source)
        {
            Debug.Assert(position + count <= <#=bitCount#>, "The position+count must be less than or equal to <#=bitCount#>.");
            <#=typeName#> mask = position + count == <#=bitCount#> ?
                <#=typeName#>.MaxValue << position :
                (<#=typeName#>.MaxValue << position) & ~(<#=typeName#>.MaxValue << (position + count));
            return (bits & ~mask) | ((source << position) & mask);
        }

        /// <summary>
        /// Copies the range of bits from a source array of <#=typeDescription#> at the specified position
        /// to the destination array at the specified position.
        /// </summary>
        /// <param name="count">The number of bits to copy.</param>
        /// <param name="x">The bits to copy from.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        /// <param name="y">The bits to copy to.</param>
        /// <param name="posy">The starting bit position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyBits(int count, <#=typeName#>[] x, int posx, <#=typeName#>[] y, int posy)
        {
            NativeMethods.bits_copy_<#=nativeSuffix#>(count, x, posx, y, posy);
        }

        /// <summary>
        /// Shifts a range of bits from a source array of <#=typeDescription#> to the left (from LSB to MSB).
        /// </summary>
        /// <param name="count">The number of bits to shift.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="x">The bits to shift.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shl(int count, int shift, <#=typeName#>[] x, int posx)
        {
            NativeMethods.bits_shl_<#=nativeSuffix#>(count, shift, x, posx);
        }

        /// <summary>
        /// Shifts a range of bits from a source array of <#=typeDescription#> to the right (from MSB to LSB).
        /// </summary>
        /// <param name="count">The number of bits to shift.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="x">The bits to shift.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shr(int count, int shift, <#=typeName#>[] x, int posx)
        {
            NativeMethods.bits_shr_<#=nativeSuffix#>(count, shift, x, posx);
        }

        /// <summary>
        /// Searches the value for a first set bit (1).
        /// </summary>
        /// <param name="bits">The bits to search.</param>
        /// <returns>
        /// The bit position of the first set bit (1) found.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitScanOneForward(<#=typeName#> bits)
        {
            return NativeMethods.bit_scan_forward_<#=nativeSuffix#>(bits);
        }

        /// <summary>
        /// Searches the value for a last set bit (1).
        /// </summary>
        /// <param name="bits">The bits to search.</param>
        /// <returns>
        /// The bit position of the last set bit (1) found.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitScanOneReverse(<#=typeName#> bits)
        {
            return NativeMethods.bit_scan_reverse_<#=nativeSuffix#>(bits);
        }

        /// <summary>
        /// Searches the array of <#=typeDescription#> for a first set bit (1).
        /// </summary>
        /// <param name="count">The number of bits to search.</param>
        /// <param name="bits">The array that contains the data to search.</param>
        /// <param name="position">The starting bit position in <paramref name="bits"/>.</param>
        /// <returns>
        /// The bit position of the first set bit (1) found.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitScanOneForward(int count, <#=typeName#>[] bits, int position)
        {
            return NativeMethods.bits_scan_one_forward_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Searches the array of <#=typeDescription#> for a last set bit (1).
        /// </summary>
        /// <param name="count">The number of bits to search.</param>
        /// <param name="bits">The array that contains the data to search.</param>
        /// <param name="position">The starting bit position in <paramref name="bits"/>.</param>
        /// <returns>
        /// The bit position of the last set bit (1) found.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitScanOneReverse(int count, <#=typeName#>[] bits, int position)
        {
            return NativeMethods.bits_scan_one_reverse_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Searches the array of <#=typeDescription#> for a first reset bit (0).
        /// </summary>
        /// <param name="count">The number of bits to search.</param>
        /// <param name="bits">The array that contains the data to search.</param>
        /// <param name="position">The starting bit position in <paramref name="bits"/>.</param>
        /// <returns>
        /// The bit position of the first reset bit (0) found.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitScanZeroForward(int count, <#=typeName#>[] bits, int position)
        {
            return NativeMethods.bits_scan_zero_forward_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Searches the array of <#=typeDescription#> for a last reset bit (0).
        /// </summary>
        /// <param name="count">The number of values to search.</param>
        /// <param name="bits">The array that contains the data to search.</param>
        /// <param name="position">The starting bit position in <paramref name="bits"/>.</param>
        /// <returns>
        /// The bit position of the last reset bit (0) found.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int BitScanZeroReverse(int count, <#=typeName#>[] bits, int position)
        {
            return NativeMethods.bits_scan_zero_reverse_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Counts the number of one bits (population count).
        /// </summary>
        /// <param name="bits">The bits to count.</param>
        /// <returns>
        /// The number of one bits.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountOneBits(<#=typeName#> bits)
        {
            return (int)NativeMethods.bits_popcount_<#=nativeSuffix#>(bits);
        }

        /// <summary>
        /// Counts the number of zero bits (population count).
        /// </summary>
        /// <param name="bits">The bits to count.</param>
        /// <returns>
        /// The number of zero bits.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountZeroBits(<#=typeName#> bits)
        {
            return <#=bitCount#> - BitUtils.CountOneBits(bits);
        }

        /// <summary>
        /// Counts the number of one bits (population count) in the array of <#=typeDescription#> starting at the specified position.
        /// </summary>
        /// <param name="count">The number of bits to examine.</param>
        /// <param name="bits">The bits to count.</param>
        /// <param name="position">The starting bit position to count.</param>
        /// <returns>
        /// The number of one bits.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountOneBits(int count, <#=typeName#>[] bits, int position)
        {
            return (int)NativeMethods.bits_count_<#=nativeSuffix#>(count, bits, position);
        }

        /// <summary>
        /// Counts the number of zero bits (population count) in the array of <#=typeDescription#> starting at the specified position.
        /// </summary>
        /// <param name="count">The number of bits to examine.</param>
        /// <param name="bits">The bits to count.</param>
        /// <param name="position">The starting bit position to count.</param>
        /// <returns>
        /// The number of zero bits.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountZeroBits(int count, <#=typeName#>[] bits, int position)
        {
            return count - BitUtils.CountOneBits(count, bits, position);
        }

        /// <summary>
        /// Performs logical OR operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="count">The number of bits to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="posy">The starting bit position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int count, <#=typeName#>[] x, int posx, <#=typeName#>[] y, int posy)
        {
            NativeMethods.bits_or_<#=nativeSuffix#>(count, x, posx, y, posy);
        }

        /// <summary>
        /// Performs logical AND operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="count">The number of bits to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="posy">The starting bit position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int count, <#=typeName#>[] x, int posx, <#=typeName#>[] y, int posy)
        {
            NativeMethods.bits_and_<#=nativeSuffix#>(count, x, posx, y, posy);
        }

        /// <summary>
        /// Performs logical XOR operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="count">The number of bits to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="posy">The starting bit position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xor(int count, <#=typeName#>[] x, int posx, <#=typeName#>[] y, int posy)
        {
            NativeMethods.bits_xor_<#=nativeSuffix#>(count, x, posx, y, posy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="count">The number of bits to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="posx">The starting bit position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="posy">The starting bit position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xand(int count, <#=typeName#>[] x, int posx, <#=typeName#>[] y, int posy)
        {
            NativeMethods.bits_xand_<#=nativeSuffix#>(count, x, posx, y, posy);
        }

        /// <summary>
        /// Reverses the order of bytes in a <#=typeDescription.Substring(0, typeDescription.Length - 1)#>.
        /// </summary>
        /// <param name="bits">The integer to reverse byte order.</param>
        /// <returns>
        /// The integer with a reversed bytes.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> BiteSwap(<#=typeName#> bits)
        {
            return NativeMethods.byteswap_<#=nativeSuffix#>(bits);
        }

        /// <summary>
        /// Reverses the order of bytes in an array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to swap.</param>
        /// <param name="xy">The source and destination array.</param>
        /// <param name="offxy">The starting element position in <paramref name="xy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void BiteSwap(int length, <#=typeName#>[] xy, int offxy)
        {
            NativeMethods.bytesswap_ip_<#=nativeSuffix#>(length, xy, offxy);
        }

        /// <summary>
        /// Reverses the order of bytes in an array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to swap.</param>
        /// <param name="xy">The source and destination array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void BiteSwap(int length, <#=typeName#>* xy)
        {
            NativeMethods.bytesswap_ip_<#=nativeSuffix#>(length, xy, 0);
        }

        /// <summary>
        /// Reverses the order of bytes in an array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to swap.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void BiteSwap(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.bytesswap_<#=nativeSuffix#>(length, x, offx, y, offy);
        }
<#
    }
#>

        [SuppressUnmanagedCodeSecurity]
        private static class NativeMethods
        {
            private const string DllName = "Genix.Core.Native.dll";
<#
    foreach (Tuple<string, int, string, string> type in types)
    {
        string typeName = type.Item1;
        string nativeSuffix = type.Item3;
#>

            [DllImport(NativeMethods.DllName)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool bits_equals_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] x, int posx, [In] <#=typeName#>[] y, int posy);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_set_<#=nativeSuffix#>(int count, [In, Out] <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_set_mask_<#=nativeSuffix#>(int count, <#=typeName#> mask, [In, Out] <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_reset_<#=nativeSuffix#>(int count, [In, Out] <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_copy_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] x, int posx, [Out] <#=typeName#>[] y, int posy);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_shl_<#=nativeSuffix#>(int count, int shift, [In] <#=typeName#>[] x, int posx);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_shr_<#=nativeSuffix#>(int count, int shift, [In] <#=typeName#>[] x, int posx);

            [DllImport(NativeMethods.DllName)]
            public static extern int bit_scan_forward_<#=nativeSuffix#>(<#=typeName#> bits);

            [DllImport(NativeMethods.DllName)]
            public static extern int bit_scan_reverse_<#=nativeSuffix#>(<#=typeName#> bits);

            [DllImport(NativeMethods.DllName)]
            public static extern int bits_scan_one_forward_<#=nativeSuffix#>(int count, <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern int bits_scan_one_reverse_<#=nativeSuffix#>(int count, <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern int bits_scan_zero_forward_<#=nativeSuffix#>(int count, <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern int bits_scan_zero_reverse_<#=nativeSuffix#>(int count, <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> bits_popcount_<#=nativeSuffix#>(<#=typeName#> bits);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> bits_count_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] bits, int pos);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_or_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] x, int posx, [Out] <#=typeName#>[] y, int posy);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_and_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] x, int posx, [Out] <#=typeName#>[] y, int posy);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_xor_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] x, int posx, [Out] <#=typeName#>[] y, int posy);

            [DllImport(NativeMethods.DllName)]
            public static extern void bits_xand_<#=nativeSuffix#>(int count, [In] <#=typeName#>[] x, int posx, [Out] <#=typeName#>[] y, int posy);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> byteswap_<#=nativeSuffix#>(<#=typeName#> bits);

            [DllImport(NativeMethods.DllName)]
            public static extern void bytesswap_ip_<#=nativeSuffix#>(int n, [In, Out] <#=typeName#>[] xy, int offxy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void bytesswap_ip_<#=nativeSuffix#>(int n, [In, Out] <#=typeName#>* xy, int offxy);

            [DllImport(NativeMethods.DllName)]
            public static extern void bytesswap_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);
<#
    }
#>
        }
    }
}