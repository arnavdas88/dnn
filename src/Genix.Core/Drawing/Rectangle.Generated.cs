// -----------------------------------------------------------------------
// <copyright file="Rectangle.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 11/5/2018 5:55:48 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Drawing
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using Genix.Core;
    using Newtonsoft.Json;


    /// <summary>
    /// Describes the width, height, and location of a rectangle in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(RectangleConverter))]
    [JsonConverter(typeof(RectangleJsonConverter))]
    public struct Rectangle
        : IEquatable<Rectangle>
    {
        /// <summary>
        /// Represents a a rectangle with no position or area.
        /// </summary>
        /// <value>
        /// The empty rectangle, which has <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> property values of 0.
        /// </value>
        public static readonly Rectangle Empty;

        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const float Eps = 1e-8f;

        /// <summary>
        /// The x-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private int x;

        /// <summary>
        /// The y-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private int y;

        /// <summary>
        /// The rectangle width.
        /// </summary>
        private int w;

        /// <summary>
        /// The rectangle height.
        /// </summary>
        private int h;

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle"/> struct
        /// that has the specified x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle(int x, int y, int width, int height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle"/> struct
        /// with the specified location and size.
        /// </summary>
        /// <param name="location">The x- and y-coordinates of the top-left corner of the rectangle.</param>
        /// <param name="size">The dimensions of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle(Point location, Size size)
        {
            this.x = location.X;
            this.y = location.Y;
            this.w = size.Width;
            this.h = size.Height;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle"/> struct
        /// using two corner points.
        /// </summary>
        /// <param name="pt1">The first point.</param>
        /// <param name="pt2">The second point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle(Point pt1, Point pt2)
        {
            if (pt2.X >= pt1.X)
            {
                this.x = pt1.X;
                this.w = pt2.X - pt1.X;
            }
            else
            {
                this.x = pt2.X;
                this.w = pt1.X - pt2.X;
            }

            if (pt2.Y >= pt1.Y)
            {
                this.y = pt1.Y;
                this.h = pt2.Y - pt1.Y;
            }
            else
            {
                this.y = pt2.Y;
                this.h = pt1.Y - pt2.Y;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle"/> struct from the <see cref="System.Drawing.Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="System.Drawing.Rectangle"/> that contains the position of the point.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Rectangle.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Rectangle.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle(System.Drawing.Rectangle rect)
        {
            this.x = rect.X;
            this.y = rect.Y;
            this.w = rect.Width >= 0 ? rect.Width : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = rect.Height >= 0 ? rect.Height : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Left"/> property.</para>
        /// <para>Changing the <see cref="X"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="Rectangle"/>.</para>
        /// </remarks>
        public int X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Top"/> property.</para>
        /// <para>Changing the <see cref="Y"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="Rectangle"/>.</para>
        /// </remarks>
        public int Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets or sets the width of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the width of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Width"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Width"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="Rectangle"/>.
        /// </remarks>
        public int Width
        {
            get => this.w;
            set => this.w = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleWidth);
        }

        /// <summary>
        /// Gets or sets the height of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the height of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Height"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Height"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="Rectangle"/>.
        /// </remarks>
        public int Height
        {
            get => this.h;
            set => this.h = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="X"/> property.
        /// </remarks>
        public int Left => this.x;

        /// <summary>
        /// Gets the x-coordinate of the right side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the right side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Right"/> property represents the x-coordinate of the first point at the right edge of the rectangle that is not contained in the <see cref="Rectangle"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Width"/> properties.</para>
        /// </remarks>
        public int Right => this.x + this.w;

        /// <summary>
        /// Gets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="Y"/> property.
        /// </remarks>
        public int Top => this.y;

        /// <summary>
        /// Gets the y-coordinate of the bottom side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the bottom side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Bottom"/> property represents the y-coordinate of the first point at the bottom edge of the rectangle that is not contained in the <see cref="Rectangle"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="Y"/> and <see cref="Height"/> properties.</para>
        /// </remarks>
        public int Bottom => this.y + this.h;

        /// <summary>
        /// Gets a value indicating whether all numeric properties of this <see cref="Rectangle"/> have value of zero.
        /// </summary>
        /// <value>
        /// <b>true</b> if <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/> and <see cref="Height"/> properties are zero; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0 && this.w == 0 && this.h == 0;

        /// <summary>
        /// Gets the location of this <see cref="Rectangle"/>.
        /// </summary>
        /// <value>
        /// The <see cref="Point"/> struct that contains the x- and y-coordinates of the top-left corner of the rectangle.
        /// </value>
        public Point Location => new Point(this.x, this.y);

        /// <summary>
        /// Gets the size of this <see cref="Rectangle"/>.
        /// </summary>
        /// <value>
        /// The <see cref="Size"/> struct that contains rectangle dimensions.
        /// </value>
        public Size Size => new Size(this.w, this.h);

        /// <summary>
        /// Gets the area of this <see cref="Rectangle"/>.
        /// </summary>
        /// <value>
        /// <see cref="Width"/> * <see cref="Height"/>.
        /// </value>
        public int Area => this.w * this.h;

        /// <summary>
        /// Gets the center of this <see cref="Rectangle"/> along x-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="Rectangle"/> along x-axis.
        /// </value>
        /// <remarks>
        /// <para>If the rectangle width is even, the center point is rounded toward the rectangles top-left corner.</para>
        /// </remarks>
        public int CenterX => this.x + ((this.w - 1) / 2);

        /// <summary>
        /// Gets the center of this <see cref="Rectangle"/> along y-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="Rectangle"/> along y-axis.
        /// </value>
        /// <remarks>
        /// <para>If the rectangle height is even, the center point is rounded toward the rectangles top-left corner.</para>
        /// </remarks>
        public int CenterY => this.y + ((this.h - 1) / 2);

        /// <summary>
        /// Gets the center <see cref="Point"/> of this <see cref="Rectangle"/>.
        /// </summary>
        /// <value>
        /// The center <see cref="Point"/> of this <see cref="Rectangle"/>.
        /// </value>
        /// <remarks>
        /// <para>If the rectangle width or height is even, the center point is rounded toward the rectangles top-left corner.</para>
        /// </remarks>
        public Point CenterPoint => new Point(this.x + ((this.w - 1) / 2), this.y + ((this.h - 1) / 2));

        /// <summary>
        /// Compares two <see cref="Rectangle"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="Rectangle"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Rectangle"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Rectangle"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Rectangle left, Rectangle right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Rectangle"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="Rectangle"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Rectangle"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Rectangle"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, or <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Rectangle left, Rectangle right) => !left.Equals(right);

        /// <summary>
        /// Creates a <see cref="Rectangle"/> structure with the specified edge locations.
        /// </summary>
        /// <param name="left">The x-coordinate of the upper-left corner of this <see cref="Rectangle"/> structure.</param>
        /// <param name="top">The y-coordinate of the upper-left corner of this <see cref="Rectangle"/> structure.</param>
        /// <param name="right">The x-coordinate of the lower-right corner of this <see cref="Rectangle"/> structure.</param>
        /// <param name="bottom">The y-coordinate of the lower-right corner of this <see cref="Rectangle"/> structure.</param>
        /// <returns>The new <see cref="Rectangle"/> that this method creates.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle FromLTRB(int left, int top, int right, int bottom) => new Rectangle(left, top, right - left, bottom - top);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="Rectangle"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle.Empty"/> rectangle.</para>
        /// </remarks>
        public static Rectangle Inflate(Rectangle rect, int dx, int dy)
        {
            return new Rectangle(
                rect.X - dx,
                rect.Y - dy,
                MinMax.Max(rect.w + (2 * dx), 0),
                MinMax.Max(rect.h + (2 * dy), 0));
        }

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle Inflate(Rectangle rect, Size size) => Rectangle.Inflate(rect, size.Width, size.Height);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="Rectangle"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle.Empty"/> rectangle.</para>
        /// </remarks>
        public static Rectangle Inflate(Rectangle rect, int left, int top, int right, int bottom)
        {
            return new Rectangle(
                rect.X - left,
                rect.Y - top,
                MinMax.Max(rect.w + left + right, 0),
                MinMax.Max(rect.h + top + bottom, 0));
        }

        /// <summary>
        /// Returns a <see cref="Rectangle"/> structure that represents the intersection of two other <see cref="Rectangle"/> structures.
        /// If there is no intersection, an empty <see cref="Rectangle"/> is returned.
        /// </summary>
        /// <param name="rect1">The first rectangle to intersect.</param>
        /// <param name="rect2">The second rectangle to intersect.</param>
        /// <returns>
        /// The intersection of the two rectangles,
        /// or <see cref="Rectangle.Empty"/> if no intersection exists.
        /// </returns>
        public static Rectangle Intersect(Rectangle rect1, Rectangle rect2)
        {
            int x1 = MinMax.Max(rect1.x, rect2.x);
            int x2 = MinMax.Min(rect1.x + rect1.w, rect2.x + rect2.w);
            int y1 = MinMax.Max(rect1.y, rect2.y);
            int y2 = MinMax.Min(rect1.y + rect1.h, rect2.y + rect2.h);

            return x2 >= x1 && y2 >= y1 ? Rectangle.FromLTRB(x1, y1, x2, y2) : Rectangle.Empty;
        }

        /// <summary>
        /// Translates the specified <see cref="Rectangle"/> by the specified amount.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="Rectangle"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle Offset(Rectangle rect, int dx, int dy) => new Rectangle(rect.x + dx, rect.y + dy, rect.w, rect.h);

        /// <summary>
        /// Translates the specified <see cref="Rectangle"/> by the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to translate.</param>
        /// <param name="offset">The <see cref="Point"/> that contains the offset for the <paramref name="rect"/>.</param>
        /// <returns>The translated <see cref="Rectangle"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle Offset(Rectangle rect, Point offset) => Rectangle.Offset(rect, offset.X, offset.Y);

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="Rectangle"/> in the following format:X Y Width Height.</param>
        /// <returns>The <see cref="Rectangle"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of four values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static Rectangle Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 4 &&
                int.TryParse(split[0], out int x) &&
                int.TryParse(split[1], out int y) &&
                int.TryParse(split[2], out int w) &&
                int.TryParse(split[3], out int h))
            {
                return new Rectangle(x, y, w, h);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidRectangleFormat, nameof(value));
            }
        }

        /// <summary>
        /// Creates a <see cref="Rectangle"/> that results from scaling the location and dimensions of specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to scale.</param>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        /// <returns>The resulting <see cref="Rectangle"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle Scale(Rectangle rect, int dx, int dy) =>
            new Rectangle(rect.x * dx, rect.y * dy, rect.w * dx, rect.h * dy);

#if false
        /// <summary>
        /// Scales the specified <see cref="Rectangle"/> location.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="Rectangle"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle Scale(Rectangle rect, float dx, float dy)
        {
            return new Rectangle((dx * rect.x).Round(), (dy * rect.y).Round());
        }
#endif

        /// <summary>
        /// Returns a <see cref="Rectangle"/> structure that contains the union of two other <see cref="Rectangle"/> structures.
        /// </summary>
        /// <param name="rect1">The first rectangle to union.</param>
        /// <param name="rect2">The second rectangle to union.</param>
        /// <returns>
        /// The <see cref="Rectangle"/> structure that bounds the union of the two <see cref="Rectangle"/> structures.
        /// </returns>
        public static Rectangle Union(Rectangle rect1, Rectangle rect2)
        {
            if (rect1.IsEmpty)
            {
                return rect2;
            }

            if (rect2.IsEmpty)
            {
                return rect1;
            }

            int x1 = MinMax.Min(rect1.x, rect2.x);
            int x2 = MinMax.Max(rect1.x + rect1.w, rect2.x + rect2.w);
            int y1 = MinMax.Min(rect1.y, rect2.y);
            int y2 = MinMax.Max(rect1.y + rect1.h, rect2.y + rect2.h);

            return Rectangle.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="Rectangle"/> structure that contains the union of a <see cref="Rectangle"/> structure
        /// and a rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="rect">The first rectangle to union.</param>
        /// <param name="x">The x-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="width">The width of the second rectangle to union.</param>
        /// <param name="height">The height of the second rectangle to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        /// <returns>
        /// The <see cref="Rectangle"/> structure that bounds the union of the <see cref="Rectangle"/> structure and a rectangular area.
        /// </returns>
        public static Rectangle Union(Rectangle rect, int x, int y, int width, int height)
        {
            if (rect.IsEmpty)
            {
                return new Rectangle(x, y, width, height);
            }

            if (x == 0 && y == 0 && width == 0 && height == 0)
            {
                return rect;
            }

            if (width < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            }

            if (height < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
            }

            int x1 = MinMax.Min(rect.x, x);
            int x2 = MinMax.Max(rect.x + rect.w, x + width);
            int y1 = MinMax.Min(rect.y, y);
            int y2 = MinMax.Max(rect.y + rect.h, y + height);

            return Rectangle.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="Rectangle"/> structure that contains the union of the sequence of <see cref="Rectangle"/> structures.
        /// </summary>
        /// <param name="values">The rectangles to union.</param>
        /// <returns>
        /// A <see cref="Rectangle"/> structure that bounds the union of the sequence of <see cref="Rectangle"/> structures.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle Union(IEnumerable<Rectangle> values)
        {
            if (values == null)
            {
                throw new ArgumentNullException(nameof(values));
            }

            Rectangle result = Rectangle.Empty;
            foreach (Rectangle value in values)
            {
                result.Union(value);
            }

            return result;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Rectangle other) => other.x == this.x && other.y == this.y && other.w == this.w && other.h == this.h;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is Rectangle))
            {
                return false;
            }

            return this.Equals((Rectangle)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y ^ (int)this.w ^ (int)this.h);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " +
            this.y.ToString(CultureInfo.CurrentCulture) + " " +
            this.w.ToString(CultureInfo.CurrentCulture) + " " +
            this.h.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = this.w = this.h = 0;

        /// <summary>
        /// Determines if the specified point is contained within this <see cref="Rectangle"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the point defined by <paramref name="x"/> and <paramref name="y"/> is contained within this <see cref="Rectangle"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(int x, int y) => this.ContainsX(x) && this.ContainsY(y);

        /// <summary>
        /// Determines if the specified <see cref="Point"/> is contained within this <see cref="Rectangle"/> structure.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the <see cref="Point"/> represented by <paramref name="point"/> is contained within this <see cref="Rectangle"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Point point) => this.Contains(point.X, point.Y);

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle"/> structure.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle"/> structure; otherwise, <b>false</b>.
        /// </returns>
        public bool Contains(Rectangle rect)
        {
            return
                this.x <= rect.x && rect.x + rect.w <= this.x + this.w &&
                this.y <= rect.y && rect.y + rect.h <= this.y + this.h;
        }

        /// <summary>
        /// Determines if the specified x-coordinate is contained within this <see cref="Rectangle"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="x"/> is contained within this <see cref="Rectangle"/> along its x-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsX(int x) => x.Between(this.x, this.x + this.w - 1);

        /// <summary>
        /// Determines if the specified y-coordinate is contained within this <see cref="Rectangle"/> structure.
        /// </summary>
        /// <param name="y">The y-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="y"/> is contained within this <see cref="Rectangle"/> along its y-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsY(int y) => y.Between(this.y, this.y + this.h - 1);

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="Rectangle"/> and the specified <see cref="Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="Rectangle"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(Point point) => (float)Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="Rectangle"/> and the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="Rectangle"/> and <paramref name="rect"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(Rectangle rect) => (float)Math.Sqrt(this.DistanceToSquared(rect));

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="Rectangle"/> and the specified <see cref="Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="Rectangle"/> and <paramref name="point"/>.
        /// </returns>
        public int DistanceToSquared(Point point)
        {
            int dx = this.DistanceToX(point);
            int dy = this.DistanceToY(point);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="Rectangle"/> and the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="Rectangle"/> and <paramref name="rect"/>.
        /// </returns>
        public int DistanceToSquared(Rectangle rect)
        {
            int dx = this.DistanceToX(rect);
            int dy = this.DistanceToY(rect);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle"/> and the specified point along x-axis.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle"/> and <paramref name="x"/> along x-axis.
        /// </returns>
        public int DistanceToX(int x)
        {
            int distance = this.x - x;
            if (distance < 0)
            {
                distance = x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle"/> and the specified point along y-axis.
        /// </summary>
        /// <param name="y">The y-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle"/> and <paramref name="y"/> along y-axis.
        /// </returns>
        public int DistanceToY(int y)
        {
            int distance = this.y - y;
            if (distance < 0)
            {
                distance = y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle"/> and the specified <see cref="Point"/> along x-axis.
        /// </summary>
        /// <param name="point">The x-coordinate of the <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int DistanceToX(Point point) => this.DistanceToX(point.X);

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle"/> and the specified <see cref="Point"/> along y-axis.
        /// </summary>
        /// <param name="point">The y-coordinate of the <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int DistanceToY(Point point) => this.DistanceToX(point.Y);

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle"/> and the specified <see cref="Rectangle"/> along x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle"/> and <paramref name="rect"/> along x-axis.
        /// </returns>
        public int DistanceToX(Rectangle rect)
        {
            int distance = this.x - (rect.x + rect.w);
            if (distance < 0)
            {
                distance = rect.x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle"/> and the specified <see cref="Rectangle"/> along y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle"/> and <paramref name="rect"/> along y-axis.
        /// </returns>
        public int DistanceToY(Rectangle rect)
        {
            int distance = this.y - (rect.y + rect.h);
            if (distance < 0)
            {
                distance = rect.y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Expands or shrinks the rectangle by using the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="Rectangle"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle.Empty"/> rectangle.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(int dx, int dy)
        {
            this.x -= dx;
            this.w = MinMax.Max(this.w + (2 * dx), 0);

            this.y -= dy;
            this.h = MinMax.Max(this.h + (2 * dy), 0);
        }

        /// <summary>
        /// Expands or shrinks the rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(Size size) => this.Inflate(size.Width, size.Height);

        /// <summary>
        /// Expands or shrinks the rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="Rectangle"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle.Empty"/> rectangle.</para>
        /// </remarks>
        public void Inflate(int left, int top, int right, int bottom)
        {
            Rectangle result = Rectangle.Inflate(this, left, top, right, bottom);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle"/> with the intersection of itself and the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to intersect.</param>
        public void Intersect(Rectangle rect)
        {
            Rectangle result = Rectangle.Intersect(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Determines if this rectangle <see cref="Rectangle"/> intersects with the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWith(Rectangle rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w &&
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Determines if this rectangle <see cref="Rectangle"/> intersects with the specified <see cref="Rectangle"/> along its x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along x-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithX(Rectangle rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w;

        /// <summary>
        /// Determines if this rectangle <see cref="Rectangle"/> intersects with the specified <see cref="Rectangle"/> along its y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along y-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithY(Rectangle rect) =>
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Translates this <see cref="Rectangle"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(int dx, int dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="Rectangle"/> by the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(Point point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to the specified values.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(int x, int y, int width, int height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle"/> with the union of itself and the specified <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to union.</param>
        public void Union(Rectangle rect)
        {
            Rectangle result = Rectangle.Union(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle"/> with the union of itself and
        /// a specified rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="width">The width of the rectangular area with which to union.</param>
        /// <param name="height">The height of the rectangular area with which to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        public void Union(int x, int y, int width, int height)
        {
            Rectangle result = Rectangle.Union(this, x, y, width, height);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Scales the location and the dimensions of this <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(int dx, int dy)
        {
            this.x *= dx;
            this.y *= dy;
            this.w *= dx;
            this.h *= dy;
        }

        /// <summary>
        /// Scales the location and the dimensions of this <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        public void Scale(float dx, float dy)
        {
            float x1 = dx * this.x;
            float y1 = dy * this.y;
            float x2 = dx * (this.x + this.w);
            float y2 = dy * (this.y + this.h);

            // note: add epsilon to avoid rounding problems
            this.x = x1.Round();
            this.y = y1.Round();
            this.w = (int)Math.Floor(x2 - x1 + Rectangle.Eps);
            this.h = (int)Math.Floor(y2 - y1 + Rectangle.Eps);
        }

        /// <summary>
        /// Applies affine transformation described by the specified matrix to the <see cref="Rectangle"/>.
        /// </summary>
        /// <param name="matrix">The transformation matrix.</param>
        public void Transform(System.Windows.Media.Matrix matrix)
        {
            // convert three corner points out of four
            (double x, double y) tr = TransformPoint(this.x + this.w, this.y);
            (double x, double y) br = TransformPoint(this.x + this.w, this.y + this.h);
            (double x, double y) bl = TransformPoint(this.x, this.y + this.h);

            // find boundaries of new rectangle
            double x1 = MinMax.Min(bl.x, tr.x, br.x);
            double x2 = MinMax.Max(bl.x, tr.x, br.x);
            double y1 = MinMax.Min(bl.y, tr.y, br.y);
            double y2 = MinMax.Max(bl.y, tr.y, br.y);

            // note: add epsilon to avoid rounding problems
            this.x = x1.Round();
            this.y = y1.Round();
            this.w = (int)Math.Floor(x2 - x1 + Rectangle.Eps);
            this.h = (int)Math.Floor(y2 - y1 + Rectangle.Eps);

            (double x, double y) TransformPoint(int x, int y)
            {
                return ((matrix.M11 * x) + (matrix.M12 * y) + matrix.OffsetX, (matrix.M21 * x) + (matrix.M22 * y) + matrix.OffsetY);
            }
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="Rectangle"/> to <see cref="string"/>.
    /// </summary>
    internal class RectangleConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleConverter"/> class.
        /// </summary>
        public RectangleConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "RectangleConverter", destType.ToString()));
            }

            return ((Rectangle)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return Rectangle.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "RectangleConverter", value.GetType().ToString()));
            }

            return Rectangle.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="Rectangle"/> struct.
    /// </summary>
    public class RectangleJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is Rectangle rect)
            {
                writer.WriteValue(rect.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting rectangle. Expected Rectangle, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to Rectangle.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing rectangle. Expected String, got {0}.",
                    reader.TokenType));
            }

            return Rectangle.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="Rectangle"/> objects,
    /// first by <see cref="Rectangle.Left"/> then by <see cref="Rectangle.Right"/>, <see cref="Rectangle.Bottom"/> and <see cref="Rectangle.Top"/>.
    /// </summary>
    public class RectangleLRBTComparer : IComparer<Rectangle>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleLRBTComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleLRBTComparer"/> object.
        /// </value>
        public static RectangleLRBTComparer Default { get; } = new RectangleLRBTComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Rectangle x, Rectangle y)
        {
            int res = x.Left - y.Left;
            if (res == 0)
            {
                res = x.Right - y.Right;
                if (res == 0)
                {
                    res = x.Bottom - y.Bottom;
                    if (res == 0)
                    {
                        res = x.Top - y.Top;
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="Rectangle"/> objects,
    /// first by <see cref="Rectangle.Top"/> then by <see cref="Rectangle.Bottom"/>, <see cref="Rectangle.Left"/> and <see cref="Rectangle.Right"/>.
    /// </summary>
    public class RectangleTBLRComparer : IComparer<Rectangle>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleTBLRComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleTBLRComparer"/> object.
        /// </value>
        public static RectangleTBLRComparer Default { get; } = new RectangleTBLRComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Rectangle x, Rectangle y)
        {
            int res = x.Top - y.Top;
            if (res == 0)
            {
                res = x.Bottom - y.Bottom;
                if (res == 0)
                {
                    res = x.Left - y.Left;
                    if (res == 0)
                    {
                        res = x.Right - y.Right;
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="Rectangle"/> objects,
    /// first by <see cref="Rectangle.Left"/> then by <see cref="Rectangle.Top"/>, <see cref="Rectangle.Right"/> and <see cref="Rectangle.Bottom"/>.
    /// </summary>
    public class RectangleLTRBComparer : IComparer<Rectangle>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleLTRBComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleLTRBComparer"/> object.
        /// </value>
        public static RectangleLTRBComparer Default { get; } = new RectangleLTRBComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Rectangle x, Rectangle y)
        {
            int res = x.Left - y.Left;
            if (res == 0)
            {
                res = x.Top - y.Top;
                if (res == 0)
                {
                    res = x.Right - y.Right;
                    if (res == 0)
                    {
                        res = x.Bottom - y.Bottom;
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Describes the width, height, and location of a rectangle in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(RectangleFConverter))]
    [JsonConverter(typeof(RectangleFJsonConverter))]
    public struct RectangleF
        : IEquatable<RectangleF>
    {
        /// <summary>
        /// Represents a a rectangle with no position or area.
        /// </summary>
        /// <value>
        /// The empty rectangle, which has <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> property values of 0.
        /// </value>
        public static readonly RectangleF Empty;

        /// <summary>
        /// The x-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private float x;

        /// <summary>
        /// The y-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private float y;

        /// <summary>
        /// The rectangle width.
        /// </summary>
        private float w;

        /// <summary>
        /// The rectangle height.
        /// </summary>
        private float h;

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleF"/> struct
        /// that has the specified x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleF(float x, float y, float width, float height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleF"/> struct
        /// with the specified location and size.
        /// </summary>
        /// <param name="location">The x- and y-coordinates of the top-left corner of the rectangle.</param>
        /// <param name="size">The dimensions of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleF(PointF location, SizeF size)
        {
            this.x = location.X;
            this.y = location.Y;
            this.w = size.Width;
            this.h = size.Height;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleF"/> struct
        /// using two corner points.
        /// </summary>
        /// <param name="pt1">The first point.</param>
        /// <param name="pt2">The second point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleF(PointF pt1, PointF pt2)
        {
            if (pt2.X >= pt1.X)
            {
                this.x = pt1.X;
                this.w = pt2.X - pt1.X;
            }
            else
            {
                this.x = pt2.X;
                this.w = pt1.X - pt2.X;
            }

            if (pt2.Y >= pt1.Y)
            {
                this.y = pt1.Y;
                this.h = pt2.Y - pt1.Y;
            }
            else
            {
                this.y = pt2.Y;
                this.h = pt1.Y - pt2.Y;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleF"/> struct from the <see cref="System.Drawing.Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="System.Drawing.Rectangle"/> that contains the position of the point.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Rectangle.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Rectangle.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleF(System.Drawing.Rectangle rect)
        {
            this.x = rect.X;
            this.y = rect.Y;
            this.w = rect.Width >= 0 ? rect.Width : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = rect.Height >= 0 ? rect.Height : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Left"/> property.</para>
        /// <para>Changing the <see cref="X"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="RectangleF"/>.</para>
        /// </remarks>
        public float X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Top"/> property.</para>
        /// <para>Changing the <see cref="Y"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="RectangleF"/>.</para>
        /// </remarks>
        public float Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets or sets the width of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the width of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Width"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Width"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="RectangleF"/>.
        /// </remarks>
        public float Width
        {
            get => this.w;
            set => this.w = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleWidth);
        }

        /// <summary>
        /// Gets or sets the height of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the height of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Height"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Height"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="RectangleF"/>.
        /// </remarks>
        public float Height
        {
            get => this.h;
            set => this.h = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="X"/> property.
        /// </remarks>
        public float Left => this.x;

        /// <summary>
        /// Gets the x-coordinate of the right side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the right side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Right"/> property represents the x-coordinate of the first point at the right edge of the rectangle that is not contained in the <see cref="RectangleF"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Width"/> properties.</para>
        /// </remarks>
        public float Right => this.x + this.w;

        /// <summary>
        /// Gets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="Y"/> property.
        /// </remarks>
        public float Top => this.y;

        /// <summary>
        /// Gets the y-coordinate of the bottom side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the bottom side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Bottom"/> property represents the y-coordinate of the first point at the bottom edge of the rectangle that is not contained in the <see cref="RectangleF"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="Y"/> and <see cref="Height"/> properties.</para>
        /// </remarks>
        public float Bottom => this.y + this.h;

        /// <summary>
        /// Gets a value indicating whether all numeric properties of this <see cref="RectangleF"/> have value of zero.
        /// </summary>
        /// <value>
        /// <b>true</b> if <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/> and <see cref="Height"/> properties are zero; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0 && this.w == 0 && this.h == 0;

        /// <summary>
        /// Gets the location of this <see cref="RectangleF"/>.
        /// </summary>
        /// <value>
        /// The <see cref="PointF"/> struct that contains the x- and y-coordinates of the top-left corner of the rectangle.
        /// </value>
        public PointF Location => new PointF(this.x, this.y);

        /// <summary>
        /// Gets the size of this <see cref="RectangleF"/>.
        /// </summary>
        /// <value>
        /// The <see cref="SizeF"/> struct that contains rectangle dimensions.
        /// </value>
        public SizeF Size => new SizeF(this.w, this.h);

        /// <summary>
        /// Gets the area of this <see cref="RectangleF"/>.
        /// </summary>
        /// <value>
        /// <see cref="Width"/> * <see cref="Height"/>.
        /// </value>
        public float Area => this.w * this.h;

        /// <summary>
        /// Gets the center of this <see cref="RectangleF"/> along x-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="RectangleF"/> along x-axis.
        /// </value>
        public float CenterX => this.x + (this.w / 2);

        /// <summary>
        /// Gets the center of this <see cref="RectangleF"/> along y-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="RectangleF"/> along y-axis.
        /// </value>
        public float CenterY => this.y + (this.h / 2);

        /// <summary>
        /// Gets the center <see cref="PointF"/> of this <see cref="RectangleF"/>.
        /// </summary>
        /// <value>
        /// The center <see cref="PointF"/> of this <see cref="RectangleF"/>.
        /// </value>
        public PointF CenterPoint => new PointF(this.x + (this.w / 2), this.y + (this.h / 2));

        /// <summary>
        /// Compares two <see cref="RectangleF"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="RectangleF"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="RectangleF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="RectangleF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(RectangleF left, RectangleF right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="RectangleF"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="RectangleF"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="RectangleF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="RectangleF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, or <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(RectangleF left, RectangleF right) => !left.Equals(right);

        /// <summary>
        /// Creates a <see cref="RectangleF"/> structure with the specified edge locations.
        /// </summary>
        /// <param name="left">The x-coordinate of the upper-left corner of this <see cref="RectangleF"/> structure.</param>
        /// <param name="top">The y-coordinate of the upper-left corner of this <see cref="RectangleF"/> structure.</param>
        /// <param name="right">The x-coordinate of the lower-right corner of this <see cref="RectangleF"/> structure.</param>
        /// <param name="bottom">The y-coordinate of the lower-right corner of this <see cref="RectangleF"/> structure.</param>
        /// <returns>The new <see cref="RectangleF"/> that this method creates.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF FromLTRB(float left, float top, float right, float bottom) => new RectangleF(left, top, right - left, bottom - top);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="RectangleF"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleF.Empty"/> rectangle.</para>
        /// </remarks>
        public static RectangleF Inflate(RectangleF rect, float dx, float dy)
        {
            return new RectangleF(
                rect.X - dx,
                rect.Y - dy,
                MinMax.Max(rect.w + (2 * dx), 0),
                MinMax.Max(rect.h + (2 * dy), 0));
        }

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF Inflate(RectangleF rect, SizeF size) => RectangleF.Inflate(rect, size.Width, size.Height);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="RectangleF"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleF.Empty"/> rectangle.</para>
        /// </remarks>
        public static RectangleF Inflate(RectangleF rect, float left, float top, float right, float bottom)
        {
            return new RectangleF(
                rect.X - left,
                rect.Y - top,
                MinMax.Max(rect.w + left + right, 0),
                MinMax.Max(rect.h + top + bottom, 0));
        }

        /// <summary>
        /// Returns a <see cref="RectangleF"/> structure that represents the intersection of two other <see cref="RectangleF"/> structures.
        /// If there is no intersection, an empty <see cref="RectangleF"/> is returned.
        /// </summary>
        /// <param name="rect1">The first rectangle to intersect.</param>
        /// <param name="rect2">The second rectangle to intersect.</param>
        /// <returns>
        /// The intersection of the two rectangles,
        /// or <see cref="RectangleF.Empty"/> if no intersection exists.
        /// </returns>
        public static RectangleF Intersect(RectangleF rect1, RectangleF rect2)
        {
            float x1 = MinMax.Max(rect1.x, rect2.x);
            float x2 = MinMax.Min(rect1.x + rect1.w, rect2.x + rect2.w);
            float y1 = MinMax.Max(rect1.y, rect2.y);
            float y2 = MinMax.Min(rect1.y + rect1.h, rect2.y + rect2.h);

            return x2 >= x1 && y2 >= y1 ? RectangleF.FromLTRB(x1, y1, x2, y2) : RectangleF.Empty;
        }

        /// <summary>
        /// Translates the specified <see cref="RectangleF"/> by the specified amount.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="RectangleF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF Offset(RectangleF rect, float dx, float dy) => new RectangleF(rect.x + dx, rect.y + dy, rect.w, rect.h);

        /// <summary>
        /// Translates the specified <see cref="RectangleF"/> by the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to translate.</param>
        /// <param name="offset">The <see cref="PointF"/> that contains the offset for the <paramref name="rect"/>.</param>
        /// <returns>The translated <see cref="RectangleF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF Offset(RectangleF rect, PointF offset) => RectangleF.Offset(rect, offset.X, offset.Y);

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleF"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="RectangleF"/> in the following format:X Y Width Height.</param>
        /// <returns>The <see cref="RectangleF"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of four values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static RectangleF Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 4 &&
                float.TryParse(split[0], out float x) &&
                float.TryParse(split[1], out float y) &&
                float.TryParse(split[2], out float w) &&
                float.TryParse(split[3], out float h))
            {
                return new RectangleF(x, y, w, h);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidRectangleFormat, nameof(value));
            }
        }

        /// <summary>
        /// Creates a <see cref="RectangleF"/> that results from scaling the location and dimensions of specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to scale.</param>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        /// <returns>The resulting <see cref="RectangleF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF Scale(RectangleF rect, float dx, float dy) =>
            new RectangleF(rect.x * dx, rect.y * dy, rect.w * dx, rect.h * dy);

#if false
        /// <summary>
        /// Scales the specified <see cref="RectangleF"/> location.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="RectangleF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF Scale(RectangleF rect, float dx, float dy)
        {
            return new RectangleF((dx * rect.x).Round(), (dy * rect.y).Round());
        }
#endif

        /// <summary>
        /// Returns a <see cref="RectangleF"/> structure that contains the union of two other <see cref="RectangleF"/> structures.
        /// </summary>
        /// <param name="rect1">The first rectangle to union.</param>
        /// <param name="rect2">The second rectangle to union.</param>
        /// <returns>
        /// The <see cref="RectangleF"/> structure that bounds the union of the two <see cref="RectangleF"/> structures.
        /// </returns>
        public static RectangleF Union(RectangleF rect1, RectangleF rect2)
        {
            if (rect1.IsEmpty)
            {
                return rect2;
            }

            if (rect2.IsEmpty)
            {
                return rect1;
            }

            float x1 = MinMax.Min(rect1.x, rect2.x);
            float x2 = MinMax.Max(rect1.x + rect1.w, rect2.x + rect2.w);
            float y1 = MinMax.Min(rect1.y, rect2.y);
            float y2 = MinMax.Max(rect1.y + rect1.h, rect2.y + rect2.h);

            return RectangleF.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="RectangleF"/> structure that contains the union of a <see cref="RectangleF"/> structure
        /// and a rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="rect">The first rectangle to union.</param>
        /// <param name="x">The x-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="width">The width of the second rectangle to union.</param>
        /// <param name="height">The height of the second rectangle to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        /// <returns>
        /// The <see cref="RectangleF"/> structure that bounds the union of the <see cref="RectangleF"/> structure and a rectangular area.
        /// </returns>
        public static RectangleF Union(RectangleF rect, float x, float y, float width, float height)
        {
            if (rect.IsEmpty)
            {
                return new RectangleF(x, y, width, height);
            }

            if (x == 0 && y == 0 && width == 0 && height == 0)
            {
                return rect;
            }

            if (width < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            }

            if (height < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
            }

            float x1 = MinMax.Min(rect.x, x);
            float x2 = MinMax.Max(rect.x + rect.w, x + width);
            float y1 = MinMax.Min(rect.y, y);
            float y2 = MinMax.Max(rect.y + rect.h, y + height);

            return RectangleF.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="RectangleF"/> structure that contains the union of the sequence of <see cref="RectangleF"/> structures.
        /// </summary>
        /// <param name="values">The rectangles to union.</param>
        /// <returns>
        /// A <see cref="RectangleF"/> structure that bounds the union of the sequence of <see cref="RectangleF"/> structures.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleF Union(IEnumerable<RectangleF> values)
        {
            if (values == null)
            {
                throw new ArgumentNullException(nameof(values));
            }

            RectangleF result = RectangleF.Empty;
            foreach (RectangleF value in values)
            {
                result.Union(value);
            }

            return result;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(RectangleF other) => other.x == this.x && other.y == this.y && other.w == this.w && other.h == this.h;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is RectangleF))
            {
                return false;
            }

            return this.Equals((RectangleF)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y ^ (int)this.w ^ (int)this.h);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " +
            this.y.ToString(CultureInfo.CurrentCulture) + " " +
            this.w.ToString(CultureInfo.CurrentCulture) + " " +
            this.h.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = this.w = this.h = 0;

        /// <summary>
        /// Determines if the specified point is contained within this <see cref="RectangleF"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the point defined by <paramref name="x"/> and <paramref name="y"/> is contained within this <see cref="RectangleF"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(float x, float y) => this.ContainsX(x) && this.ContainsY(y);

        /// <summary>
        /// Determines if the specified <see cref="PointF"/> is contained within this <see cref="RectangleF"/> structure.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the <see cref="PointF"/> represented by <paramref name="point"/> is contained within this <see cref="RectangleF"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(PointF point) => this.Contains(point.X, point.Y);

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="RectangleF"/> structure.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="RectangleF"/> structure; otherwise, <b>false</b>.
        /// </returns>
        public bool Contains(RectangleF rect)
        {
            return
                this.x <= rect.x && rect.x + rect.w <= this.x + this.w &&
                this.y <= rect.y && rect.y + rect.h <= this.y + this.h;
        }

        /// <summary>
        /// Determines if the specified x-coordinate is contained within this <see cref="RectangleF"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="x"/> is contained within this <see cref="RectangleF"/> along its x-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsX(float x) => x.Between(this.x, this.x + this.w - 1);

        /// <summary>
        /// Determines if the specified y-coordinate is contained within this <see cref="RectangleF"/> structure.
        /// </summary>
        /// <param name="y">The y-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="y"/> is contained within this <see cref="RectangleF"/> along its y-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsY(float y) => y.Between(this.y, this.y + this.h - 1);

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="RectangleF"/> and the specified <see cref="PointF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="RectangleF"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(PointF point) => (float)Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="RectangleF"/> and the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="RectangleF"/> and <paramref name="rect"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(RectangleF rect) => (float)Math.Sqrt(this.DistanceToSquared(rect));

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="RectangleF"/> and the specified <see cref="PointF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="RectangleF"/> and <paramref name="point"/>.
        /// </returns>
        public float DistanceToSquared(PointF point)
        {
            float dx = this.DistanceToX(point);
            float dy = this.DistanceToY(point);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="RectangleF"/> and the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="RectangleF"/> and <paramref name="rect"/>.
        /// </returns>
        public float DistanceToSquared(RectangleF rect)
        {
            float dx = this.DistanceToX(rect);
            float dy = this.DistanceToY(rect);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleF"/> and the specified point along x-axis.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleF"/> and <paramref name="x"/> along x-axis.
        /// </returns>
        public float DistanceToX(float x)
        {
            float distance = this.x - x;
            if (distance < 0)
            {
                distance = x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleF"/> and the specified point along y-axis.
        /// </summary>
        /// <param name="y">The y-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleF"/> and <paramref name="y"/> along y-axis.
        /// </returns>
        public float DistanceToY(float y)
        {
            float distance = this.y - y;
            if (distance < 0)
            {
                distance = y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleF"/> and the specified <see cref="PointF"/> along x-axis.
        /// </summary>
        /// <param name="point">The x-coordinate of the <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleF"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceToX(PointF point) => this.DistanceToX(point.X);

        /// <summary>
        /// Computes the distance between this <see cref="RectangleF"/> and the specified <see cref="PointF"/> along y-axis.
        /// </summary>
        /// <param name="point">The y-coordinate of the <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleF"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceToY(PointF point) => this.DistanceToX(point.Y);

        /// <summary>
        /// Computes the distance between this <see cref="RectangleF"/> and the specified <see cref="RectangleF"/> along x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleF"/> and <paramref name="rect"/> along x-axis.
        /// </returns>
        public float DistanceToX(RectangleF rect)
        {
            float distance = this.x - (rect.x + rect.w);
            if (distance < 0)
            {
                distance = rect.x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleF"/> and the specified <see cref="RectangleF"/> along y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleF"/> and <paramref name="rect"/> along y-axis.
        /// </returns>
        public float DistanceToY(RectangleF rect)
        {
            float distance = this.y - (rect.y + rect.h);
            if (distance < 0)
            {
                distance = rect.y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Expands or shrinks the rectangle by using the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="RectangleF"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleF.Empty"/> rectangle.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(float dx, float dy)
        {
            this.x -= dx;
            this.w = MinMax.Max(this.w + (2 * dx), 0);

            this.y -= dy;
            this.h = MinMax.Max(this.h + (2 * dy), 0);
        }

        /// <summary>
        /// Expands or shrinks the rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(SizeF size) => this.Inflate(size.Width, size.Height);

        /// <summary>
        /// Expands or shrinks the rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="RectangleF"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleF.Empty"/> rectangle.</para>
        /// </remarks>
        public void Inflate(float left, float top, float right, float bottom)
        {
            RectangleF result = RectangleF.Inflate(this, left, top, right, bottom);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="RectangleF"/> with the intersection of itself and the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to intersect.</param>
        public void Intersect(RectangleF rect)
        {
            RectangleF result = RectangleF.Intersect(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Determines if this rectangle <see cref="RectangleF"/> intersects with the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWith(RectangleF rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w &&
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Determines if this rectangle <see cref="RectangleF"/> intersects with the specified <see cref="RectangleF"/> along its x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along x-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithX(RectangleF rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w;

        /// <summary>
        /// Determines if this rectangle <see cref="RectangleF"/> intersects with the specified <see cref="RectangleF"/> along its y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleF"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along y-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithY(RectangleF rect) =>
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Translates this <see cref="RectangleF"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(float dx, float dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="RectangleF"/> by the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(PointF point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to the specified values.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(float x, float y, float width, float height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Replaces this <see cref="RectangleF"/> with the union of itself and the specified <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to union.</param>
        public void Union(RectangleF rect)
        {
            RectangleF result = RectangleF.Union(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="RectangleF"/> with the union of itself and
        /// a specified rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="width">The width of the rectangular area with which to union.</param>
        /// <param name="height">The height of the rectangular area with which to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        public void Union(float x, float y, float width, float height)
        {
            RectangleF result = RectangleF.Union(this, x, y, width, height);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Scales the location and the dimensions of this <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(float dx, float dy)
        {
            this.x *= dx;
            this.y *= dy;
            this.w *= dx;
            this.h *= dy;
        }

        /// <summary>
        /// Applies affine transformation described by the specified matrix to the <see cref="RectangleF"/>.
        /// </summary>
        /// <param name="matrix">The transformation matrix.</param>
        public void Transform(System.Windows.Media.Matrix matrix)
        {
            // convert three corner points out of four
            (double x, double y) tr = TransformPoint(this.x + this.w, this.y);
            (double x, double y) br = TransformPoint(this.x + this.w, this.y + this.h);
            (double x, double y) bl = TransformPoint(this.x, this.y + this.h);

            // find boundaries of new rectangle
            double x1 = MinMax.Min(bl.x, tr.x, br.x);
            double x2 = MinMax.Max(bl.x, tr.x, br.x);
            double y1 = MinMax.Min(bl.y, tr.y, br.y);
            double y2 = MinMax.Max(bl.y, tr.y, br.y);

            this.x = (float)(x1);
            this.y = (float)(y1);
            this.w = (float)(x2 - x1);
            this.h = (float)(y2 - y1);

            (double x, double y) TransformPoint(float x, float y)
            {
                return ((matrix.M11 * x) + (matrix.M12 * y) + matrix.OffsetX, (matrix.M21 * x) + (matrix.M22 * y) + matrix.OffsetY);
            }
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="RectangleF"/> to <see cref="string"/>.
    /// </summary>
    internal class RectangleFConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleFConverter"/> class.
        /// </summary>
        public RectangleFConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "RectangleFConverter", destType.ToString()));
            }

            return ((RectangleF)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return RectangleF.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "RectangleFConverter", value.GetType().ToString()));
            }

            return RectangleF.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="RectangleF"/> struct.
    /// </summary>
    public class RectangleFJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is RectangleF rect)
            {
                writer.WriteValue(rect.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting rectangle. Expected RectangleF, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to RectangleF.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing rectangle. Expected String, got {0}.",
                    reader.TokenType));
            }

            return RectangleF.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="RectangleF"/> objects,
    /// first by <see cref="RectangleF.Left"/> then by <see cref="RectangleF.Right"/>, <see cref="RectangleF.Bottom"/> and <see cref="RectangleF.Top"/>.
    /// </summary>
    public class RectangleFLRBTComparer : IComparer<RectangleF>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleFLRBTComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleFLRBTComparer"/> object.
        /// </value>
        public static RectangleFLRBTComparer Default { get; } = new RectangleFLRBTComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(RectangleF x, RectangleF y)
        {
            int res = x.Left.CompareTo(y.Left);
            if (res == 0)
            {
                res = x.Right.CompareTo(y.Right);
                if (res == 0)
                {
                    res = x.Bottom.CompareTo(y.Bottom);
                    if (res == 0)
                    {
                        res = x.Top.CompareTo(y.Top);
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="RectangleF"/> objects,
    /// first by <see cref="RectangleF.Top"/> then by <see cref="RectangleF.Bottom"/>, <see cref="RectangleF.Left"/> and <see cref="RectangleF.Right"/>.
    /// </summary>
    public class RectangleFTBLRComparer : IComparer<RectangleF>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleFTBLRComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleFTBLRComparer"/> object.
        /// </value>
        public static RectangleFTBLRComparer Default { get; } = new RectangleFTBLRComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(RectangleF x, RectangleF y)
        {
            int res = x.Top.CompareTo(y.Top);
            if (res == 0)
            {
                res = x.Bottom.CompareTo(y.Bottom);
                if (res == 0)
                {
                    res = x.Left.CompareTo(y.Left);
                    if (res == 0)
                    {
                        res = x.Right.CompareTo(y.Right);
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="RectangleF"/> objects,
    /// first by <see cref="RectangleF.Left"/> then by <see cref="RectangleF.Top"/>, <see cref="RectangleF.Right"/> and <see cref="RectangleF.Bottom"/>.
    /// </summary>
    public class RectangleFLTRBComparer : IComparer<RectangleF>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleFLTRBComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleFLTRBComparer"/> object.
        /// </value>
        public static RectangleFLTRBComparer Default { get; } = new RectangleFLTRBComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(RectangleF x, RectangleF y)
        {
            int res = x.Left.CompareTo(y.Left);
            if (res == 0)
            {
                res = x.Top.CompareTo(y.Top);
                if (res == 0)
                {
                    res = x.Right.CompareTo(y.Right);
                    if (res == 0)
                    {
                        res = x.Bottom.CompareTo(y.Bottom);
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Describes the width, height, and location of a rectangle in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(RectangleDConverter))]
    [JsonConverter(typeof(RectangleDJsonConverter))]
    public struct RectangleD
        : IEquatable<RectangleD>
    {
        /// <summary>
        /// Represents a a rectangle with no position or area.
        /// </summary>
        /// <value>
        /// The empty rectangle, which has <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> property values of 0.
        /// </value>
        public static readonly RectangleD Empty;

        /// <summary>
        /// The x-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private double x;

        /// <summary>
        /// The y-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private double y;

        /// <summary>
        /// The rectangle width.
        /// </summary>
        private double w;

        /// <summary>
        /// The rectangle height.
        /// </summary>
        private double h;

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleD"/> struct
        /// that has the specified x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleD(double x, double y, double width, double height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleD"/> struct
        /// with the specified location and size.
        /// </summary>
        /// <param name="location">The x- and y-coordinates of the top-left corner of the rectangle.</param>
        /// <param name="size">The dimensions of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleD(PointD location, SizeD size)
        {
            this.x = location.X;
            this.y = location.Y;
            this.w = size.Width;
            this.h = size.Height;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleD"/> struct
        /// using two corner points.
        /// </summary>
        /// <param name="pt1">The first point.</param>
        /// <param name="pt2">The second point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleD(PointD pt1, PointD pt2)
        {
            if (pt2.X >= pt1.X)
            {
                this.x = pt1.X;
                this.w = pt2.X - pt1.X;
            }
            else
            {
                this.x = pt2.X;
                this.w = pt1.X - pt2.X;
            }

            if (pt2.Y >= pt1.Y)
            {
                this.y = pt1.Y;
                this.h = pt2.Y - pt1.Y;
            }
            else
            {
                this.y = pt2.Y;
                this.h = pt1.Y - pt2.Y;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleD"/> struct from the <see cref="System.Drawing.Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="System.Drawing.Rectangle"/> that contains the position of the point.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Rectangle.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Rectangle.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RectangleD(System.Drawing.Rectangle rect)
        {
            this.x = rect.X;
            this.y = rect.Y;
            this.w = rect.Width >= 0 ? rect.Width : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = rect.Height >= 0 ? rect.Height : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Left"/> property.</para>
        /// <para>Changing the <see cref="X"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="RectangleD"/>.</para>
        /// </remarks>
        public double X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Top"/> property.</para>
        /// <para>Changing the <see cref="Y"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="RectangleD"/>.</para>
        /// </remarks>
        public double Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets or sets the width of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the width of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Width"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Width"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="RectangleD"/>.
        /// </remarks>
        public double Width
        {
            get => this.w;
            set => this.w = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleWidth);
        }

        /// <summary>
        /// Gets or sets the height of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the height of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Height"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Height"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="RectangleD"/>.
        /// </remarks>
        public double Height
        {
            get => this.h;
            set => this.h = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="X"/> property.
        /// </remarks>
        public double Left => this.x;

        /// <summary>
        /// Gets the x-coordinate of the right side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the right side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Right"/> property represents the x-coordinate of the first point at the right edge of the rectangle that is not contained in the <see cref="RectangleD"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Width"/> properties.</para>
        /// </remarks>
        public double Right => this.x + this.w;

        /// <summary>
        /// Gets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="Y"/> property.
        /// </remarks>
        public double Top => this.y;

        /// <summary>
        /// Gets the y-coordinate of the bottom side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the bottom side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Bottom"/> property represents the y-coordinate of the first point at the bottom edge of the rectangle that is not contained in the <see cref="RectangleD"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="Y"/> and <see cref="Height"/> properties.</para>
        /// </remarks>
        public double Bottom => this.y + this.h;

        /// <summary>
        /// Gets a value indicating whether all numeric properties of this <see cref="RectangleD"/> have value of zero.
        /// </summary>
        /// <value>
        /// <b>true</b> if <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/> and <see cref="Height"/> properties are zero; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0 && this.w == 0 && this.h == 0;

        /// <summary>
        /// Gets the location of this <see cref="RectangleD"/>.
        /// </summary>
        /// <value>
        /// The <see cref="PointD"/> struct that contains the x- and y-coordinates of the top-left corner of the rectangle.
        /// </value>
        public PointD Location => new PointD(this.x, this.y);

        /// <summary>
        /// Gets the size of this <see cref="RectangleD"/>.
        /// </summary>
        /// <value>
        /// The <see cref="SizeD"/> struct that contains rectangle dimensions.
        /// </value>
        public SizeD Size => new SizeD(this.w, this.h);

        /// <summary>
        /// Gets the area of this <see cref="RectangleD"/>.
        /// </summary>
        /// <value>
        /// <see cref="Width"/> * <see cref="Height"/>.
        /// </value>
        public double Area => this.w * this.h;

        /// <summary>
        /// Gets the center of this <see cref="RectangleD"/> along x-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="RectangleD"/> along x-axis.
        /// </value>
        public double CenterX => this.x + (this.w / 2);

        /// <summary>
        /// Gets the center of this <see cref="RectangleD"/> along y-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="RectangleD"/> along y-axis.
        /// </value>
        public double CenterY => this.y + (this.h / 2);

        /// <summary>
        /// Gets the center <see cref="PointD"/> of this <see cref="RectangleD"/>.
        /// </summary>
        /// <value>
        /// The center <see cref="PointD"/> of this <see cref="RectangleD"/>.
        /// </value>
        public PointD CenterPoint => new PointD(this.x + (this.w / 2), this.y + (this.h / 2));

        /// <summary>
        /// Compares two <see cref="RectangleD"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="RectangleD"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="RectangleD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="RectangleD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(RectangleD left, RectangleD right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="RectangleD"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="RectangleD"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="RectangleD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="RectangleD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, or <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(RectangleD left, RectangleD right) => !left.Equals(right);

        /// <summary>
        /// Creates a <see cref="RectangleD"/> structure with the specified edge locations.
        /// </summary>
        /// <param name="left">The x-coordinate of the upper-left corner of this <see cref="RectangleD"/> structure.</param>
        /// <param name="top">The y-coordinate of the upper-left corner of this <see cref="RectangleD"/> structure.</param>
        /// <param name="right">The x-coordinate of the lower-right corner of this <see cref="RectangleD"/> structure.</param>
        /// <param name="bottom">The y-coordinate of the lower-right corner of this <see cref="RectangleD"/> structure.</param>
        /// <returns>The new <see cref="RectangleD"/> that this method creates.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD FromLTRB(double left, double top, double right, double bottom) => new RectangleD(left, top, right - left, bottom - top);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="RectangleD"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleD.Empty"/> rectangle.</para>
        /// </remarks>
        public static RectangleD Inflate(RectangleD rect, double dx, double dy)
        {
            return new RectangleD(
                rect.X - dx,
                rect.Y - dy,
                MinMax.Max(rect.w + (2 * dx), 0),
                MinMax.Max(rect.h + (2 * dy), 0));
        }

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD Inflate(RectangleD rect, SizeD size) => RectangleD.Inflate(rect, size.Width, size.Height);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="RectangleD"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleD.Empty"/> rectangle.</para>
        /// </remarks>
        public static RectangleD Inflate(RectangleD rect, double left, double top, double right, double bottom)
        {
            return new RectangleD(
                rect.X - left,
                rect.Y - top,
                MinMax.Max(rect.w + left + right, 0),
                MinMax.Max(rect.h + top + bottom, 0));
        }

        /// <summary>
        /// Returns a <see cref="RectangleD"/> structure that represents the intersection of two other <see cref="RectangleD"/> structures.
        /// If there is no intersection, an empty <see cref="RectangleD"/> is returned.
        /// </summary>
        /// <param name="rect1">The first rectangle to intersect.</param>
        /// <param name="rect2">The second rectangle to intersect.</param>
        /// <returns>
        /// The intersection of the two rectangles,
        /// or <see cref="RectangleD.Empty"/> if no intersection exists.
        /// </returns>
        public static RectangleD Intersect(RectangleD rect1, RectangleD rect2)
        {
            double x1 = MinMax.Max(rect1.x, rect2.x);
            double x2 = MinMax.Min(rect1.x + rect1.w, rect2.x + rect2.w);
            double y1 = MinMax.Max(rect1.y, rect2.y);
            double y2 = MinMax.Min(rect1.y + rect1.h, rect2.y + rect2.h);

            return x2 >= x1 && y2 >= y1 ? RectangleD.FromLTRB(x1, y1, x2, y2) : RectangleD.Empty;
        }

        /// <summary>
        /// Translates the specified <see cref="RectangleD"/> by the specified amount.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="RectangleD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD Offset(RectangleD rect, double dx, double dy) => new RectangleD(rect.x + dx, rect.y + dy, rect.w, rect.h);

        /// <summary>
        /// Translates the specified <see cref="RectangleD"/> by the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to translate.</param>
        /// <param name="offset">The <see cref="PointD"/> that contains the offset for the <paramref name="rect"/>.</param>
        /// <returns>The translated <see cref="RectangleD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD Offset(RectangleD rect, PointD offset) => RectangleD.Offset(rect, offset.X, offset.Y);

        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleD"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="RectangleD"/> in the following format:X Y Width Height.</param>
        /// <returns>The <see cref="RectangleD"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of four values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static RectangleD Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 4 &&
                double.TryParse(split[0], out double x) &&
                double.TryParse(split[1], out double y) &&
                double.TryParse(split[2], out double w) &&
                double.TryParse(split[3], out double h))
            {
                return new RectangleD(x, y, w, h);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidRectangleFormat, nameof(value));
            }
        }

        /// <summary>
        /// Creates a <see cref="RectangleD"/> that results from scaling the location and dimensions of specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to scale.</param>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        /// <returns>The resulting <see cref="RectangleD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD Scale(RectangleD rect, double dx, double dy) =>
            new RectangleD(rect.x * dx, rect.y * dy, rect.w * dx, rect.h * dy);

#if false
        /// <summary>
        /// Scales the specified <see cref="RectangleD"/> location.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="RectangleD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD Scale(RectangleD rect, float dx, float dy)
        {
            return new RectangleD((dx * rect.x).Round(), (dy * rect.y).Round());
        }
#endif

        /// <summary>
        /// Returns a <see cref="RectangleD"/> structure that contains the union of two other <see cref="RectangleD"/> structures.
        /// </summary>
        /// <param name="rect1">The first rectangle to union.</param>
        /// <param name="rect2">The second rectangle to union.</param>
        /// <returns>
        /// The <see cref="RectangleD"/> structure that bounds the union of the two <see cref="RectangleD"/> structures.
        /// </returns>
        public static RectangleD Union(RectangleD rect1, RectangleD rect2)
        {
            if (rect1.IsEmpty)
            {
                return rect2;
            }

            if (rect2.IsEmpty)
            {
                return rect1;
            }

            double x1 = MinMax.Min(rect1.x, rect2.x);
            double x2 = MinMax.Max(rect1.x + rect1.w, rect2.x + rect2.w);
            double y1 = MinMax.Min(rect1.y, rect2.y);
            double y2 = MinMax.Max(rect1.y + rect1.h, rect2.y + rect2.h);

            return RectangleD.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="RectangleD"/> structure that contains the union of a <see cref="RectangleD"/> structure
        /// and a rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="rect">The first rectangle to union.</param>
        /// <param name="x">The x-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="width">The width of the second rectangle to union.</param>
        /// <param name="height">The height of the second rectangle to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        /// <returns>
        /// The <see cref="RectangleD"/> structure that bounds the union of the <see cref="RectangleD"/> structure and a rectangular area.
        /// </returns>
        public static RectangleD Union(RectangleD rect, double x, double y, double width, double height)
        {
            if (rect.IsEmpty)
            {
                return new RectangleD(x, y, width, height);
            }

            if (x == 0 && y == 0 && width == 0 && height == 0)
            {
                return rect;
            }

            if (width < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            }

            if (height < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
            }

            double x1 = MinMax.Min(rect.x, x);
            double x2 = MinMax.Max(rect.x + rect.w, x + width);
            double y1 = MinMax.Min(rect.y, y);
            double y2 = MinMax.Max(rect.y + rect.h, y + height);

            return RectangleD.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="RectangleD"/> structure that contains the union of the sequence of <see cref="RectangleD"/> structures.
        /// </summary>
        /// <param name="values">The rectangles to union.</param>
        /// <returns>
        /// A <see cref="RectangleD"/> structure that bounds the union of the sequence of <see cref="RectangleD"/> structures.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static RectangleD Union(IEnumerable<RectangleD> values)
        {
            if (values == null)
            {
                throw new ArgumentNullException(nameof(values));
            }

            RectangleD result = RectangleD.Empty;
            foreach (RectangleD value in values)
            {
                result.Union(value);
            }

            return result;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(RectangleD other) => other.x == this.x && other.y == this.y && other.w == this.w && other.h == this.h;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is RectangleD))
            {
                return false;
            }

            return this.Equals((RectangleD)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y ^ (int)this.w ^ (int)this.h);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " +
            this.y.ToString(CultureInfo.CurrentCulture) + " " +
            this.w.ToString(CultureInfo.CurrentCulture) + " " +
            this.h.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = this.w = this.h = 0;

        /// <summary>
        /// Determines if the specified point is contained within this <see cref="RectangleD"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the point defined by <paramref name="x"/> and <paramref name="y"/> is contained within this <see cref="RectangleD"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(double x, double y) => this.ContainsX(x) && this.ContainsY(y);

        /// <summary>
        /// Determines if the specified <see cref="PointD"/> is contained within this <see cref="RectangleD"/> structure.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the <see cref="PointD"/> represented by <paramref name="point"/> is contained within this <see cref="RectangleD"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(PointD point) => this.Contains(point.X, point.Y);

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="RectangleD"/> structure.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="RectangleD"/> structure; otherwise, <b>false</b>.
        /// </returns>
        public bool Contains(RectangleD rect)
        {
            return
                this.x <= rect.x && rect.x + rect.w <= this.x + this.w &&
                this.y <= rect.y && rect.y + rect.h <= this.y + this.h;
        }

        /// <summary>
        /// Determines if the specified x-coordinate is contained within this <see cref="RectangleD"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="x"/> is contained within this <see cref="RectangleD"/> along its x-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsX(double x) => x.Between(this.x, this.x + this.w - 1);

        /// <summary>
        /// Determines if the specified y-coordinate is contained within this <see cref="RectangleD"/> structure.
        /// </summary>
        /// <param name="y">The y-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="y"/> is contained within this <see cref="RectangleD"/> along its y-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsY(double y) => y.Between(this.y, this.y + this.h - 1);

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="RectangleD"/> and the specified <see cref="PointD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="RectangleD"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(PointD point) => (float)Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="RectangleD"/> and the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="RectangleD"/> and <paramref name="rect"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(RectangleD rect) => (float)Math.Sqrt(this.DistanceToSquared(rect));

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="RectangleD"/> and the specified <see cref="PointD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="RectangleD"/> and <paramref name="point"/>.
        /// </returns>
        public double DistanceToSquared(PointD point)
        {
            double dx = this.DistanceToX(point);
            double dy = this.DistanceToY(point);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="RectangleD"/> and the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="RectangleD"/> and <paramref name="rect"/>.
        /// </returns>
        public double DistanceToSquared(RectangleD rect)
        {
            double dx = this.DistanceToX(rect);
            double dy = this.DistanceToY(rect);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleD"/> and the specified point along x-axis.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleD"/> and <paramref name="x"/> along x-axis.
        /// </returns>
        public double DistanceToX(double x)
        {
            double distance = this.x - x;
            if (distance < 0)
            {
                distance = x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleD"/> and the specified point along y-axis.
        /// </summary>
        /// <param name="y">The y-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleD"/> and <paramref name="y"/> along y-axis.
        /// </returns>
        public double DistanceToY(double y)
        {
            double distance = this.y - y;
            if (distance < 0)
            {
                distance = y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleD"/> and the specified <see cref="PointD"/> along x-axis.
        /// </summary>
        /// <param name="point">The x-coordinate of the <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleD"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceToX(PointD point) => this.DistanceToX(point.X);

        /// <summary>
        /// Computes the distance between this <see cref="RectangleD"/> and the specified <see cref="PointD"/> along y-axis.
        /// </summary>
        /// <param name="point">The y-coordinate of the <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleD"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceToY(PointD point) => this.DistanceToX(point.Y);

        /// <summary>
        /// Computes the distance between this <see cref="RectangleD"/> and the specified <see cref="RectangleD"/> along x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleD"/> and <paramref name="rect"/> along x-axis.
        /// </returns>
        public double DistanceToX(RectangleD rect)
        {
            double distance = this.x - (rect.x + rect.w);
            if (distance < 0)
            {
                distance = rect.x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="RectangleD"/> and the specified <see cref="RectangleD"/> along y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="RectangleD"/> and <paramref name="rect"/> along y-axis.
        /// </returns>
        public double DistanceToY(RectangleD rect)
        {
            double distance = this.y - (rect.y + rect.h);
            if (distance < 0)
            {
                distance = rect.y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Expands or shrinks the rectangle by using the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="RectangleD"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleD.Empty"/> rectangle.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(double dx, double dy)
        {
            this.x -= dx;
            this.w = MinMax.Max(this.w + (2 * dx), 0);

            this.y -= dy;
            this.h = MinMax.Max(this.h + (2 * dy), 0);
        }

        /// <summary>
        /// Expands or shrinks the rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(SizeD size) => this.Inflate(size.Width, size.Height);

        /// <summary>
        /// Expands or shrinks the rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="RectangleD"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="RectangleD.Empty"/> rectangle.</para>
        /// </remarks>
        public void Inflate(double left, double top, double right, double bottom)
        {
            RectangleD result = RectangleD.Inflate(this, left, top, right, bottom);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="RectangleD"/> with the intersection of itself and the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to intersect.</param>
        public void Intersect(RectangleD rect)
        {
            RectangleD result = RectangleD.Intersect(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Determines if this rectangle <see cref="RectangleD"/> intersects with the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWith(RectangleD rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w &&
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Determines if this rectangle <see cref="RectangleD"/> intersects with the specified <see cref="RectangleD"/> along its x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along x-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithX(RectangleD rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w;

        /// <summary>
        /// Determines if this rectangle <see cref="RectangleD"/> intersects with the specified <see cref="RectangleD"/> along its y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="RectangleD"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along y-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithY(RectangleD rect) =>
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Translates this <see cref="RectangleD"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(double dx, double dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="RectangleD"/> by the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(PointD point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to the specified values.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(double x, double y, double width, double height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Replaces this <see cref="RectangleD"/> with the union of itself and the specified <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to union.</param>
        public void Union(RectangleD rect)
        {
            RectangleD result = RectangleD.Union(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="RectangleD"/> with the union of itself and
        /// a specified rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="width">The width of the rectangular area with which to union.</param>
        /// <param name="height">The height of the rectangular area with which to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        public void Union(double x, double y, double width, double height)
        {
            RectangleD result = RectangleD.Union(this, x, y, width, height);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Scales the location and the dimensions of this <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(double dx, double dy)
        {
            this.x *= dx;
            this.y *= dy;
            this.w *= dx;
            this.h *= dy;
        }

        /// <summary>
        /// Applies affine transformation described by the specified matrix to the <see cref="RectangleD"/>.
        /// </summary>
        /// <param name="matrix">The transformation matrix.</param>
        public void Transform(System.Windows.Media.Matrix matrix)
        {
            // convert three corner points out of four
            (double x, double y) tr = TransformPoint(this.x + this.w, this.y);
            (double x, double y) br = TransformPoint(this.x + this.w, this.y + this.h);
            (double x, double y) bl = TransformPoint(this.x, this.y + this.h);

            // find boundaries of new rectangle
            double x1 = MinMax.Min(bl.x, tr.x, br.x);
            double x2 = MinMax.Max(bl.x, tr.x, br.x);
            double y1 = MinMax.Min(bl.y, tr.y, br.y);
            double y2 = MinMax.Max(bl.y, tr.y, br.y);

            this.x = (double)(x1);
            this.y = (double)(y1);
            this.w = (double)(x2 - x1);
            this.h = (double)(y2 - y1);

            (double x, double y) TransformPoint(double x, double y)
            {
                return ((matrix.M11 * x) + (matrix.M12 * y) + matrix.OffsetX, (matrix.M21 * x) + (matrix.M22 * y) + matrix.OffsetY);
            }
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="RectangleD"/> to <see cref="string"/>.
    /// </summary>
    internal class RectangleDConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RectangleDConverter"/> class.
        /// </summary>
        public RectangleDConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "RectangleDConverter", destType.ToString()));
            }

            return ((RectangleD)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return RectangleD.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "RectangleDConverter", value.GetType().ToString()));
            }

            return RectangleD.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="RectangleD"/> struct.
    /// </summary>
    public class RectangleDJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is RectangleD rect)
            {
                writer.WriteValue(rect.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting rectangle. Expected RectangleD, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to RectangleD.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing rectangle. Expected String, got {0}.",
                    reader.TokenType));
            }

            return RectangleD.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="RectangleD"/> objects,
    /// first by <see cref="RectangleD.Left"/> then by <see cref="RectangleD.Right"/>, <see cref="RectangleD.Bottom"/> and <see cref="RectangleD.Top"/>.
    /// </summary>
    public class RectangleDLRBTComparer : IComparer<RectangleD>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleDLRBTComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleDLRBTComparer"/> object.
        /// </value>
        public static RectangleDLRBTComparer Default { get; } = new RectangleDLRBTComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(RectangleD x, RectangleD y)
        {
            int res = x.Left.CompareTo(y.Left);
            if (res == 0)
            {
                res = x.Right.CompareTo(y.Right);
                if (res == 0)
                {
                    res = x.Bottom.CompareTo(y.Bottom);
                    if (res == 0)
                    {
                        res = x.Top.CompareTo(y.Top);
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="RectangleD"/> objects,
    /// first by <see cref="RectangleD.Top"/> then by <see cref="RectangleD.Bottom"/>, <see cref="RectangleD.Left"/> and <see cref="RectangleD.Right"/>.
    /// </summary>
    public class RectangleDTBLRComparer : IComparer<RectangleD>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleDTBLRComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleDTBLRComparer"/> object.
        /// </value>
        public static RectangleDTBLRComparer Default { get; } = new RectangleDTBLRComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(RectangleD x, RectangleD y)
        {
            int res = x.Top.CompareTo(y.Top);
            if (res == 0)
            {
                res = x.Bottom.CompareTo(y.Bottom);
                if (res == 0)
                {
                    res = x.Left.CompareTo(y.Left);
                    if (res == 0)
                    {
                        res = x.Right.CompareTo(y.Right);
                    }
                }
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="RectangleD"/> objects,
    /// first by <see cref="RectangleD.Left"/> then by <see cref="RectangleD.Top"/>, <see cref="RectangleD.Right"/> and <see cref="RectangleD.Bottom"/>.
    /// </summary>
    public class RectangleDLTRBComparer : IComparer<RectangleD>
    {
        /// <summary>
        /// Gets a default <see cref="RectangleDLTRBComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="RectangleDLTRBComparer"/> object.
        /// </value>
        public static RectangleDLTRBComparer Default { get; } = new RectangleDLTRBComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(RectangleD x, RectangleD y)
        {
            int res = x.Left.CompareTo(y.Left);
            if (res == 0)
            {
                res = x.Top.CompareTo(y.Top);
                if (res == 0)
                {
                    res = x.Right.CompareTo(y.Right);
                    if (res == 0)
                    {
                        res = x.Bottom.CompareTo(y.Bottom);
                    }
                }
            }

            return res;
        }
    }
}