// -----------------------------------------------------------------------
// <copyright file="Rectangle.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Drawing
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using Genix.Core;
    using Newtonsoft.Json;

<#
    Tuple<string, string>[] classes = 
    {
        Tuple.Create("int", ""),
        Tuple.Create("float", "F"),
        Tuple.Create("double", "D"),
    };

    foreach (Tuple<string, string> cls in classes)
    {
        string type = cls.Item1;
        string suffix = cls.Item2;
#>

    /// <summary>
    /// Describes the width, height, and location of a rectangle in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(Rectangle<#=suffix#>Converter))]
    [JsonConverter(typeof(Rectangle<#=suffix#>JsonConverter))]
    public struct Rectangle<#=suffix#>
        : IEquatable<Rectangle<#=suffix#>>
    {
        /// <summary>
        /// Represents a a rectangle with no position or area.
        /// </summary>
        /// <value>
        /// The empty rectangle, which has <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> property values of 0.
        /// </value>
        public static readonly Rectangle<#=suffix#> Empty;
<# if (type == "int") { #>

        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const float Eps = 1e-8f;
<# } #>

        /// <summary>
        /// The x-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private <#=type#> x;

        /// <summary>
        /// The y-coordinate of the top-left corner of the rectangle.
        /// </summary>
        private <#=type#> y;

        /// <summary>
        /// The rectangle width.
        /// </summary>
        private <#=type#> w;

        /// <summary>
        /// The rectangle height.
        /// </summary>
        private <#=type#> h;

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle<#=suffix#>"/> struct
        /// that has the specified x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle<#=suffix#>(<#=type#> x, <#=type#> y, <#=type#> width, <#=type#> height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle<#=suffix#>"/> struct
        /// with the specified location and size.
        /// </summary>
        /// <param name="location">The x- and y-coordinates of the top-left corner of the rectangle.</param>
        /// <param name="size">The dimensions of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle<#=suffix#>(Point<#=suffix#> location, Size<#=suffix#> size)
        {
            this.x = location.X;
            this.y = location.Y;
            this.w = size.Width;
            this.h = size.Height;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle<#=suffix#>"/> struct
        /// using two corner points.
        /// </summary>
        /// <param name="pt1">The first point.</param>
        /// <param name="pt2">The second point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle<#=suffix#>(Point<#=suffix#> pt1, Point<#=suffix#> pt2)
        {
            if (pt2.X >= pt1.X)
            {
                this.x = pt1.X;
                this.w = pt2.X - pt1.X;
            }
            else
            {
                this.x = pt2.X;
                this.w = pt1.X - pt2.X;
            }

            if (pt2.Y >= pt1.Y)
            {
                this.y = pt1.Y;
                this.h = pt2.Y - pt1.Y;
            }
            else
            {
                this.y = pt2.Y;
                this.h = pt1.Y - pt2.Y;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle<#=suffix#>"/> struct from the <see cref="System.Drawing.Rectangle"/>.
        /// </summary>
        /// <param name="rect">The <see cref="System.Drawing.Rectangle"/> that contains the position of the point.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Rectangle.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Rectangle.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rectangle<#=suffix#>(System.Drawing.Rectangle rect)
        {
            this.x = rect.X;
            this.y = rect.Y;
            this.w = rect.Width >= 0 ? rect.Width : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = rect.Height >= 0 ? rect.Height : throw new ArgumentOutOfRangeException(nameof(rect), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Left"/> property.</para>
        /// <para>Changing the <see cref="X"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="Rectangle<#=suffix#>"/>.</para>
        /// </remarks>
        public <#=type#> X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>Getting this property is equivalent to getting the <see cref="Top"/> property.</para>
        /// <para>Changing the <see cref="Y"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="Rectangle<#=suffix#>"/>.</para>
        /// </remarks>
        public <#=type#> Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets or sets the width of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the width of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Width"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Width"/> property will also cause a change in the <see cref="Right"/> property of the <see cref="Rectangle<#=suffix#>"/>.
        /// </remarks>
        public <#=type#> Width
        {
            get => this.w;
            set => this.w = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleWidth);
        }

        /// <summary>
        /// Gets or sets the height of the rectangle.
        /// </summary>
        /// <value>
        /// A positive number that represents the height of the rectangle. The default is 0.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="Height"/> is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Changing the <see cref="Height"/> property will also cause a change in the <see cref="Bottom"/> property of the <see cref="Rectangle<#=suffix#>"/>.
        /// </remarks>
        public <#=type#> Height
        {
            get => this.h;
            set => this.h = value >= 0 ? value : throw new ArgumentOutOfRangeException(nameof(value), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Gets the x-coordinate of the left side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the left side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="X"/> property.
        /// </remarks>
        public <#=type#> Left => this.x;

        /// <summary>
        /// Gets the x-coordinate of the right side of the rectangle.
        /// </summary>
        /// <value>
        /// The x-coordinate of the right side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Right"/> property represents the x-coordinate of the first point at the right edge of the rectangle that is not contained in the <see cref="Rectangle<#=suffix#>"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Width"/> properties.</para>
        /// </remarks>
        public <#=type#> Right => this.x + this.w;

        /// <summary>
        /// Gets the y-coordinate of the top side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the top side of the rectangle.
        /// </value>
        /// <remarks>
        /// Getting this property is equivalent to getting the <see cref="Y"/> property.
        /// </remarks>
        public <#=type#> Top => this.y;

        /// <summary>
        /// Gets the y-coordinate of the bottom side of the rectangle.
        /// </summary>
        /// <value>
        /// The y-coordinate of the bottom side of the rectangle.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="Bottom"/> property represents the y-coordinate of the first point at the bottom edge of the rectangle that is not contained in the <see cref="Rectangle<#=suffix#>"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="Y"/> and <see cref="Height"/> properties.</para>
        /// </remarks>
        public <#=type#> Bottom => this.y + this.h;

        /// <summary>
        /// Gets a value indicating whether all numeric properties of this <see cref="Rectangle<#=suffix#>"/> have value of zero.
        /// </summary>
        /// <value>
        /// <b>true</b> if <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/> and <see cref="Height"/> properties are zero; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0 && this.w == 0 && this.h == 0;

        /// <summary>
        /// Gets the location of this <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// The <see cref="Point<#=suffix#>"/> struct that contains the x- and y-coordinates of the top-left corner of the rectangle.
        /// </value>
        public Point<#=suffix#> Location => new Point<#=suffix#>(this.x, this.y);

        /// <summary>
        /// Gets the size of this <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// The <see cref="Size<#=suffix#>"/> struct that contains rectangle dimensions.
        /// </value>
        public Size<#=suffix#> Size => new Size<#=suffix#>(this.w, this.h);

        /// <summary>
        /// Gets the area of this <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// <see cref="Width"/> * <see cref="Height"/>.
        /// </value>
        public <#=type#> Area => this.w * this.h;

        /// <summary>
        /// Gets the center of this <see cref="Rectangle<#=suffix#>"/> along x-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="Rectangle<#=suffix#>"/> along x-axis.
        /// </value>
<# if (type == "int") { #>
        /// <remarks>
        /// <para>If the rectangle width is even, the center point is rounded toward the rectangles top-left corner.</para>
        /// </remarks>
        public <#=type#> CenterX => this.x + ((this.w - 1) / 2);
<# } else { #>
        public <#=type#> CenterX => this.x + (this.w / 2);
<# } #>

        /// <summary>
        /// Gets the center of this <see cref="Rectangle<#=suffix#>"/> along y-axis.
        /// </summary>
        /// <value>
        /// The center of this <see cref="Rectangle<#=suffix#>"/> along y-axis.
        /// </value>
<# if (type == "int") { #>
        /// <remarks>
        /// <para>If the rectangle height is even, the center point is rounded toward the rectangles top-left corner.</para>
        /// </remarks>
        public <#=type#> CenterY => this.y + ((this.h - 1) / 2);
<# } else { #>
        public <#=type#> CenterY => this.y + (this.h / 2);
<# } #>

        /// <summary>
        /// Gets the center <see cref="Point<#=suffix#>"/> of this <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// The center <see cref="Point<#=suffix#>"/> of this <see cref="Rectangle<#=suffix#>"/>.
        /// </value>
<# if (type == "int") { #>
        /// <remarks>
        /// <para>If the rectangle width or height is even, the center point is rounded toward the rectangles top-left corner.</para>
        /// </remarks>
        public Point<#=suffix#> CenterPoint => new Point<#=suffix#>(this.x + ((this.w - 1) / 2), this.y + ((this.h - 1) / 2));
<# } else { #>
        public Point<#=suffix#> CenterPoint => new Point<#=suffix#>(this.x + (this.w / 2), this.y + (this.h / 2));
<# } #>

        /// <summary>
        /// Compares two <see cref="Rectangle<#=suffix#>"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="Rectangle<#=suffix#>"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Rectangle<#=suffix#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Rectangle<#=suffix#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Rectangle<#=suffix#> left, Rectangle<#=suffix#> right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Rectangle<#=suffix#>"/> objects.
        /// The result specifies whether the values of the <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, and <see cref="Height"/> properties of the two <see cref="Rectangle<#=suffix#>"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Rectangle<#=suffix#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Rectangle<#=suffix#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/>, <see cref="Y"/>, <see cref="Width"/>, or <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Rectangle<#=suffix#> left, Rectangle<#=suffix#> right) => !left.Equals(right);

        /// <summary>
        /// Creates a <see cref="Rectangle<#=suffix#>"/> structure with the specified edge locations.
        /// </summary>
        /// <param name="left">The x-coordinate of the upper-left corner of this <see cref="Rectangle<#=suffix#>"/> structure.</param>
        /// <param name="top">The y-coordinate of the upper-left corner of this <see cref="Rectangle<#=suffix#>"/> structure.</param>
        /// <param name="right">The x-coordinate of the lower-right corner of this <see cref="Rectangle<#=suffix#>"/> structure.</param>
        /// <param name="bottom">The y-coordinate of the lower-right corner of this <see cref="Rectangle<#=suffix#>"/> structure.</param>
        /// <returns>The new <see cref="Rectangle<#=suffix#>"/> that this method creates.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> FromLTRB(<#=type#> left, <#=type#> top, <#=type#> right, <#=type#> bottom) => new Rectangle<#=suffix#>(left, top, right - left, bottom - top);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public static Rectangle<#=suffix#> Inflate(Rectangle<#=suffix#> rect, <#=type#> dx, <#=type#> dy)
        {
            return new Rectangle<#=suffix#>(
                rect.X - dx,
                rect.Y - dy,
                MinMax.Max(rect.w + (2 * dx), 0),
                MinMax.Max(rect.h + (2 * dy), 0));
        }

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> Inflate(Rectangle<#=suffix#> rect, Size<#=suffix#> size) => Rectangle<#=suffix#>.Inflate(rect, size.Width, size.Height);

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public static Rectangle<#=suffix#> Inflate(Rectangle<#=suffix#> rect, <#=type#> left, <#=type#> top, <#=type#> right, <#=type#> bottom)
        {
            return new Rectangle<#=suffix#>(
                rect.x - left,
                rect.y - top,
                MinMax.Max(rect.w + left + right, 0),
                MinMax.Max(rect.h + top + bottom, 0));
        }

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified amounts, along its x-axis.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// </para>
        /// <para>
        /// If <paramref name="left"/> and <paramref name="right"/> sum is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated along its x-axis.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public static Rectangle<#=suffix#> InflateX(Rectangle<#=suffix#> rect, <#=type#> left, <#=type#> right)
        {
            return new Rectangle<#=suffix#>(
                rect.x - left,
                rect.y,
                MinMax.Max(rect.w + left + right, 0),
                rect.h);
        }

        /// <summary>
        /// Creates a rectangle that results from expanding or shrinking the specified rectangle by the specified amounts, along its y-axis.
        /// </summary>
        /// <param name="rect">The rectangle to shrink or expand.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <returns>The resulting rectangle.</returns>
        /// <remarks>
        /// <para>
        /// The <see cref="Height"/> of the resulting rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>,
        /// because it is applied to both the top and bottom sides of the rectangle.
        /// </para>
        /// <para>
        /// If <paramref name="top"/> and <paramref name="bottom"/> sum is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated along its y-axis.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public static Rectangle<#=suffix#> InflateY(Rectangle<#=suffix#> rect, <#=type#> top, <#=type#> bottom)
        {
            return new Rectangle<#=suffix#>(
                rect.x,
                rect.y - top,
                rect.w,
                MinMax.Max(rect.h + top + bottom, 0));
        }

        /// <summary>
        /// Returns a <see cref="Rectangle<#=suffix#>"/> structure that represents the intersection of two other <see cref="Rectangle<#=suffix#>"/> structures.
        /// If there is no intersection, an empty <see cref="Rectangle<#=suffix#>"/> is returned.
        /// </summary>
        /// <param name="rect1">The first rectangle to intersect.</param>
        /// <param name="rect2">The second rectangle to intersect.</param>
        /// <returns>
        /// The intersection of the two rectangles,
        /// or <see cref="Rectangle<#=suffix#>.Empty"/> if no intersection exists.
        /// </returns>
        public static Rectangle<#=suffix#> Intersect(Rectangle<#=suffix#> rect1, Rectangle<#=suffix#> rect2)
        {
            <#=type#> x1 = MinMax.Max(rect1.x, rect2.x);
            <#=type#> x2 = MinMax.Min(rect1.x + rect1.w, rect2.x + rect2.w);
            <#=type#> y1 = MinMax.Max(rect1.y, rect2.y);
            <#=type#> y2 = MinMax.Min(rect1.y + rect1.h, rect2.y + rect2.h);

            return x2 >= x1 && y2 >= y1 ? Rectangle<#=suffix#>.FromLTRB(x1, y1, x2, y2) : Rectangle<#=suffix#>.Empty;
        }

        /// <summary>
        /// Translates the specified <see cref="Rectangle<#=suffix#>"/> by the specified amount.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="Rectangle<#=suffix#>"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> Offset(Rectangle<#=suffix#> rect, <#=type#> dx, <#=type#> dy) => new Rectangle<#=suffix#>(rect.x + dx, rect.y + dy, rect.w, rect.h);

        /// <summary>
        /// Translates the specified <see cref="Rectangle<#=suffix#>"/> by the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to translate.</param>
        /// <param name="offset">The <see cref="Point<#=suffix#>"/> that contains the offset for the <paramref name="rect"/>.</param>
        /// <returns>The translated <see cref="Rectangle<#=suffix#>"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> Offset(Rectangle<#=suffix#> rect, Point<#=suffix#> offset) => Rectangle<#=suffix#>.Offset(rect, offset.X, offset.Y);

        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle<#=suffix#>"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="Rectangle<#=suffix#>"/> in the following format:X Y Width Height.</param>
        /// <returns>The <see cref="Rectangle<#=suffix#>"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of four values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static Rectangle<#=suffix#> Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 4 &&
                <#=type#>.TryParse(split[0], out <#=type#> x) &&
                <#=type#>.TryParse(split[1], out <#=type#> y) &&
                <#=type#>.TryParse(split[2], out <#=type#> w) &&
                <#=type#>.TryParse(split[3], out <#=type#> h))
            {
                return new Rectangle<#=suffix#>(x, y, w, h);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidRectangleFormat, nameof(value));
            }
        }

        /// <summary>
        /// Creates a <see cref="Rectangle<#=suffix#>"/> that results from scaling the location and dimensions of specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to scale.</param>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        /// <returns>The resulting <see cref="Rectangle<#=suffix#>"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> Scale(Rectangle<#=suffix#> rect, <#=type#> dx, <#=type#> dy) =>
            new Rectangle<#=suffix#>(rect.x * dx, rect.y * dy, rect.w * dx, rect.h * dy);

#if false
        /// <summary>
        /// Scales the specified <see cref="Rectangle<#=suffix#>"/> location.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="Rectangle<#=suffix#>"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> Scale(Rectangle<#=suffix#> rect, float dx, float dy)
        {
            return new Rectangle<#=suffix#>((dx * rect.x).Round(), (dy * rect.y).Round());
        }
#endif

        /// <summary>
        /// Returns a <see cref="Rectangle<#=suffix#>"/> structure that contains the union of two other <see cref="Rectangle<#=suffix#>"/> structures.
        /// </summary>
        /// <param name="rect1">The first rectangle to union.</param>
        /// <param name="rect2">The second rectangle to union.</param>
        /// <returns>
        /// The <see cref="Rectangle<#=suffix#>"/> structure that bounds the union of the two <see cref="Rectangle<#=suffix#>"/> structures.
        /// </returns>
        public static Rectangle<#=suffix#> Union(Rectangle<#=suffix#> rect1, Rectangle<#=suffix#> rect2)
        {
            if (rect1.IsEmpty)
            {
                return rect2;
            }

            if (rect2.IsEmpty)
            {
                return rect1;
            }

            <#=type#> x1 = MinMax.Min(rect1.x, rect2.x);
            <#=type#> x2 = MinMax.Max(rect1.x + rect1.w, rect2.x + rect2.w);
            <#=type#> y1 = MinMax.Min(rect1.y, rect2.y);
            <#=type#> y2 = MinMax.Max(rect1.y + rect1.h, rect2.y + rect2.h);

            return Rectangle<#=suffix#>.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="Rectangle<#=suffix#>"/> structure that contains the union of a <see cref="Rectangle<#=suffix#>"/> structure
        /// and a rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="rect">The first rectangle to union.</param>
        /// <param name="x">The x-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the second rectangle to union.</param>
        /// <param name="width">The width of the second rectangle to union.</param>
        /// <param name="height">The height of the second rectangle to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        /// <returns>
        /// The <see cref="Rectangle<#=suffix#>"/> structure that bounds the union of the <see cref="Rectangle<#=suffix#>"/> structure and a rectangular area.
        /// </returns>
        public static Rectangle<#=suffix#> Union(Rectangle<#=suffix#> rect, <#=type#> x, <#=type#> y, <#=type#> width, <#=type#> height)
        {
            if (rect.IsEmpty)
            {
                return new Rectangle<#=suffix#>(x, y, width, height);
            }

            if (x == 0 && y == 0 && width == 0 && height == 0)
            {
                return rect;
            }

            if (width < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            }

            if (height < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
            }

            <#=type#> x1 = MinMax.Min(rect.x, x);
            <#=type#> x2 = MinMax.Max(rect.x + rect.w, x + width);
            <#=type#> y1 = MinMax.Min(rect.y, y);
            <#=type#> y2 = MinMax.Max(rect.y + rect.h, y + height);

            return Rectangle<#=suffix#>.FromLTRB(x1, y1, x2, y2);
        }

        /// <summary>
        /// Returns a <see cref="Rectangle<#=suffix#>"/> structure that contains the union of the sequence of <see cref="Rectangle<#=suffix#>"/> structures.
        /// </summary>
        /// <param name="values">The rectangles to union.</param>
        /// <returns>
        /// A <see cref="Rectangle<#=suffix#>"/> structure that bounds the union of the sequence of <see cref="Rectangle<#=suffix#>"/> structures.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Rectangle<#=suffix#> Union(IEnumerable<Rectangle<#=suffix#>> values)
        {
            if (values == null)
            {
                throw new ArgumentNullException(nameof(values));
            }

            Rectangle<#=suffix#> result = Rectangle<#=suffix#>.Empty;
            foreach (Rectangle<#=suffix#> value in values)
            {
                result.Union(value);
            }

            return result;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Rectangle<#=suffix#> other) => other.x == this.x && other.y == this.y && other.w == this.w && other.h == this.h;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is Rectangle<#=suffix#>))
            {
                return false;
            }

            return this.Equals((Rectangle<#=suffix#>)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y ^ (int)this.w ^ (int)this.h);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " +
            this.y.ToString(CultureInfo.CurrentCulture) + " " +
            this.w.ToString(CultureInfo.CurrentCulture) + " " +
            this.h.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = this.w = this.h = 0;

        /// <summary>
        /// Determines if the specified point is contained within this <see cref="Rectangle<#=suffix#>"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the point defined by <paramref name="x"/> and <paramref name="y"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(<#=type#> x, <#=type#> y) => this.ContainsX(x) && this.ContainsY(y);

        /// <summary>
        /// Determines if the specified <see cref="Point<#=suffix#>"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure.
        /// </summary>
        /// <param name="point">The <see cref="Point<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the <see cref="Point<#=suffix#>"/> represented by <paramref name="point"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Point<#=suffix#> point) => this.Contains(point.X, point.Y);

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure; otherwise, <b>false</b>.
        /// </returns>
        public bool Contains(Rectangle<#=suffix#> rect)
        {
            return
                this.x <= rect.x && rect.x + rect.w <= this.x + this.w &&
                this.y <= rect.y && rect.y + rect.h <= this.y + this.h;
        }

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure along its x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure along its x-axis; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsX(Rectangle<#=suffix#> rect)
        {
            return this.x <= rect.x && rect.x + rect.w <= this.x + this.w;
        }

        /// <summary>
        /// Determines if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure along its y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the rectangular region represented by <paramref name="rect"/> is contained within this <see cref="Rectangle<#=suffix#>"/> structure along its y-axis; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsY(Rectangle<#=suffix#> rect)
        {
            return this.y <= rect.y && rect.y + rect.h <= this.y + this.h;
        }

        /// <summary>
        /// Determines if the specified x-coordinate is contained within this <see cref="Rectangle<#=suffix#>"/> structure.
        /// </summary>
        /// <param name="x">The x-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="x"/> is contained within this <see cref="Rectangle<#=suffix#>"/> along its x-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsX(<#=type#> x) => x.Between(this.x, this.x + this.w - 1);

        /// <summary>
        /// Determines if the specified y-coordinate is contained within this <see cref="Rectangle<#=suffix#>"/> structure.
        /// </summary>
        /// <param name="y">The y-coordinate to check.</param>
        /// <returns><b>true</b> if <paramref name="y"/> is contained within this <see cref="Rectangle<#=suffix#>"/> along its y-axis; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ContainsY(<#=type#> y) => y.Between(this.y, this.y + this.h - 1);

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Point<#=suffix#>"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(Point<#=suffix#> point) => (float)Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="rect"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(Rectangle<#=suffix#> rect) => (float)Math.Sqrt(this.DistanceToSquared(rect));

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Point<#=suffix#>"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="point"/>.
        /// </returns>
        public <#=type#> DistanceToSquared(Point<#=suffix#> point)
        {
            <#=type#> dx = this.DistanceToX(point);
            <#=type#> dy = this.DistanceToY(point);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="rect"/>.
        /// </returns>
        public <#=type#> DistanceToSquared(Rectangle<#=suffix#> rect)
        {
            <#=type#> dx = this.DistanceToX(rect);
            <#=type#> dy = this.DistanceToY(rect);
            return (dx * dx) + (dy * dy);
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle<#=suffix#>"/> and the specified point along x-axis.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="x"/> along x-axis.
        /// </returns>
        public <#=type#> DistanceToX(<#=type#> x)
        {
            <#=type#> distance = this.x - x;
            if (distance < 0)
            {
                distance = x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle<#=suffix#>"/> and the specified point along y-axis.
        /// </summary>
        /// <param name="y">The y-coordinate of the point to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="y"/> along y-axis.
        /// </returns>
        public <#=type#> DistanceToY(<#=type#> y)
        {
            <#=type#> distance = this.y - y;
            if (distance < 0)
            {
                distance = y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Point<#=suffix#>"/> along x-axis.
        /// </summary>
        /// <param name="point">The x-coordinate of the <see cref="Point<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=type#> DistanceToX(Point<#=suffix#> point) => this.DistanceToX(point.X);

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Point<#=suffix#>"/> along y-axis.
        /// </summary>
        /// <param name="point">The y-coordinate of the <see cref="Point<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=type#> DistanceToY(Point<#=suffix#> point) => this.DistanceToX(point.Y);

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Rectangle<#=suffix#>"/> along x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="rect"/> along x-axis.
        /// </returns>
        public <#=type#> DistanceToX(Rectangle<#=suffix#> rect)
        {
            <#=type#> distance = this.x - (rect.x + rect.w);
            if (distance < 0)
            {
                distance = rect.x - (this.x + this.w);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Computes the distance between this <see cref="Rectangle<#=suffix#>"/> and the specified <see cref="Rectangle<#=suffix#>"/> along y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Rectangle<#=suffix#>"/> and <paramref name="rect"/> along y-axis.
        /// </returns>
        public <#=type#> DistanceToY(Rectangle<#=suffix#> rect)
        {
            <#=type#> distance = this.y - (rect.y + rect.h);
            if (distance < 0)
            {
                distance = rect.y - (this.y + this.h);
                if (distance < 0)
                {
                    distance = 0;
                }
            }

            return distance;
        }

        /// <summary>
        /// Expands or shrinks the rectangle by using the specified width and height amounts, in all directions.
        /// </summary>
        /// <param name="dx">The amount by which to expand or shrink the left and right sides of the rectangle.</param>
        /// <param name="dy">The amount by which to expand or shrink the top and bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the resulting rectangle is increased or decreased by twice the specified width offset,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased or decreased by twice the specified height.
        /// </para>
        /// <para>
        /// If either <paramref name="dx"/> or <paramref name="dy"/> is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified width or height shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(<#=type#> dx, <#=type#> dy)
        {
            this.x -= dx;
            this.w = MinMax.Max(this.w + (2 * dx), 0);

            this.y -= dy;
            this.h = MinMax.Max(this.h + (2 * dy), 0);
        }

        /// <summary>
        /// Expands or shrinks the rectangle by the specified dimensions, in all directions.
        /// </summary>
        /// <param name="size">The amount by which to expand or shrink the left, right and top, bottom sides of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased by twice the specified horizontal dimension,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the resulting rectangle is increased by twice the vertical dimension.
        /// </para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Inflate(Size<#=suffix#> size) => this.Inflate(size.Width, size.Height);

        /// <summary>
        /// Expands or shrinks the rectangle by the specified amounts, in all directions.
        /// </summary>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// Likewise, the <see cref="Height"/> of the rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>.
        /// </para>
        /// <para>
        /// If either sum is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated in the corresponding direction.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/> or <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public void Inflate(<#=type#> left, <#=type#> top, <#=type#> right, <#=type#> bottom)
        {
            this.x -= left;
            this.w = MinMax.Max(this.w + left + right, 0);

            this.y -= top;
            this.h = MinMax.Max(this.h + top + bottom, 0);
        }

        /// <summary>
        /// Expands or shrinks the rectangle by the specified amounts, along its x-axis.
        /// </summary>
        /// <param name="left">The amount by which to expand or shrink the left side of the rectangle.</param>
        /// <param name="right">The amount by which to expand or shrink the right side of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Width"/> of the rectangle is increased or decreased by the sum of <paramref name="left"/> and <paramref name="right"/>,
        /// because it is applied to both the left and right sides of the rectangle.
        /// </para>
        /// <para>
        /// If <paramref name="left"/> and <paramref name="right"/> sum is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated along its x-axis.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Width"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public void InflateX(<#=type#> left, <#=type#> right)
        {
            this.x -= left;
            this.w = MinMax.Max(this.w + left + right, 0);
        }

        /// <summary>
        /// Expands or shrinks the rectangle by the specified amounts, along its y-axis.
        /// </summary>
        /// <param name="top">The amount by which to expand or shrink the top side of the rectangle.</param>
        /// <param name="bottom">The amount by which to expand or shrink the bottom side of the rectangle.</param>
        /// <remarks>
        /// <para>
        /// The <see cref="Height"/> of the rectangle is increased or decreased by the sum of <paramref name="top"/> and <paramref name="bottom"/>,
        /// because it is applied to both the top and bottom sides of the rectangle.
        /// </para>
        /// <para>
        /// If <paramref name="top"/> and <paramref name="bottom"/> sum is negative, the <see cref="Rectangle<#=suffix#>"/> structure is deflated along its y-axis.
        /// </para>
        /// <para>
        /// If the specified parameters shrink the rectangle by more than its current <see cref="Height"/>
        /// giving the rectangle a negative area, the rectangle becomes the <see cref="Rectangle<#=suffix#>.Empty"/> rectangle.</para>
        /// </remarks>
        public void InflateY(<#=type#> top, <#=type#> bottom)
        {
            this.y -= top;
            this.h = MinMax.Max(this.h + top + bottom, 0);
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle<#=suffix#>"/> with the intersection of itself and the specified rectangular area.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangular area with which to intersect.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangular area with which to intersect.</param>
        /// <param name="width">The width of the rectangular area with which to intersect.</param>
        /// <param name="height">The height of the rectangular area with which to intersect.</param>
        public void Intersect(<#=type#> x, <#=type#> y, <#=type#> width, <#=type#> height)
        {
            <#=type#> x1 = MinMax.Max(this.x, x);
            <#=type#> x2 = MinMax.Min(this.x + this.w, x + width);
            <#=type#> y1 = MinMax.Max(this.y, y);
            <#=type#> y2 = MinMax.Min(this.y + this.h, y + height);

            if (x2 >= x1 && y2 >= y1)
            {
                this.x = x1;
                this.y = y1;
                this.w = x2 - x1;
                this.h = y2 - y1;
            }
            else
            {
                this.x = this.y = this.w = this.h = 0;
            }
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle<#=suffix#>"/> with the intersection of itself and the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to intersect.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Intersect(Rectangle<#=suffix#> rect) => this.Intersect(rect.x, rect.y, rect.w, rect.h);

        /// <summary>
        /// Determines if this rectangle <see cref="Rectangle<#=suffix#>"/> intersects with the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWith(Rectangle<#=suffix#> rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w &&
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Determines if this rectangle <see cref="Rectangle<#=suffix#>"/> intersects with the specified <see cref="Rectangle<#=suffix#>"/> along its x-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along x-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithX(Rectangle<#=suffix#> rect) =>
            rect.x < this.x + this.w &&
            this.x < rect.x + rect.w;

        /// <summary>
        /// Determines if this rectangle <see cref="Rectangle<#=suffix#>"/> intersects with the specified <see cref="Rectangle<#=suffix#>"/> along its y-axis.
        /// </summary>
        /// <param name="rect">The <see cref="Rectangle<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if two rectangles intersect along y-axis, otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IntersectsWithY(Rectangle<#=suffix#> rect) =>
            rect.y < this.y + this.h &&
            this.y < rect.y + rect.h;

        /// <summary>
        /// Translates this <see cref="Rectangle<#=suffix#>"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(<#=type#> dx, <#=type#> dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="Rectangle<#=suffix#>"/> by the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point<#=suffix#>"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(Point<#=suffix#> point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Set the rectangle x-coordinate, y-coordinate, width, and height to the specified values.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangle.</param>
        /// <param name="width">The width of the rectangle.</param>
        /// <param name="height">The height of the rectangle.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(<#=type#> x, <#=type#> y, <#=type#> width, <#=type#> height)
        {
            this.x = x;
            this.y = y;
            this.w = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidRectangleWidth);
            this.h = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidRectangleHeight);
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle<#=suffix#>"/> with the union of itself and the specified <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="rect">The rectangle with which to union.</param>
        public void Union(Rectangle<#=suffix#> rect)
        {
            Rectangle<#=suffix#> result = Rectangle<#=suffix#>.Union(rect, this);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Replaces this <see cref="Rectangle<#=suffix#>"/> with the union of itself and
        /// a specified rectangular area represented by its x-coordinate, y-coordinate, width, and height.
        /// </summary>
        /// <param name="x">The x-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="y">The y-coordinate of the top-left corner of the rectangular area with which to union.</param>
        /// <param name="width">The width of the rectangular area with which to union.</param>
        /// <param name="height">The height of the rectangular area with which to union.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        public void Union(<#=type#> x, <#=type#> y, <#=type#> width, <#=type#> height)
        {
            Rectangle<#=suffix#> result = Rectangle<#=suffix#>.Union(this, x, y, width, height);

            this.x = result.x;
            this.y = result.y;
            this.w = result.w;
            this.h = result.h;
        }

        /// <summary>
        /// Scales the location and the dimensions of this <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(<#=type#> dx, <#=type#> dy)
        {
            this.x *= dx;
            this.y *= dy;
            this.w *= dx;
            this.h *= dy;
        }
<# if (type == "int") { #>

        /// <summary>
        /// Scales the location and the dimensions of this <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="dx">The amount by which to scale the left position and the width of the rectangle.</param>
        /// <param name="dy">The amount by which to scale the top position and the height of the rectangle.</param>
        public void Scale(float dx, float dy)
        {
            float x1 = dx * this.x;
            float y1 = dy * this.y;
            float x2 = dx * (this.x + this.w);
            float y2 = dy * (this.y + this.h);

            // note: add epsilon to avoid rounding problems
            this.x = x1.Round();
            this.y = y1.Round();
            this.w = (int)Math.Floor(x2 - x1 + Rectangle<#=suffix#>.Eps);
            this.h = (int)Math.Floor(y2 - y1 + Rectangle<#=suffix#>.Eps);
        }
<# } #>

        /// <summary>
        /// Applies affine transformation described by the specified matrix to the <see cref="Rectangle<#=suffix#>"/>.
        /// </summary>
        /// <param name="matrix">The transformation matrix.</param>
        public void Transform(System.Windows.Media.Matrix matrix)
        {
            // convert three corner points out of four
            (double x, double y) tr = TransformPoint(this.x + this.w, this.y);
            (double x, double y) br = TransformPoint(this.x + this.w, this.y + this.h);
            (double x, double y) bl = TransformPoint(this.x, this.y + this.h);

            // find boundaries of new rectangle
            double x1 = MinMax.Min(bl.x, tr.x, br.x);
            double x2 = MinMax.Max(bl.x, tr.x, br.x);
            double y1 = MinMax.Min(bl.y, tr.y, br.y);
            double y2 = MinMax.Max(bl.y, tr.y, br.y);

<# if (type == "int") { #>
            // note: add epsilon to avoid rounding problems
            this.x = x1.Round();
            this.y = y1.Round();
            this.w = (int)Math.Floor(x2 - x1 + Rectangle<#=suffix#>.Eps);
            this.h = (int)Math.Floor(y2 - y1 + Rectangle<#=suffix#>.Eps);
<# } else { #>
            this.x = (<#=type#>)(x1);
            this.y = (<#=type#>)(y1);
            this.w = (<#=type#>)(x2 - x1);
            this.h = (<#=type#>)(y2 - y1);
<# } #>

            (double x, double y) TransformPoint(<#=type#> x, <#=type#> y)
            {
                return ((matrix.M11 * x) + (matrix.M12 * y) + matrix.OffsetX, (matrix.M21 * x) + (matrix.M22 * y) + matrix.OffsetY);
            }
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="Rectangle<#=suffix#>"/> to <see cref="string"/>.
    /// </summary>
    internal class Rectangle<#=suffix#>Converter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Rectangle<#=suffix#>Converter"/> class.
        /// </summary>
        public Rectangle<#=suffix#>Converter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "Rectangle<#=suffix#>Converter", destType.ToString()));
            }

            return ((Rectangle<#=suffix#>)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return Rectangle<#=suffix#>.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "Rectangle<#=suffix#>Converter", value.GetType().ToString()));
            }

            return Rectangle<#=suffix#>.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="Rectangle<#=suffix#>"/> struct.
    /// </summary>
    public class Rectangle<#=suffix#>JsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is Rectangle<#=suffix#> rect)
            {
                writer.WriteValue(rect.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting rectangle. Expected Rectangle<#=suffix#>, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to Rectangle<#=suffix#>.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing rectangle. Expected String, got {0}.",
                    reader.TokenType));
            }

            return Rectangle<#=suffix#>.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="Rectangle<#=suffix#>"/> objects,
    /// first by <see cref="Rectangle<#=suffix#>.Left"/> then by <see cref="Rectangle<#=suffix#>.Right"/>, <see cref="Rectangle<#=suffix#>.Bottom"/> and <see cref="Rectangle<#=suffix#>.Top"/>.
    /// </summary>
    public class Rectangle<#=suffix#>LRBTComparer : IComparer<Rectangle<#=suffix#>>
    {
        /// <summary>
        /// Gets a default <see cref="Rectangle<#=suffix#>LRBTComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="Rectangle<#=suffix#>LRBTComparer"/> object.
        /// </value>
        public static Rectangle<#=suffix#>LRBTComparer Default { get; } = new Rectangle<#=suffix#>LRBTComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Rectangle<#=suffix#> x, Rectangle<#=suffix#> y)
        {
<# if (type == "int") { #>
            int res = x.Left - y.Left;
            if (res == 0)
            {
                res = x.Right - y.Right;
                if (res == 0)
                {
                    res = x.Bottom - y.Bottom;
                    if (res == 0)
                    {
                        res = x.Top - y.Top;
                    }
                }
            }
<# } else { #>
            int res = x.Left.CompareTo(y.Left);
            if (res == 0)
            {
                res = x.Right.CompareTo(y.Right);
                if (res == 0)
                {
                    res = x.Bottom.CompareTo(y.Bottom);
                    if (res == 0)
                    {
                        res = x.Top.CompareTo(y.Top);
                    }
                }
            }
<# } #>

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="Rectangle<#=suffix#>"/> objects,
    /// first by <see cref="Rectangle<#=suffix#>.Top"/> then by <see cref="Rectangle<#=suffix#>.Bottom"/>, <see cref="Rectangle<#=suffix#>.Left"/> and <see cref="Rectangle<#=suffix#>.Right"/>.
    /// </summary>
    public class Rectangle<#=suffix#>TBLRComparer : IComparer<Rectangle<#=suffix#>>
    {
        /// <summary>
        /// Gets a default <see cref="Rectangle<#=suffix#>TBLRComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="Rectangle<#=suffix#>TBLRComparer"/> object.
        /// </value>
        public static Rectangle<#=suffix#>TBLRComparer Default { get; } = new Rectangle<#=suffix#>TBLRComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Rectangle<#=suffix#> x, Rectangle<#=suffix#> y)
        {
<# if (type == "int") { #>
            int res = x.Top - y.Top;
            if (res == 0)
            {
                res = x.Bottom - y.Bottom;
                if (res == 0)
                {
                    res = x.Left - y.Left;
                    if (res == 0)
                    {
                        res = x.Right - y.Right;
                    }
                }
            }
<# } else { #>
            int res = x.Top.CompareTo(y.Top);
            if (res == 0)
            {
                res = x.Bottom.CompareTo(y.Bottom);
                if (res == 0)
                {
                    res = x.Left.CompareTo(y.Left);
                    if (res == 0)
                    {
                        res = x.Right.CompareTo(y.Right);
                    }
                }
            }
<# } #>

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="Rectangle<#=suffix#>"/> objects,
    /// first by <see cref="Rectangle<#=suffix#>.Left"/> then by <see cref="Rectangle<#=suffix#>.Top"/>, <see cref="Rectangle<#=suffix#>.Right"/> and <see cref="Rectangle<#=suffix#>.Bottom"/>.
    /// </summary>
    public class Rectangle<#=suffix#>LTRBComparer : IComparer<Rectangle<#=suffix#>>
    {
        /// <summary>
        /// Gets a default <see cref="Rectangle<#=suffix#>LTRBComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="Rectangle<#=suffix#>LTRBComparer"/> object.
        /// </value>
        public static Rectangle<#=suffix#>LTRBComparer Default { get; } = new Rectangle<#=suffix#>LTRBComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Rectangle<#=suffix#> x, Rectangle<#=suffix#> y)
        {
<# if (type == "int") { #>
            int res = x.Left - y.Left;
            if (res == 0)
            {
                res = x.Top - y.Top;
                if (res == 0)
                {
                    res = x.Right - y.Right;
                    if (res == 0)
                    {
                        res = x.Bottom - y.Bottom;
                    }
                }
            }
<# } else { #>
            int res = x.Left.CompareTo(y.Left);
            if (res == 0)
            {
                res = x.Top.CompareTo(y.Top);
                if (res == 0)
                {
                    res = x.Right.CompareTo(y.Right);
                    if (res == 0)
                    {
                        res = x.Bottom.CompareTo(y.Bottom);
                    }
                }
            }
<# } #>

            return res;
        }
    }
<#
    }
#>
}