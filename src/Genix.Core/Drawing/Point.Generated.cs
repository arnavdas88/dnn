// -----------------------------------------------------------------------
// <copyright file="Point.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 10/26/2018 10:30:45 AM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Drawing
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using Newtonsoft.Json;


    /// <summary>
    /// Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(PointConverter))]
    [JsonConverter(typeof(PointJsonConverter))]
    public struct Point
        : IEquatable<Point>
    {
        /// <summary>
        /// Represents a <see cref="Point"/> that has <see cref="X"/> and <see cref="Y"/> values set to zero.
        /// </summary>
        public static readonly Point Empty;

        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const float Eps = 1e-8f;

        /// <summary>
        /// The x-coordinate of this <see cref="Point"/>.
        /// </summary>
        private int x;

        /// <summary>
        /// The y-coordinate of this <see cref="Point"/>.
        /// </summary>
        private int y;

        /// <summary>
        /// Initializes a new instance of the <see cref="Point"/> struct with the specified coordinates.
        /// </summary>
        /// <param name="x">The horizontal position of the point.</param>
        /// <param name="y">The vertical position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Point(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Point"/> struct from the <see cref="System.Drawing.Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="System.Drawing.Point"/> that contains the position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Point(System.Drawing.Point point)
        {
            this.x = point.X;
            this.y = point.Y;
        }

        /// <summary>
        /// Gets or sets the x-coordinate of this <see cref="Point"/>.
        /// </summary>
        /// <value>
        /// The x-coordinate of this <see cref="Point"/>.
        /// </value>
        public int X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of this <see cref="Point"/>.
        /// </summary>
        /// <value>
        /// The y-coordinate of this <see cref="Point"/>.
        /// </value>
        public int Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="Point"/> is empty.
        /// </summary>
        /// <value>
        /// <b>true</b> if both <see cref="X"/> and <see cref="Y"/> are 0; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0;

        /// <summary>
        /// Compares two <see cref="Point"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Y"/> properties of the two <see cref="Point"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Point"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Point"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Y"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Point left, Point right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Point"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Y"/> properties of the two <see cref="Point"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Point"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Point"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> and <see cref="Y"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Point left, Point right) => !left.Equals(right);

        /// <summary>
        /// Initializes a new instance of the <see cref="Point"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="Point"/> in the following format:X Y.</param>
        /// <returns>The <see cref="Point"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of two values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static Point Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 2 &&
                int.TryParse(split[0], out int x) &&
                int.TryParse(split[1], out int y))
            {
                return new Point(x, y);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidPointFormat, nameof(value));
            }
        }

        /// <summary>
        /// Scales the specified <see cref="Point"/> location.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="Point"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Point Scale(Point point, int dx, int dy) => new Point(point.x * dx, point.y * dy);

        /// <summary>
        /// Scales the specified <see cref="Point"/> location.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="Point"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Point Scale(Point point, float dx, float dy)
        {
            // note: add epsilon to avoid rounding problems
            return new Point(
                (int)Math.Round((dx * point.x) + Point.Eps, MidpointRounding.AwayFromZero),
                (int)Math.Round((dy * point.y) + Point.Eps, MidpointRounding.AwayFromZero));
        }

        /// <summary>
        /// Translates the specified <see cref="Point"/> by the specified amount.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="Point"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Point Offset(Point point, int dx, int dy) => new Point(point.x + dx, point.y + dy);

        /// <summary>
        /// Translates the specified <see cref="Point"/> by the specified <see cref="Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to translate.</param>
        /// <param name="offset">The <see cref="Point"/> that contains the offset for the <paramref name="point"/>.</param>
        /// <returns>The translated <see cref="Point"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Point Offset(Point point, Point offset) => Point.Offset(point, offset.x, offset.y);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Point other) => other.x == this.x && other.y == this.y;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is Point))
            {
                return false;
            }

            return this.Equals((Point)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " + this.y.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Sets <see cref="X"/> and <see cref="Y"/> values set to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = 0;

        /// <summary>
        /// Sets this <see cref="Point"/> position.
        /// </summary>
        /// <param name="x">The horizontal position of the point.</param>
        /// <param name="y">The vertical position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Translates this <see cref="Point"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(int dx, int dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="Point"/> by the specified <see cref="Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(Point point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Scales this <see cref="Point"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(int dx, int dy)
        {
            this.x *= dx;
            this.y *= dy;
        }
 
        /// <summary>
        /// Scales this <see cref="Point"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(float dx, float dy)
        {
            // note: add epsilon to avoid rounding problems
            this.x = (int)Math.Round((dx * this.x) + Point.Eps, MidpointRounding.AwayFromZero);
            this.y = (int)Math.Round((dy * this.y) + Point.Eps, MidpointRounding.AwayFromZero);
        }

        /// <summary>
        /// Computes the Euclidean distance between this <see cref="Point"/> and the specified <see cref="Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="Point"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(Point point) => (float)Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the distance between this <see cref="Point"/> and the specified <see cref="Point"/> along x-axis.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Point"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int DistanceToX(Point point) => Math.Abs(this.x - point.x);

        /// <summary>
        /// Computes the distance between this <see cref="Point"/> and the specified <see cref="Point"/> along y-axis.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="Point"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int DistanceToY(Point point) => Math.Abs(this.y - point.y);

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="Point"/> and the specified <see cref="Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="Point"/> and <paramref name="point"/>.
        /// </returns>
        public int DistanceToSquared(Point point)
        {
            int dx = this.x - point.x;
            int dy = this.y - point.y;
            return (dx * dx) + (dy * dy);
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="Point"/> to <see cref="string"/>.
    /// </summary>
    internal class PointConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PointConverter"/> class.
        /// </summary>
        public PointConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "PointConverter", destType.ToString()));
            }

            return ((Point)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return Point.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "PointConverter", value.GetType().ToString()));
            }

            return Point.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="Point"/> struct.
    /// </summary>
    public class PointJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is Point point)
            {
                writer.WriteValue(point.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting point. Expected Point, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to Point.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing point. Expected String, got {0}.",
                    reader.TokenType));
            }

            return Point.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="Point"/> objects, first by <see cref="Point.X"/> then by <see cref="Point.Y"/>.
    /// </summary>
    public class PointXYComparer : IComparer<Point>
    {
        /// <summary>
        /// Gets a default <see cref="PointXYComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="PointXYComparer"/> object.
        /// </value>
        public static PointXYComparer Default { get; } = new PointXYComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Point x, Point y)
        {
            int res = x.X - y.X;
            if (res == 0)
            {
                res = x.Y - y.Y;
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="Point"/> objects, first by <see cref="Point.Y"/> then by <see cref="Point.X"/>.
    /// </summary>
    public class PointYXComparer : IComparer<Point>
    {
        /// <summary>
        /// Gets a default <see cref="PointYXComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="PointYXComparer"/> object.
        /// </value>
        public static PointYXComparer Default { get; } = new PointYXComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(Point x, Point y)
        {
            int res = x.Y - y.Y;
            if (res == 0)
            {
                res = x.X - y.X;
            }

            return res;
        }
    }

    /// <summary>
    /// Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(PointFConverter))]
    [JsonConverter(typeof(PointFJsonConverter))]
    public struct PointF
        : IEquatable<PointF>
    {
        /// <summary>
        /// Represents a <see cref="PointF"/> that has <see cref="X"/> and <see cref="Y"/> values set to zero.
        /// </summary>
        public static readonly PointF Empty;

        /// <summary>
        /// The x-coordinate of this <see cref="PointF"/>.
        /// </summary>
        private float x;

        /// <summary>
        /// The y-coordinate of this <see cref="PointF"/>.
        /// </summary>
        private float y;

        /// <summary>
        /// Initializes a new instance of the <see cref="PointF"/> struct with the specified coordinates.
        /// </summary>
        /// <param name="x">The horizontal position of the point.</param>
        /// <param name="y">The vertical position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public PointF(float x, float y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PointF"/> struct from the <see cref="System.Drawing.Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="System.Drawing.Point"/> that contains the position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public PointF(System.Drawing.Point point)
        {
            this.x = point.X;
            this.y = point.Y;
        }

        /// <summary>
        /// Gets or sets the x-coordinate of this <see cref="PointF"/>.
        /// </summary>
        /// <value>
        /// The x-coordinate of this <see cref="PointF"/>.
        /// </value>
        public float X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of this <see cref="PointF"/>.
        /// </summary>
        /// <value>
        /// The y-coordinate of this <see cref="PointF"/>.
        /// </value>
        public float Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="PointF"/> is empty.
        /// </summary>
        /// <value>
        /// <b>true</b> if both <see cref="X"/> and <see cref="Y"/> are 0; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0;

        /// <summary>
        /// Compares two <see cref="PointF"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Y"/> properties of the two <see cref="PointF"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="PointF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="PointF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Y"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(PointF left, PointF right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="PointF"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Y"/> properties of the two <see cref="PointF"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="PointF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="PointF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> and <see cref="Y"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(PointF left, PointF right) => !left.Equals(right);

        /// <summary>
        /// Initializes a new instance of the <see cref="PointF"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="PointF"/> in the following format:X Y.</param>
        /// <returns>The <see cref="PointF"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of two values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static PointF Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 2 &&
                float.TryParse(split[0], out float x) &&
                float.TryParse(split[1], out float y))
            {
                return new PointF(x, y);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidPointFormat, nameof(value));
            }
        }

        /// <summary>
        /// Scales the specified <see cref="PointF"/> location.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="PointF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointF Scale(PointF point, float dx, float dy) => new PointF(point.x * dx, point.y * dy);

        /// <summary>
        /// Translates the specified <see cref="PointF"/> by the specified amount.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="PointF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointF Offset(PointF point, float dx, float dy) => new PointF(point.x + dx, point.y + dy);

        /// <summary>
        /// Translates the specified <see cref="PointF"/> by the specified <see cref="PointF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to translate.</param>
        /// <param name="offset">The <see cref="PointF"/> that contains the offset for the <paramref name="point"/>.</param>
        /// <returns>The translated <see cref="PointF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointF Offset(PointF point, PointF offset) => PointF.Offset(point, offset.x, offset.y);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(PointF other) => other.x == this.x && other.y == this.y;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is Point))
            {
                return false;
            }

            return this.Equals((PointF)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " + this.y.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Sets <see cref="X"/> and <see cref="Y"/> values set to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = 0;

        /// <summary>
        /// Sets this <see cref="PointF"/> position.
        /// </summary>
        /// <param name="x">The horizontal position of the point.</param>
        /// <param name="y">The vertical position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(float x, float y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Translates this <see cref="PointF"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(float dx, float dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="PointF"/> by the specified <see cref="PointF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(PointF point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Scales this <see cref="PointF"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(float dx, float dy)
        {
            this.x *= dx;
            this.y *= dy;
        }
 
        /// <summary>
        /// Computes the Euclidean distance between this <see cref="PointF"/> and the specified <see cref="PointF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="PointF"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceTo(PointF point) => (float)Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the distance between this <see cref="PointF"/> and the specified <see cref="PointF"/> along x-axis.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="PointF"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceToX(PointF point) => Math.Abs(this.x - point.x);

        /// <summary>
        /// Computes the distance between this <see cref="PointF"/> and the specified <see cref="PointF"/> along y-axis.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="PointF"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float DistanceToY(PointF point) => Math.Abs(this.y - point.y);

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="PointF"/> and the specified <see cref="PointF"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointF"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="PointF"/> and <paramref name="point"/>.
        /// </returns>
        public float DistanceToSquared(PointF point)
        {
            float dx = this.x - point.x;
            float dy = this.y - point.y;
            return (dx * dx) + (dy * dy);
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="PointF"/> to <see cref="string"/>.
    /// </summary>
    internal class PointFConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PointFConverter"/> class.
        /// </summary>
        public PointFConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "PointFConverter", destType.ToString()));
            }

            return ((PointF)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return PointF.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "PointFConverter", value.GetType().ToString()));
            }

            return PointF.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="PointF"/> struct.
    /// </summary>
    public class PointFJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is PointF point)
            {
                writer.WriteValue(point.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting point. Expected PointF, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to PointF.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing point. Expected String, got {0}.",
                    reader.TokenType));
            }

            return PointF.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="PointF"/> objects, first by <see cref="PointF.X"/> then by <see cref="PointF.Y"/>.
    /// </summary>
    public class PointFXYComparer : IComparer<PointF>
    {
        /// <summary>
        /// Gets a default <see cref="PointFXYComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="PointFXYComparer"/> object.
        /// </value>
        public static PointFXYComparer Default { get; } = new PointFXYComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(PointF x, PointF y)
        {
            int res = x.X.CompareTo(y.X);
            if (res == 0)
            {
                res = x.Y.CompareTo(y.Y);
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="PointF"/> objects, first by <see cref="PointF.Y"/> then by <see cref="PointF.X"/>.
    /// </summary>
    public class PointFYXComparer : IComparer<PointF>
    {
        /// <summary>
        /// Gets a default <see cref="PointFYXComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="PointFYXComparer"/> object.
        /// </value>
        public static PointFYXComparer Default { get; } = new PointFYXComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(PointF x, PointF y)
        {
            int res = x.Y.CompareTo(y.Y);
            if (res == 0)
            {
                res = x.X.CompareTo(y.X);
            }

            return res;
        }
    }

    /// <summary>
    /// Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.
    /// </summary>
    [TypeConverter(typeof(PointDConverter))]
    [JsonConverter(typeof(PointDJsonConverter))]
    public struct PointD
        : IEquatable<PointD>
    {
        /// <summary>
        /// Represents a <see cref="PointD"/> that has <see cref="X"/> and <see cref="Y"/> values set to zero.
        /// </summary>
        public static readonly PointD Empty;

        /// <summary>
        /// The x-coordinate of this <see cref="PointD"/>.
        /// </summary>
        private double x;

        /// <summary>
        /// The y-coordinate of this <see cref="PointD"/>.
        /// </summary>
        private double y;

        /// <summary>
        /// Initializes a new instance of the <see cref="PointD"/> struct with the specified coordinates.
        /// </summary>
        /// <param name="x">The horizontal position of the point.</param>
        /// <param name="y">The vertical position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public PointD(double x, double y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PointD"/> struct from the <see cref="System.Drawing.Point"/>.
        /// </summary>
        /// <param name="point">The <see cref="System.Drawing.Point"/> that contains the position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public PointD(System.Drawing.Point point)
        {
            this.x = point.X;
            this.y = point.Y;
        }

        /// <summary>
        /// Gets or sets the x-coordinate of this <see cref="PointD"/>.
        /// </summary>
        /// <value>
        /// The x-coordinate of this <see cref="PointD"/>.
        /// </value>
        public double X
        {
            get => this.x;
            set => this.x = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of this <see cref="PointD"/>.
        /// </summary>
        /// <value>
        /// The y-coordinate of this <see cref="PointD"/>.
        /// </value>
        public double Y
        {
            get => this.y;
            set => this.y = value;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="PointD"/> is empty.
        /// </summary>
        /// <value>
        /// <b>true</b> if both <see cref="X"/> and <see cref="Y"/> are 0; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.x == 0 && this.y == 0;

        /// <summary>
        /// Compares two <see cref="PointD"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Y"/> properties of the two <see cref="PointD"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="PointD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="PointD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Y"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(PointD left, PointD right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="PointD"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Y"/> properties of the two <see cref="PointD"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="PointD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="PointD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> and <see cref="Y"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(PointD left, PointD right) => !left.Equals(right);

        /// <summary>
        /// Initializes a new instance of the <see cref="PointD"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="PointD"/> in the following format:X Y.</param>
        /// <returns>The <see cref="PointD"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of two values represented by an optional sign followed by a sequence of digits (0 through 9).
        /// </exception>
        public static PointD Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 2 &&
                double.TryParse(split[0], out double x) &&
                double.TryParse(split[1], out double y))
            {
                return new PointD(x, y);
            }
            else
            {
                throw new ArgumentException(Genix.Core.Properties.Resources.E_InvalidPointFormat, nameof(value));
            }
        }

        /// <summary>
        /// Scales the specified <see cref="PointD"/> location.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="PointD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointD Scale(PointD point, double dx, double dy) => new PointD(point.x * dx, point.y * dy);

        /// <summary>
        /// Translates the specified <see cref="PointD"/> by the specified amount.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to translate.</param>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        /// <returns>The translated <see cref="PointD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointD Offset(PointD point, double dx, double dy) => new PointD(point.x + dx, point.y + dy);

        /// <summary>
        /// Translates the specified <see cref="PointD"/> by the specified <see cref="PointD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to translate.</param>
        /// <param name="offset">The <see cref="PointD"/> that contains the offset for the <paramref name="point"/>.</param>
        /// <returns>The translated <see cref="PointD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PointD Offset(PointD point, PointD offset) => PointD.Offset(point, offset.x, offset.y);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(PointD other) => other.x == this.x && other.y == this.y;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is Point))
            {
                return false;
            }

            return this.Equals((PointD)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x ^ (int)this.y);

        /// <inheritdoc />
        public override string ToString() =>
            this.x.ToString(CultureInfo.CurrentCulture) + " " + this.y.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Sets <see cref="X"/> and <see cref="Y"/> values set to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.x = this.y = 0;

        /// <summary>
        /// Sets this <see cref="PointD"/> position.
        /// </summary>
        /// <param name="x">The horizontal position of the point.</param>
        /// <param name="y">The vertical position of the point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(double x, double y)
        {
            this.x = x;
            this.y = y;
        }

        /// <summary>
        /// Translates this <see cref="PointD"/> by the specified amount.
        /// </summary>
        /// <param name="dx">The amount to offset the x-coordinate.</param>
        /// <param name="dy">The amount to offset the y-coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(double dx, double dy)
        {
            this.x += dx;
            this.y += dy;
        }

        /// <summary>
        /// Translates this <see cref="PointD"/> by the specified <see cref="PointD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> that contains the offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Offset(PointD point) => this.Offset(point.X, point.Y);

        /// <summary>
        /// Scales this <see cref="PointD"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(double dx, double dy)
        {
            this.x *= dx;
            this.y *= dy;
        }
 
        /// <summary>
        /// Computes the Euclidean distance between this <see cref="PointD"/> and the specified <see cref="PointD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the Euclidean distance between this <see cref="PointD"/> and <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceTo(PointD point) => Math.Sqrt(this.DistanceToSquared(point));

        /// <summary>
        /// Computes the distance between this <see cref="PointD"/> and the specified <see cref="PointD"/> along x-axis.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="PointD"/> and <paramref name="point"/> along x-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceToX(PointD point) => Math.Abs(this.x - point.x);

        /// <summary>
        /// Computes the distance between this <see cref="PointD"/> and the specified <see cref="PointD"/> along y-axis.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the distance between this <see cref="PointD"/> and <paramref name="point"/> along y-axis.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceToY(PointD point) => Math.Abs(this.y - point.y);

        /// <summary>
        /// Computes the squared Euclidean distance between this <see cref="PointD"/> and the specified <see cref="PointD"/>.
        /// </summary>
        /// <param name="point">The <see cref="PointD"/> to compute the distance to.</param>
        /// <returns>
        /// A value that represents the squared Euclidean distance between this <see cref="PointD"/> and <paramref name="point"/>.
        /// </returns>
        public double DistanceToSquared(PointD point)
        {
            double dx = this.x - point.x;
            double dy = this.y - point.y;
            return (dx * dx) + (dy * dy);
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="PointD"/> to <see cref="string"/>.
    /// </summary>
    internal class PointDConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PointDConverter"/> class.
        /// </summary>
        public PointDConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "PointDConverter", destType.ToString()));
            }

            return ((PointD)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return PointD.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Genix.Core.Properties.Resources.E_TypeConversionNotSupported, "PointDConverter", value.GetType().ToString()));
            }

            return PointD.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="PointD"/> struct.
    /// </summary>
    public class PointDJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is PointD point)
            {
                writer.WriteValue(point.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting point. Expected PointD, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to PointD.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing point. Expected String, got {0}.",
                    reader.TokenType));
            }

            return PointD.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Compares two <see cref="PointD"/> objects, first by <see cref="PointD.X"/> then by <see cref="PointD.Y"/>.
    /// </summary>
    public class PointDXYComparer : IComparer<PointD>
    {
        /// <summary>
        /// Gets a default <see cref="PointDXYComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="PointDXYComparer"/> object.
        /// </value>
        public static PointDXYComparer Default { get; } = new PointDXYComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(PointD x, PointD y)
        {
            int res = x.X.CompareTo(y.X);
            if (res == 0)
            {
                res = x.Y.CompareTo(y.Y);
            }

            return res;
        }
    }

    /// <summary>
    /// Compares two <see cref="PointD"/> objects, first by <see cref="PointD.Y"/> then by <see cref="PointD.X"/>.
    /// </summary>
    public class PointDYXComparer : IComparer<PointD>
    {
        /// <summary>
        /// Gets a default <see cref="PointDYXComparer"/> comparer.
        /// </summary>
        /// <value>
        /// The <see cref="PointDYXComparer"/> object.
        /// </value>
        public static PointDYXComparer Default { get; } = new PointDYXComparer();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Compare(PointD x, PointD y)
        {
            int res = x.Y.CompareTo(y.Y);
            if (res == 0)
            {
                res = x.X.CompareTo(y.X);
            }

            return res;
        }
    }
}