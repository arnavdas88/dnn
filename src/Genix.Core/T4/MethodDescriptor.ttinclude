<#+ 

    enum ArgumentType
    {
        Constant = 0,
        Vector = 1,
        VectorAggregate = 2,
        TwoVectorsAggregate = 3,
        ConstantAndVector = 4,
        TwoVectors = 5,
        ThreeVectors = 6,
        FourVectors = 7,
    }

    class MethodDescriptor
    {
        public MethodDescriptor()
        {
            this.HasNotInPlace = true;
            this.ConstantName = "a";
            this.ConstantDescription = "The constant value.";
        }

        public string Name { get; set; }
        public string NativeName { get; set; }
        public ArgumentType Argument { get; set; }
        public string Summary { get; set; }
        public bool HasNotInPlace { get; set; }
        public bool HasInPlace { get; set; }
        public bool HasIncrement { get; set; }
        public bool HasGradient { get; set; }
        public string ConstantType { get; set; }
        public string ConstantName { get; set; }
        public string ConstantDescription { get; set; }
        public string ReturnType { get; set; }
        public string Returns { get; set; }
        public string Op { get; set; }
        public string OpInPlace { get; set; }
        public string OpGradient { get; set; }
        public string SupportedTypes { get; set; }

        public static string Type2Suffix(string typeName)
        {
            switch (typeName)
            {
                case "sbyte": return "s8";
                case "byte": return "u8";
                case "short": return "s16";
                case "ushort": return "u16";
                case "int": return "s32";
                case "uint": return "u32";
                case "long": return "s64";
                case "ulong": return "u64";
                case "float": return "f32";
                case "double": return "f64";
                default: return string.Empty;
            }
        }

        public string GetReturnType(string typeName)
        {
            switch (this.Name)
            {
                case "Sum":
                case "CumulativeSum":
                    if (typeName == "byte" || typeName == "ushort") return "uint";
                    else if (typeName == "sbyte" || typeName == "short") return "int";
                    break;
            }

            return this.ReturnType ?? typeName;
        }

        public string NativeSuffix(string typeName)
        {
            string suffix = MethodDescriptor.Type2Suffix(typeName);
            string retType = this.GetReturnType(typeName);
            if (retType != typeName)
            {
                suffix += MethodDescriptor.Type2Suffix(retType);
            }
            
            return suffix;
        }
    }
#>

<#+
    void RenderMethod(MethodDescriptor method, string typeName, string typeDescription)
    {
        switch (method.Argument) {
            case ArgumentType.Constant:
#>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, 0);
        }
<#+           if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, 0, incy);
        }
<#+           }
              break;
            case ArgumentType.Vector:
                if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
<#+if (!string.IsNullOrEmpty(method.Returns)) { #>
        /// <returns><#=method.Returns#></returns>
<#+} #>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, y, 0);
        }
<#+             } #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, x, 0, y, 0);
        }
<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=typeName#>[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, x, 0, incx, y, 0, incy);
        }
<#+            }
               if (method.HasGradient && (typeName == "float" || typeName == "double")) { #>

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>Gradient(int length, <#=typeName#>[] x, <#=typeName#>[] dx, int offx, bool cleardx, <#=typeName#>[] y, <#=typeName#>[] dy, int offdy)
        {
            NativeMethods.<#=method.NativeName#>_gradient_<#=method.NativeSuffix(typeName)#>(length, x, dx, offx, cleardx, y, dy, offdy);
        }
<#+           }
              break;
            case ArgumentType.VectorAggregate:
               if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, x, offx);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x)
        {
            return NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, x, 0);
        }

<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, x, offx, incx);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x, int incx)
        {
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, x, 0, incx);
        }
<#+             }
            }
            if (method.HasNotInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=method.GetReturnType(typeName)#>[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x, <#=method.GetReturnType(typeName)#>* y)
        {
            return NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, x, 0, y, 0);
        }

<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=method.GetReturnType(typeName)#>[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=method.GetReturnType(typeName)#>* y, int incy)
        {
            return NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, x, 0, incx, y, 0, incy);
        }
<#+                 }
                }
                break;
            case ArgumentType.TwoVectorsAggregate:
               if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb)
        {
            Debug.Assert(a.Length > offa + length - 1, "The source array should be big enough.");
            Debug.Assert(b.Length > offb + length - 1, "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, a, offa, b, offb);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b)
        {
            return NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, a, 0, b, 0);
        }

<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, int inca, <#=typeName#>[] b, int offb, int incb)
        {
            Debug.Assert(a.Length > offa + ((length - 1) * inca), "The source array should be big enough.");
            Debug.Assert(b.Length > offb + ((length - 1) * incb), "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, a, offa, inca, b, offb, incb);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, int inca, <#=typeName#>* b, int incb)
        {
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, a, 0, inca, b, 0, incb);
        }
<#+             }
            }
            if (method.HasNotInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offa">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=method.GetReturnType(typeName)#>[] y, int offy)
        {
            Debug.Assert(a.Length > offa + length - 1, "The source array should be big enough.");
            Debug.Assert(b.Length > offb + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=method.GetReturnType(typeName)#>* y)
        {
            return NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, 0, b, 0, y, 0);
        }

<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, int inca, <#=typeName#>[] b, int offb, int incb, <#=method.GetReturnType(typeName)#>[] y, int offy, int incy)
        {
            Debug.Assert(a.Length > offa + ((length - 1) * inca), "The source array should be big enough.");
            Debug.Assert(b.Length > offb + ((length - 1) * incb), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The first source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, int inca, <#=typeName#>* b, int incb, <#=method.GetReturnType(typeName)#>* y, int incy)
        {
            return NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }
<#+                 }
                }
                break;
            case ArgumentType.ConstantAndVector:
                if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, 0);
        }
<#+                 if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, <#=method.ConstantName#>, y, 0, incy);
        }
<#+                 }
                } #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, x, offx, <#=method.ConstantName#>, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, x, 0, <#=method.ConstantName#>, y, 0);
        }
<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, x, offx, incx, <#=method.ConstantName#>, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, x, 0, incx, <#=method.ConstantName#>, y, 0, incy);
        }
<#+             }
                if (method.HasGradient && (typeName == "float" || typeName == "double")) { #>

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=method.ConstantType ?? typeName#>, <#=typeName#>[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=method.ConstantType ?? typeName#>, <#=typeName#>[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=method.ConstantType ?? typeName#>, <#=typeName#>[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=method.ConstantType ?? typeName#>, <#=typeName#>[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpGradient#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>Gradient(int length, <#=typeName#>[] x, <#=typeName#>[] dx, int offx, bool cleardx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, <#=typeName#>[] dy, int offdy)
        {
            NativeMethods.<#=method.NativeName#>_gradient_<#=method.NativeSuffix(typeName)#>(length, x, dx, offx, cleardx, <#=method.ConstantName#>, y, dy, offdy);
        }
<#+             }
                break;
            case ArgumentType.TwoVectors:
                if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(length, x, 0, y, 0);
        }
<#+                 if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(length, x, 0, incx, y, 0, incy);
        }
<#+                 }
                } #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, 0, b, 0, y, 0);
        }
<#+             if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, int inca, <#=typeName#>[] b, int offb, int incb, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, int inca, <#=typeName#>* b, int incb, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }
<#+             }
                break;
            case ArgumentType.ThreeVectors:#>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] c, int offc, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, offa, b, offb, c, offc, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* c, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, 0, b, 0, c, 0, y, 0);
        }
<#+             break;
            case ArgumentType.FourVectors:#>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="offd">The starting element position in <paramref name="d"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] c, int offc, <#=typeName#>[] d, int offd, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, offa, b, offb, c, offc, d, offd, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* c, <#=typeName#>* d, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(length, a, 0, b, 0, c, 0, d, 0, y, 0);
        }
<#+         break;
        }
    }
#>

<#+
    void RenderNativeMethod(MethodDescriptor method, string typeName)
    {
        switch (method.Argument) {
            case ArgumentType.Constant:
#>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy);
<#+             if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy, int incy);
<#+             }
                break;
            case ArgumentType.Vector:
                if (method.HasInPlace) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In, Out] <#=typeName#>* y, int offy);
<#+             } #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, [Out] <#=typeName#>* y, int offy);
<#+             if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, int incx, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, int incx, [Out] <#=typeName#>* y, int offy, int incy);
<#+             }
                if (method.HasGradient && (typeName == "float" || typeName == "double")) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_gradient_<#=method.NativeSuffix(typeName)#>(
                int n,
                [In] <#=typeName#>[] x,
                [Out] <#=typeName#>[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] <#=typeName#>[] y,
                [In] <#=typeName#>[] dy,
                int offdy);
<#+             }
                break;
            case ArgumentType.VectorAggregate:
                if (method.HasInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx);
<#+                 if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, int incx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, int incx);
<#+                 }
                }
                if (method.HasNotInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=method.GetReturnType(typeName)#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, [In] <#=method.GetReturnType(typeName)#>* y, int offy);
<#+                 if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, int incx, [In] <#=method.GetReturnType(typeName)#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, int incx, [In] <#=method.GetReturnType(typeName)#>* y, int offy, int incy);
<#+                 }
                }
                break;
            case ArgumentType.TwoVectorsAggregate:
                if (method.HasInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb);
<#+                 if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, int inca, [In] <#=typeName#>[] b, int offb, int incb);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, int inca, [In] <#=typeName#>* b, int offb, int incb);
<#+                 }
                }
                if (method.HasNotInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In] <#=method.GetReturnType(typeName)#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [In] <#=method.GetReturnType(typeName)#>* y, int offy);
<#+                 if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, int inca, [In] <#=typeName#>[] b, int offb, int incb, [In] <#=method.GetReturnType(typeName)#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, int inca, [In] <#=typeName#>* b, int offb, int incb, [In] <#=method.GetReturnType(typeName)#>* y, int offy, int incy);
<#+                 }
                }
                break;
            case ArgumentType.ConstantAndVector:
                if (method.HasInPlace) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>* y, int offy);
<#+                 if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>* y, int offy, int incy);
<#+                 }
                } #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy);
<#+             if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy, int incy);
<#+             }
                if (method.HasGradient && (typeName == "float" || typeName == "double")) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_gradient_<#=method.NativeSuffix(typeName)#>(
                int n,
                [In] <#=typeName#>[] x,
                [Out] <#=typeName#>[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>,
                [In] <#=typeName#>[] y,
                [In] <#=typeName#>[] dy,
                int offdy);
<#+             }
                break;
            case ArgumentType.TwoVectors:
                if (method.HasInPlace) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, [In, Out] <#=typeName#>* y, int offy);
<#+                 if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] x, int offx, int incx, [In, Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_ip_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* x, int offx, int incx, [In, Out] <#=typeName#>* y, int offy, int incy);
<#+                 }
                } #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [Out] <#=typeName#>* y, int offy);
<#+             if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, int inca, [In] <#=typeName#>[] b, int offb, int incb, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, int inca, [In] <#=typeName#>* b, int offb, int incb, [Out] <#=typeName#>* y, int offy, int incy);
<#+             }
                break;
            case ArgumentType.ThreeVectors:#>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In] <#=typeName#>[] c, int offc, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [In] <#=typeName#>* c, int offc, [Out] <#=typeName#>* y, int offy);
<#+             break;
            case ArgumentType.FourVectors:#>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In] <#=typeName#>[] c, int offc, [In] <#=typeName#>[] d, int offd, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=method.NativeSuffix(typeName)#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [In] <#=typeName#>* c, int offc, [In] <#=typeName#>* d, int offd, [Out] <#=typeName#>* y, int offy);
<#+             break;
        }
    }
#>