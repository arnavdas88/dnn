// -----------------------------------------------------------------------
// <copyright file="Vector1D.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Geometry
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.CompilerServices;
<#
    Tuple<string, string>[] classes = 
    {
        Tuple.Create("int", ""),
        Tuple.Create("float", "F"),
        Tuple.Create("double", "D"),
    };

    foreach (Tuple<string, string> cls in classes)
    {
        string type = cls.Item1;
        string suffix = cls.Item2;
#>

    /// <summary>
    /// Represents a vector in a one-dimensional plane.
    /// </summary>
    [DebuggerDisplay("{X} {Length}")]
    public struct Vector1D<#=suffix#>
        : IEquatable<Vector1D<#=suffix#>>
    {
        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
<# if (type == "int") { #>
        private const double Eps = 1e-8;
<# } else { #>
        private const <#=type#> Eps = (<#=type#>)1e-8;
<# } #>

        /// <summary>
        /// The coordinate of the vector.
        /// </summary>
        public <#=type#> X;

        /// <summary>
        /// The length of the vector.
        /// </summary>
        public <#=type#> Length;

        /// <summary>
        /// Initializes a new instance of the <see cref="Vector1D<#=suffix#>"/> struct
        /// that has the specified x-coordinate and y-coordinate of two points.
        /// </summary>
        /// <param name="x">The coordinate of the vector.</param>
        /// <param name="length">The length of the vector.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector1D<#=suffix#>(<#=type#> x, <#=type#> length)
        {
            this.X = x;
            this.Length = length;
        }

        /// <summary>
        /// Gets the center point of this <see cref="Vector1D<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// The center point of this <see cref="Vector1D<#=suffix#>"/>.
        /// </value>
<# if (type == "int") { #>
        /// <remarks>
        /// <para>If the vector length is even, the center point is rounded toward the <see cref="X"/>.</para>
        /// </remarks>
        public <#=type#> Center => this.X + ((this.Length - 1) / 2);
<# } else { #>
        public <#=type#> Center => this.X + (this.Length / 2);
<# } #>

        /// <summary>
        /// Gets the end of the vector.
        /// </summary>
        /// <value>
        /// The end of the vector.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="End"/> property represents the coordinate of the first point at the right edge of the vector that is not contained in the <see cref="Vector1D<#=suffix#>"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Length"/> properties.</para>
        /// </remarks>
        public <#=type#> End => this.X + this.Length;

        /// <summary>
        /// Compares two <see cref="Vector1D<#=suffix#>"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Length"/> properties of the two <see cref="Vector1D<#=suffix#>"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1D<#=suffix#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1D<#=suffix#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Length"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Vector1D<#=suffix#> left, Vector1D<#=suffix#> right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Vector1D<#=suffix#>"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> or <see cref="Length"/> properties of the two <see cref="Vector1D<#=suffix#>"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1D<#=suffix#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1D<#=suffix#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> or <see cref="Length"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Vector1D<#=suffix#> left, Vector1D<#=suffix#> right) => !left.Equals(right);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector1D<#=suffix#> other) =>
<# if (type == "int") { #>
            other.X == this.X &&
            other.Length == this.Length;
<# } else { #>
            Vector1D<#=suffix#>.AreEqual(other.X, this.X) &&
            Vector1D<#=suffix#>.AreEqual(other.Length, this.Length);
<# } #>

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object obj) => obj is Vector1D<#=suffix#> vector && this.Equals(vector);

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.X ^ (int)this.Length);

        /// <inheritdoc />
        public override string ToString() =>
            this.X.ToString(CultureInfo.CurrentCulture) + " " +
            this.Length.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Determines if this <see cref="Vector1D<#=suffix#>"/> contains the specified point.
        /// </summary>
        /// <param name="x">The coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if this <see cref="Vector1D<#=suffix#>"/> contains the specified point; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(<#=type#> x) => x.Between(this.X, this.X + this.Length - 1);
<# if (type != "int") { #>

        /// <summary>
        /// Compares two <see cref="<#=type#>"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="<#=type#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="<#=type#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreEqual(<#=type#> left, <#=type#> right) => left.AreEqual(right, Vector1D<#=suffix#>.Eps);

        /// <summary>
        /// Compares two <see cref="<#=type#>"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="<#=type#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="<#=type#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreNotEqual(<#=type#> left, <#=type#> right) => !left.AreEqual(right, Vector1D<#=suffix#>.Eps);
<#  } #>
    }
<#  } #>
}