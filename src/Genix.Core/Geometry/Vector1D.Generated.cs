// -----------------------------------------------------------------------
// <copyright file="Vector1D.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 11/27/2018 8:04:06 AM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Geometry
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.CompilerServices;

    /// <summary>
    /// Represents a vector in a one-dimensional plane.
    /// </summary>
    [DebuggerDisplay("{X} {Length}")]
    public struct Vector1D
        : IEquatable<Vector1D>
    {
        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const double Eps = 1e-8;

        /// <summary>
        /// The coordinate of the vector.
        /// </summary>
        public int X;

        /// <summary>
        /// The length of the vector.
        /// </summary>
        public int Length;

        /// <summary>
        /// Initializes a new instance of the <see cref="Vector1D"/> struct
        /// that has the specified x-coordinate and y-coordinate of two points.
        /// </summary>
        /// <param name="x">The coordinate of the vector.</param>
        /// <param name="length">The length of the vector.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector1D(int x, int length)
        {
            this.X = x;
            this.Length = length;
        }

        /// <summary>
        /// Gets the center point of this <see cref="Vector1D"/>.
        /// </summary>
        /// <value>
        /// The center point of this <see cref="Vector1D"/>.
        /// </value>
        /// <remarks>
        /// <para>If the vector length is even, the center point is rounded toward the <see cref="X"/>.</para>
        /// </remarks>
        public int Center => this.X + ((this.Length - 1) / 2);

        /// <summary>
        /// Gets the end of the vector.
        /// </summary>
        /// <value>
        /// The end of the vector.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="End"/> property represents the coordinate of the first point at the right edge of the vector that is not contained in the <see cref="Vector1D"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Length"/> properties.</para>
        /// </remarks>
        public int End => this.X + this.Length;

        /// <summary>
        /// Compares two <see cref="Vector1D"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Length"/> properties of the two <see cref="Vector1D"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1D"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1D"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Length"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Vector1D left, Vector1D right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Vector1D"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> or <see cref="Length"/> properties of the two <see cref="Vector1D"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1D"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1D"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> or <see cref="Length"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Vector1D left, Vector1D right) => !left.Equals(right);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector1D other) =>
            other.X == this.X &&
            other.Length == this.Length;

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object obj) => obj is Vector1D vector && this.Equals(vector);

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.X ^ (int)this.Length);

        /// <inheritdoc />
        public override string ToString() =>
            this.X.ToString(CultureInfo.CurrentCulture) + " " +
            this.Length.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Determines if this <see cref="Vector1D"/> contains the specified point.
        /// </summary>
        /// <param name="x">The coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if this <see cref="Vector1D"/> contains the specified point; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(int x) => x.Between(this.X, this.X + this.Length - 1);
    }

    /// <summary>
    /// Represents a vector in a one-dimensional plane.
    /// </summary>
    [DebuggerDisplay("{X} {Length}")]
    public struct Vector1DF
        : IEquatable<Vector1DF>
    {
        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const float Eps = (float)1e-8;

        /// <summary>
        /// The coordinate of the vector.
        /// </summary>
        public float X;

        /// <summary>
        /// The length of the vector.
        /// </summary>
        public float Length;

        /// <summary>
        /// Initializes a new instance of the <see cref="Vector1DF"/> struct
        /// that has the specified x-coordinate and y-coordinate of two points.
        /// </summary>
        /// <param name="x">The coordinate of the vector.</param>
        /// <param name="length">The length of the vector.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector1DF(float x, float length)
        {
            this.X = x;
            this.Length = length;
        }

        /// <summary>
        /// Gets the center point of this <see cref="Vector1DF"/>.
        /// </summary>
        /// <value>
        /// The center point of this <see cref="Vector1DF"/>.
        /// </value>
        public float Center => this.X + (this.Length / 2);

        /// <summary>
        /// Gets the end of the vector.
        /// </summary>
        /// <value>
        /// The end of the vector.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="End"/> property represents the coordinate of the first point at the right edge of the vector that is not contained in the <see cref="Vector1DF"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Length"/> properties.</para>
        /// </remarks>
        public float End => this.X + this.Length;

        /// <summary>
        /// Compares two <see cref="Vector1DF"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Length"/> properties of the two <see cref="Vector1DF"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1DF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1DF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Length"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Vector1DF left, Vector1DF right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Vector1DF"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> or <see cref="Length"/> properties of the two <see cref="Vector1DF"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1DF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1DF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> or <see cref="Length"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Vector1DF left, Vector1DF right) => !left.Equals(right);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector1DF other) =>
            Vector1DF.AreEqual(other.X, this.X) &&
            Vector1DF.AreEqual(other.Length, this.Length);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object obj) => obj is Vector1DF vector && this.Equals(vector);

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.X ^ (int)this.Length);

        /// <inheritdoc />
        public override string ToString() =>
            this.X.ToString(CultureInfo.CurrentCulture) + " " +
            this.Length.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Determines if this <see cref="Vector1DF"/> contains the specified point.
        /// </summary>
        /// <param name="x">The coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if this <see cref="Vector1DF"/> contains the specified point; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(float x) => x.Between(this.X, this.X + this.Length - 1);

        /// <summary>
        /// Compares two <see cref="float"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="float"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="float"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreEqual(float left, float right) => left.AreEqual(right, Vector1DF.Eps);

        /// <summary>
        /// Compares two <see cref="float"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="float"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="float"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreNotEqual(float left, float right) => !left.AreEqual(right, Vector1DF.Eps);
    }

    /// <summary>
    /// Represents a vector in a one-dimensional plane.
    /// </summary>
    [DebuggerDisplay("{X} {Length}")]
    public struct Vector1DD
        : IEquatable<Vector1DD>
    {
        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const double Eps = (double)1e-8;

        /// <summary>
        /// The coordinate of the vector.
        /// </summary>
        public double X;

        /// <summary>
        /// The length of the vector.
        /// </summary>
        public double Length;

        /// <summary>
        /// Initializes a new instance of the <see cref="Vector1DD"/> struct
        /// that has the specified x-coordinate and y-coordinate of two points.
        /// </summary>
        /// <param name="x">The coordinate of the vector.</param>
        /// <param name="length">The length of the vector.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector1DD(double x, double length)
        {
            this.X = x;
            this.Length = length;
        }

        /// <summary>
        /// Gets the center point of this <see cref="Vector1DD"/>.
        /// </summary>
        /// <value>
        /// The center point of this <see cref="Vector1DD"/>.
        /// </value>
        public double Center => this.X + (this.Length / 2);

        /// <summary>
        /// Gets the end of the vector.
        /// </summary>
        /// <value>
        /// The end of the vector.
        /// </value>
        /// <remarks>
        /// <para>The value of the <see cref="End"/> property represents the coordinate of the first point at the right edge of the vector that is not contained in the <see cref="Vector1DD"/>.</para>
        /// <para>The value of the property is equal to the sum of the <see cref="X"/> and <see cref="Length"/> properties.</para>
        /// </remarks>
        public double End => this.X + this.Length;

        /// <summary>
        /// Compares two <see cref="Vector1DD"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> and <see cref="Length"/> properties of the two <see cref="Vector1DD"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1DD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1DD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X"/> and <see cref="Length"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Vector1DD left, Vector1DD right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Vector1DD"/> objects.
        /// The result specifies whether the values of the <see cref="X"/> or <see cref="Length"/> properties of the two <see cref="Vector1DD"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Vector1DD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Vector1DD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X"/> or <see cref="Length"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Vector1DD left, Vector1DD right) => !left.Equals(right);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector1DD other) =>
            Vector1DD.AreEqual(other.X, this.X) &&
            Vector1DD.AreEqual(other.Length, this.Length);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object obj) => obj is Vector1DD vector && this.Equals(vector);

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.X ^ (int)this.Length);

        /// <inheritdoc />
        public override string ToString() =>
            this.X.ToString(CultureInfo.CurrentCulture) + " " +
            this.Length.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Determines if this <see cref="Vector1DD"/> contains the specified point.
        /// </summary>
        /// <param name="x">The coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if this <see cref="Vector1DD"/> contains the specified point; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(double x) => x.Between(this.X, this.X + this.Length - 1);

        /// <summary>
        /// Compares two <see cref="double"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="double"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="double"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreEqual(double left, double right) => left.AreEqual(right, Vector1DD.Eps);

        /// <summary>
        /// Compares two <see cref="double"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="double"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="double"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreNotEqual(double left, double right) => !left.AreEqual(right, Vector1DD.Eps);
    }
}