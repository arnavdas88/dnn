// -----------------------------------------------------------------------
// <copyright file="Size.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 11/27/2018 8:04:05 AM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Geometry
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using Newtonsoft.Json;


    /// <summary>
    /// Represents a dimension in 2D coordinate space.
    /// </summary>
    [TypeConverter(typeof(SizeConverter))]
    [JsonConverter(typeof(SizeJsonConverter))]
    public struct Size
        : IEquatable<Size>
    {
        /// <summary>
        /// Represents a <see cref="Size"/> that has <see cref="Width"/> and <see cref="Height"/> values set to zero.
        /// </summary>
        public static readonly Size Empty;

        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
        private const float Eps = 1e-8f;

        /// <summary>
        /// The horizontal dimension of this <see cref="Size"/>.
        /// </summary>
        private int width;

        /// <summary>
        /// The vertical dimension of this <see cref="Size"/>.
        /// </summary>
        private int height;

        /// <summary>
        /// Initializes a new instance of the <see cref="Size"/> struct with the specified dimensions.
        /// </summary>
        /// <param name="width">The horizontal dimension.</param>
        /// <param name="height">The vertical dimension.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Size(int width, int height)
        {
            this.width = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Size"/> struct from the <see cref="System.Drawing.Size"/>.
        /// </summary>
        /// <param name="size">The <see cref="System.Drawing.Size"/> that contains the dimensions.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Size.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Size.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Size(System.Drawing.Size size)
        {
            this.width = size.Width >= 0 ? size.Width : throw new ArgumentOutOfRangeException(nameof(size), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = size.Height >= 0 ? size.Height : throw new ArgumentOutOfRangeException(nameof(size), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Gets or sets the horizontal dimension of this <see cref="Size"/>.
        /// </summary>
        /// <value>
        /// The horizontal dimension of this <see cref="Size"/>.
        /// </value>
        public int Width
        {
            get => this.width;
            set => this.width = value;
        }

        /// <summary>
        /// Gets or sets the vertical dimension of this <see cref="Size"/>.
        /// </summary>
        /// <value>
        /// The vertical dimension of this <see cref="Size"/>.
        /// </value>
        public int Height
        {
            get => this.height;
            set => this.height = value;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="Size"/> is empty.
        /// </summary>
        /// <value>
        /// <b>true</b> if both <see cref="Width"/> and <see cref="Height"/> are 0; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.width == 0 && this.height == 0;

        /// <summary>
        /// Compares two <see cref="Size"/> objects.
        /// The result specifies whether the values of the <see cref="Width"/> and <see cref="Height"/> properties of the two <see cref="Size"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Size"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Size"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="Width"/> and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Size left, Size right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Size"/> objects.
        /// The result specifies whether the values of the <see cref="Width"/> and <see cref="Height"/> properties of the two <see cref="Size"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Size"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Size"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="Width"/> and <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Size left, Size right) => !left.Equals(right);

        /// <summary>
        /// Initializes a new instance of the <see cref="Size"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="Size"/> in the following format:Width Height.</param>
        /// <returns>The <see cref="Size"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of two values represented by a sequence of digits (0 through 9).
        /// </exception>
        public static Size Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 2 &&
                int.TryParse(split[0], out int width) &&
                int.TryParse(split[1], out int height))
            {
                return new Size(width, height);
            }
            else
            {
                throw new ArgumentException(Core.Properties.Resources.E_InvalidSizeFormat, nameof(value));
            }
        }

        /// <summary>
        /// Performs vector addition of two <see cref="Size"/> structs.
        /// </summary>
        /// <param name="size1">The first <see cref="Size"/> to add.</param>
        /// <param name="size2">The second <see cref="Size"/> to add.</param>
        /// <returns>The <see cref="Size"/> that contains the result of addition.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Size Add(Size size1, Size size2) => new Size(size1.width + size2.width, size1.height + size2.height);

        /// <summary>
        /// Performs vector addition of two <see cref="Size"/> structs.
        /// </summary>
        /// <param name="size">The <see cref="Size"/> to expand.</param>
        /// <param name="dx">The horizontal dimension.</param>
        /// <param name="dy">The vertical dimension.</param>
        /// <returns>The expanded <see cref="Size"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The result has a negative width.</para>
        /// <para>-or-</para>
        /// <para>The result has a negative height.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Size Add(Size size, int dx, int dy) => new Size(size.width + dx, size.height + dy);

        /// <summary>
        /// Contracts a <see cref="Size"/> by another <see cref="Size"/>.
        /// </summary>
        /// <param name="size1">The <see cref="Size"/> to subtract from.</param>
        /// <param name="size2">The <see cref="Size"/> to subtract.</param>
        /// <returns>The contracted <see cref="Size"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The result has a negative width.</para>
        /// <para>-or-</para>
        /// <para>The result has a negative height.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Size Subtract(Size size1, Size size2) => new Size(size1.width - size2.width, size1.height - size2.height);

        /// <summary>
        /// Scales the specified <see cref="Size"/> location.
        /// </summary>
        /// <param name="size">The <see cref="Size"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="Size"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Size Scale(Size size, int dx, int dy) => new Size(size.width * dx, size.height * dy);

        /// <summary>
        /// Scales the specified <see cref="Size"/> location.
        /// </summary>
        /// <param name="size">The <see cref="Size"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="Size"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Size Scale(Size size, float dx, float dy)
        {
            return new Size((dx * size.width).Round(), (dy * size.height).Round());
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Size other) => other.width == this.width && other.height == this.height;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is Size))
            {
                return false;
            }

            return this.Equals((Size)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.width ^ (int)this.height);

        /// <inheritdoc />
        public override string ToString() =>
            this.width.ToString(CultureInfo.CurrentCulture) + " " + this.height.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Sets <see cref="Width"/> and <see cref="Height"/> values set to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.width = this.height = 0;

        /// <summary>
        /// Sets this <see cref="Size"/> position.
        /// </summary>
        /// <param name="width">The horizontal dimension.</param>
        /// <param name="height">The vertical dimension.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(int width, int height)
        {
            this.width = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Scales this <see cref="Size"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(int dx, int dy)
        {
            this.width *= dx;
            this.height *= dy;
        }

        /// <summary>
        /// Scales this <see cref="Size"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(float dx, float dy)
        {
            this.width = (dx * this.width).Round();
            this.height = (dy * this.height).Round();
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="Size"/> to <see cref="string"/>.
    /// </summary>
    internal class SizeConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SizeConverter"/> class.
        /// </summary>
        public SizeConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Core.Properties.Resources.E_TypeConversionNotSupported, "SizeConverter", destType.ToString()));
            }

            return ((Size)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return Size.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Core.Properties.Resources.E_TypeConversionNotSupported, "SizeConverter", value.GetType().ToString()));
            }

            return Size.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="Size"/> struct.
    /// </summary>
    public class SizeJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is Size size)
            {
                writer.WriteValue(size.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting size. Expected Size, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to Size.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing size. Expected String, got {0}.",
                    reader.TokenType));
            }

            return Size.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Represents a dimension in 2D coordinate space.
    /// </summary>
    [TypeConverter(typeof(SizeFConverter))]
    [JsonConverter(typeof(SizeFJsonConverter))]
    public struct SizeF
        : IEquatable<SizeF>
    {
        /// <summary>
        /// Represents a <see cref="SizeF"/> that has <see cref="Width"/> and <see cref="Height"/> values set to zero.
        /// </summary>
        public static readonly SizeF Empty;

        /// <summary>
        /// The horizontal dimension of this <see cref="SizeF"/>.
        /// </summary>
        private float width;

        /// <summary>
        /// The vertical dimension of this <see cref="SizeF"/>.
        /// </summary>
        private float height;

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeF"/> struct with the specified dimensions.
        /// </summary>
        /// <param name="width">The horizontal dimension.</param>
        /// <param name="height">The vertical dimension.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SizeF(float width, float height)
        {
            this.width = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeF"/> struct from the <see cref="System.Drawing.Size"/>.
        /// </summary>
        /// <param name="size">The <see cref="System.Drawing.Size"/> that contains the dimensions.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Size.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Size.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SizeF(System.Drawing.Size size)
        {
            this.width = size.Width >= 0 ? size.Width : throw new ArgumentOutOfRangeException(nameof(size), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = size.Height >= 0 ? size.Height : throw new ArgumentOutOfRangeException(nameof(size), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Gets or sets the horizontal dimension of this <see cref="SizeF"/>.
        /// </summary>
        /// <value>
        /// The horizontal dimension of this <see cref="SizeF"/>.
        /// </value>
        public float Width
        {
            get => this.width;
            set => this.width = value;
        }

        /// <summary>
        /// Gets or sets the vertical dimension of this <see cref="SizeF"/>.
        /// </summary>
        /// <value>
        /// The vertical dimension of this <see cref="SizeF"/>.
        /// </value>
        public float Height
        {
            get => this.height;
            set => this.height = value;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="SizeF"/> is empty.
        /// </summary>
        /// <value>
        /// <b>true</b> if both <see cref="Width"/> and <see cref="Height"/> are 0; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.width == 0 && this.height == 0;

        /// <summary>
        /// Compares two <see cref="SizeF"/> objects.
        /// The result specifies whether the values of the <see cref="Width"/> and <see cref="Height"/> properties of the two <see cref="SizeF"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="SizeF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="SizeF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="Width"/> and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(SizeF left, SizeF right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="SizeF"/> objects.
        /// The result specifies whether the values of the <see cref="Width"/> and <see cref="Height"/> properties of the two <see cref="SizeF"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="SizeF"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="SizeF"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="Width"/> and <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(SizeF left, SizeF right) => !left.Equals(right);

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeF"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="SizeF"/> in the following format:Width Height.</param>
        /// <returns>The <see cref="SizeF"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of two values represented by a sequence of digits (0 through 9).
        /// </exception>
        public static SizeF Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 2 &&
                float.TryParse(split[0], out float width) &&
                float.TryParse(split[1], out float height))
            {
                return new SizeF(width, height);
            }
            else
            {
                throw new ArgumentException(Core.Properties.Resources.E_InvalidSizeFormat, nameof(value));
            }
        }

        /// <summary>
        /// Performs vector addition of two <see cref="SizeF"/> structs.
        /// </summary>
        /// <param name="size1">The first <see cref="SizeF"/> to add.</param>
        /// <param name="size2">The second <see cref="SizeF"/> to add.</param>
        /// <returns>The <see cref="SizeF"/> that contains the result of addition.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeF Add(SizeF size1, SizeF size2) => new SizeF(size1.width + size2.width, size1.height + size2.height);

        /// <summary>
        /// Performs vector addition of two <see cref="SizeF"/> structs.
        /// </summary>
        /// <param name="size">The <see cref="SizeF"/> to expand.</param>
        /// <param name="dx">The horizontal dimension.</param>
        /// <param name="dy">The vertical dimension.</param>
        /// <returns>The expanded <see cref="SizeF"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The result has a negative width.</para>
        /// <para>-or-</para>
        /// <para>The result has a negative height.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeF Add(SizeF size, float dx, float dy) => new SizeF(size.width + dx, size.height + dy);

        /// <summary>
        /// Contracts a <see cref="SizeF"/> by another <see cref="SizeF"/>.
        /// </summary>
        /// <param name="size1">The <see cref="SizeF"/> to subtract from.</param>
        /// <param name="size2">The <see cref="SizeF"/> to subtract.</param>
        /// <returns>The contracted <see cref="SizeF"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The result has a negative width.</para>
        /// <para>-or-</para>
        /// <para>The result has a negative height.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeF Subtract(SizeF size1, SizeF size2) => new SizeF(size1.width - size2.width, size1.height - size2.height);

        /// <summary>
        /// Scales the specified <see cref="SizeF"/> location.
        /// </summary>
        /// <param name="size">The <see cref="SizeF"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="SizeF"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeF Scale(SizeF size, float dx, float dy) => new SizeF(size.width * dx, size.height * dy);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(SizeF other) => other.width == this.width && other.height == this.height;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is SizeF))
            {
                return false;
            }

            return this.Equals((SizeF)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.width ^ (int)this.height);

        /// <inheritdoc />
        public override string ToString() =>
            this.width.ToString(CultureInfo.CurrentCulture) + " " + this.height.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Sets <see cref="Width"/> and <see cref="Height"/> values set to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.width = this.height = 0;

        /// <summary>
        /// Sets this <see cref="SizeF"/> position.
        /// </summary>
        /// <param name="width">The horizontal dimension.</param>
        /// <param name="height">The vertical dimension.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(float width, float height)
        {
            this.width = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Scales this <see cref="SizeF"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(float dx, float dy)
        {
            this.width *= dx;
            this.height *= dy;
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="SizeF"/> to <see cref="string"/>.
    /// </summary>
    internal class SizeFConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SizeFConverter"/> class.
        /// </summary>
        public SizeFConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Core.Properties.Resources.E_TypeConversionNotSupported, "SizeFConverter", destType.ToString()));
            }

            return ((SizeF)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return SizeF.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Core.Properties.Resources.E_TypeConversionNotSupported, "SizeFConverter", value.GetType().ToString()));
            }

            return SizeF.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="SizeF"/> struct.
    /// </summary>
    public class SizeFJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is SizeF size)
            {
                writer.WriteValue(size.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting size. Expected SizeF, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to SizeF.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing size. Expected String, got {0}.",
                    reader.TokenType));
            }

            return SizeF.Parse(reader.Value.ToString());
        }
    }

    /// <summary>
    /// Represents a dimension in 2D coordinate space.
    /// </summary>
    [TypeConverter(typeof(SizeDConverter))]
    [JsonConverter(typeof(SizeDJsonConverter))]
    public struct SizeD
        : IEquatable<SizeD>
    {
        /// <summary>
        /// Represents a <see cref="SizeD"/> that has <see cref="Width"/> and <see cref="Height"/> values set to zero.
        /// </summary>
        public static readonly SizeD Empty;

        /// <summary>
        /// The horizontal dimension of this <see cref="SizeD"/>.
        /// </summary>
        private double width;

        /// <summary>
        /// The vertical dimension of this <see cref="SizeD"/>.
        /// </summary>
        private double height;

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeD"/> struct with the specified dimensions.
        /// </summary>
        /// <param name="width">The horizontal dimension.</param>
        /// <param name="height">The vertical dimension.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SizeD(double width, double height)
        {
            this.width = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeD"/> struct from the <see cref="System.Drawing.Size"/>.
        /// </summary>
        /// <param name="size">The <see cref="System.Drawing.Size"/> that contains the dimensions.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><see cref="System.Drawing.Size.Width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><see cref="System.Drawing.Size.Height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SizeD(System.Drawing.Size size)
        {
            this.width = size.Width >= 0 ? size.Width : throw new ArgumentOutOfRangeException(nameof(size), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = size.Height >= 0 ? size.Height : throw new ArgumentOutOfRangeException(nameof(size), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Gets or sets the horizontal dimension of this <see cref="SizeD"/>.
        /// </summary>
        /// <value>
        /// The horizontal dimension of this <see cref="SizeD"/>.
        /// </value>
        public double Width
        {
            get => this.width;
            set => this.width = value;
        }

        /// <summary>
        /// Gets or sets the vertical dimension of this <see cref="SizeD"/>.
        /// </summary>
        /// <value>
        /// The vertical dimension of this <see cref="SizeD"/>.
        /// </value>
        public double Height
        {
            get => this.height;
            set => this.height = value;
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="SizeD"/> is empty.
        /// </summary>
        /// <value>
        /// <b>true</b> if both <see cref="Width"/> and <see cref="Height"/> are 0; otherwise, <b>false</b>.
        /// </value>
        public bool IsEmpty => this.width == 0 && this.height == 0;

        /// <summary>
        /// Compares two <see cref="SizeD"/> objects.
        /// The result specifies whether the values of the <see cref="Width"/> and <see cref="Height"/> properties of the two <see cref="SizeD"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="SizeD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="SizeD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="Width"/> and <see cref="Height"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(SizeD left, SizeD right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="SizeD"/> objects.
        /// The result specifies whether the values of the <see cref="Width"/> and <see cref="Height"/> properties of the two <see cref="SizeD"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="SizeD"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="SizeD"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="Width"/> and <see cref="Height"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(SizeD left, SizeD right) => !left.Equals(right);

        /// <summary>
        /// Initializes a new instance of the <see cref="SizeD"/> structure using the value represented by the specified string.
        /// </summary>
        /// <param name="value">A <see cref="string"/> that contains a <see cref="SizeD"/> in the following format:Width Height.</param>
        /// <returns>The <see cref="SizeD"/> this method creates.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="value"/> does not consist of two values represented by a sequence of digits (0 through 9).
        /// </exception>
        public static SizeD Parse(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value));
            }

            string[] split = value.Split(' ');
            if (split?.Length == 2 &&
                double.TryParse(split[0], out double width) &&
                double.TryParse(split[1], out double height))
            {
                return new SizeD(width, height);
            }
            else
            {
                throw new ArgumentException(Core.Properties.Resources.E_InvalidSizeFormat, nameof(value));
            }
        }

        /// <summary>
        /// Performs vector addition of two <see cref="SizeD"/> structs.
        /// </summary>
        /// <param name="size1">The first <see cref="SizeD"/> to add.</param>
        /// <param name="size2">The second <see cref="SizeD"/> to add.</param>
        /// <returns>The <see cref="SizeD"/> that contains the result of addition.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeD Add(SizeD size1, SizeD size2) => new SizeD(size1.width + size2.width, size1.height + size2.height);

        /// <summary>
        /// Performs vector addition of two <see cref="SizeD"/> structs.
        /// </summary>
        /// <param name="size">The <see cref="SizeD"/> to expand.</param>
        /// <param name="dx">The horizontal dimension.</param>
        /// <param name="dy">The vertical dimension.</param>
        /// <returns>The expanded <see cref="SizeD"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The result has a negative width.</para>
        /// <para>-or-</para>
        /// <para>The result has a negative height.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeD Add(SizeD size, double dx, double dy) => new SizeD(size.width + dx, size.height + dy);

        /// <summary>
        /// Contracts a <see cref="SizeD"/> by another <see cref="SizeD"/>.
        /// </summary>
        /// <param name="size1">The <see cref="SizeD"/> to subtract from.</param>
        /// <param name="size2">The <see cref="SizeD"/> to subtract.</param>
        /// <returns>The contracted <see cref="SizeD"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The result has a negative width.</para>
        /// <para>-or-</para>
        /// <para>The result has a negative height.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeD Subtract(SizeD size1, SizeD size2) => new SizeD(size1.width - size2.width, size1.height - size2.height);

        /// <summary>
        /// Scales the specified <see cref="SizeD"/> location.
        /// </summary>
        /// <param name="size">The <see cref="SizeD"/> to scale.</param>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        /// <returns>The scaled <see cref="SizeD"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SizeD Scale(SizeD size, double dx, double dy) => new SizeD(size.width * dx, size.height * dy);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(SizeD other) => other.width == this.width && other.height == this.height;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (!(obj is SizeD))
            {
                return false;
            }

            return this.Equals((SizeD)obj);
        }

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.width ^ (int)this.height);

        /// <inheritdoc />
        public override string ToString() =>
            this.width.ToString(CultureInfo.CurrentCulture) + " " + this.height.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Sets <see cref="Width"/> and <see cref="Height"/> values set to zero.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() => this.width = this.height = 0;

        /// <summary>
        /// Sets this <see cref="SizeD"/> position.
        /// </summary>
        /// <param name="width">The horizontal dimension.</param>
        /// <param name="height">The vertical dimension.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="width"/> is a negative value.</para>
        /// <para>-or-</para>
        /// <para><paramref name="height"/> is a negative value.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(double width, double height)
        {
            this.width = width >= 0 ? width : throw new ArgumentOutOfRangeException(nameof(width), Core.Properties.Resources.E_InvalidSizeWidth);
            this.height = height >= 0 ? height : throw new ArgumentOutOfRangeException(nameof(height), Core.Properties.Resources.E_InvalidSizeHeight);
        }

        /// <summary>
        /// Scales this <see cref="SizeD"/> location.
        /// </summary>
        /// <param name="dx">The horizontal scaling factor.</param>
        /// <param name="dy">The vertical scaling factor.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scale(double dx, double dy)
        {
            this.width *= dx;
            this.height *= dy;
        }
    }

    /// <summary>
    /// Provides a unified way of converting <see cref="SizeD"/> to <see cref="string"/>.
    /// </summary>
    internal class SizeDConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SizeDConverter"/> class.
        /// </summary>
        public SizeDConverter()
        {
        }

        /// <inheritdoc />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) => destType == typeof(string);

        /// <inheritdoc />
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType)
        {
            if (destType == null)
            {
                throw new ArgumentNullException(nameof(destType));
            }

            if (destType != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Core.Properties.Resources.E_TypeConversionNotSupported, "SizeDConverter", destType.ToString()));
            }

            return ((SizeD)value).ToString();
        }

        /// <inheritdoc />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type srcType) => srcType == typeof(string);

        /// <inheritdoc />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
            {
                return SizeD.Empty;
            }

            if (value.GetType() != typeof(string))
            {
                throw new NotSupportedException(
                    string.Format(CultureInfo.InvariantCulture, Core.Properties.Resources.E_TypeConversionNotSupported, "SizeDConverter", value.GetType().ToString()));
            }

            return SizeD.Parse((string)value);
        }
    }

    /// <summary>
    /// Represents a Json.NET converter for <see cref="SizeD"/> struct.
    /// </summary>
    public class SizeDJsonConverter : JsonConverter
    {
        /// <inheritdoc />
        public override bool CanConvert(Type objectType) => true;

        /// <inheritdoc />
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is SizeD size)
            {
                writer.WriteValue(size.ToString());
            }
            else
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected value when converting size. Expected SizeD, got {0}.",
                    value?.GetType()));
            }
        }

        /// <inheritdoc />
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                throw new JsonSerializationException("Cannot convert null value to SizeD.");
            }

            if (reader.TokenType != JsonToken.String)
            {
                throw new JsonSerializationException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Unexpected token parsing size. Expected String, got {0}.",
                    reader.TokenType));
            }

            return SizeD.Parse(reader.Value.ToString());
        }
    }
}