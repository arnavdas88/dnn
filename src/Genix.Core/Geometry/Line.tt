// -----------------------------------------------------------------------
// <copyright file="Line.tt" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Geometry
{
    using System;
    using System.Globalization;
    using System.Runtime.CompilerServices;
<#
    Tuple<string, string>[] classes = 
    {
        Tuple.Create("int", ""),
        Tuple.Create("float", "F"),
        Tuple.Create("double", "D"),
    };

    foreach (Tuple<string, string> cls in classes)
    {
        string type = cls.Item1;
        string suffix = cls.Item2;
#>

    /// <summary>
    /// Represents a line in a two-dimensional plane described by two <see cref="Point<#=suffix#>"/> objects.
    /// </summary>
    /// <remarks>
    /// <para>The line is defined by the equation: <c>y = m * x + b</c>.</para>
    /// </remarks>
    public struct Line<#=suffix#>
        : IEquatable<Line<#=suffix#>>
    {
        /// <summary>
        /// Epsilon used in rounding operations.
        /// </summary>
<# if (type == "int") { #>
        private const double Eps = 1e-8;
<# } else { #>
        private const <#=type#> Eps = (<#=type#>)1e-8;
<# } #>

        /// <summary>
        /// The x-coordinate of the first point.
        /// </summary>
        private <#=type#> x1;

        /// <summary>
        /// The y-coordinate of the first point.
        /// </summary>
        private <#=type#> y1;

        /// <summary>
        /// The x-coordinate of the second point.
        /// </summary>
        private <#=type#> x2;

        /// <summary>
        /// The y-coordinate of the second point.
        /// </summary>
        private <#=type#> y2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Line<#=suffix#>"/> struct
        /// that has the specified x-coordinate and y-coordinate of two points.
        /// </summary>
        /// <param name="x1">The x-coordinate of the first point.</param>
        /// <param name="y1">The y-coordinate of the first point.</param>
        /// <param name="x2">The x-coordinate of the second point.</param>
        /// <param name="y2">The y-coordinate of the second point.</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="x1"/> equals <paramref name="x2"/> and <paramref name="y1"/> equals <paramref name="y2"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Line<#=suffix#>(<#=type#> x1, <#=type#> y1, <#=type#> x2, <#=type#> y2)
        {
<# if (type == "int") { #>
            if (x1 == x2 && y1 == y2)
<# } else { #>
            if (Line<#=suffix#>.AreEqual(x1, x2) && Line<#=suffix#>.AreEqual(y1, y2))
<# } #>
            {
                throw new ArgumentException("The line must be defined by two points.");
            }

            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Line<#=suffix#>"/> struct
        /// that has the specified coordinates of two points.
        /// </summary>
        /// <param name="point1">The coordinates of the first point.</param>
        /// <param name="point2">The coordinates of the second point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Line<#=suffix#>(Point<#=suffix#> point1, Point<#=suffix#> point2)
            : this(point1.X, point1.Y, point2.X, point2.Y)
        {
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the first point.
        /// </summary>
        /// <value>
        /// The x-coordinate of the first point.
        /// </value>
        public <#=type#> X1
        {
            get => this.x1;
            set => this.x1 = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the first point.
        /// </summary>
        /// <value>
        /// The y-coordinate of the first point.
        /// </value>
        public <#=type#> Y1
        {
            get => this.y1;
            set => this.y1 = value;
        }

        /// <summary>
        /// Gets or sets the x-coordinate of the second point.
        /// </summary>
        /// <value>
        /// The x-coordinate of the second point.
        /// </value>
        public <#=type#> X2
        {
            get => this.x2;
            set => this.x2 = value;
        }

        /// <summary>
        /// Gets or sets the y-coordinate of the second point.
        /// </summary>
        /// <value>
        /// The y-coordinate of the second point.
        /// </value>
        public <#=type#> Y2
        {
            get => this.y2;
            set => this.y2 = value;
        }

        /// <summary>
        /// Gets the coordinates of the first point.
        /// </summary>
        /// <value>
        /// The <see cref="Point<#=suffix#>"/> that contains the coordinates of the first point.
        /// </value>
        public Point<#=suffix#> Begin => new Point<#=suffix#>(this.X1, this.Y1);

        /// <summary>
        /// Gets the coordinates of the second point.
        /// </summary>
        /// <value>
        /// The <see cref="Point<#=suffix#>"/> that contains the coordinates of the second point.
        /// </value>
        public Point<#=suffix#> End => new Point<#=suffix#>(this.X2, this.Y2);

        /// <summary>
        /// Gets the slope of this <see cref="Line<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// (<see cref="Y2"/> - <see cref="Y1"/>) / (<see cref="X2"/> - <see cref="X1"/>); <see cref="double.PositiveInfinity"/> if <see cref="X2"/> equals <see cref="X1"/>.
        /// </value>
        public double M => this.IsVertical ? double.PositiveInfinity : (double)(this.y2 - this.y1) / (this.x2 - this.x1);

        /// <summary>
        /// Gets the intercept of this <see cref="Line<#=suffix#>"/>.
        /// </summary>
        /// <value>
        /// (<see cref="Y2"/> - <see cref="Y1"/>) / (<see cref="X2"/> - <see cref="X1"/>); <see cref="double.PositiveInfinity"/> if <see cref="X2"/> equals <see cref="X1"/>.
        /// </value>
        public double B => this.IsVertical ? double.NaN : (double)this.y1 - ((double)this.x1 * (this.y2 - this.y1) / (this.x2 - this.x1));

        /// <summary>
        /// Gets a value indicating whether this <see cref="Line<#=suffix#>"/> is a vertical line.
        /// </summary>
        /// <value>
        /// <b>true</b> if this <see cref="Line<#=suffix#>"/> is a vertical line; otherwise, <b>false</b>.
        /// </value>
        public bool IsVertical =>
<# if (type == "int") { #>
            this.x1 == this.x2;
<# } else { #>
            Line<#=suffix#>.AreEqual(this.x1, this.x2);
<# } #>

        /// <summary>
        /// Gets a value indicating whether this <see cref="Line<#=suffix#>"/> is a horizontal line.
        /// </summary>
        /// <value>
        /// <b>true</b> if this <see cref="Line<#=suffix#>"/> is a horizontal line; otherwise, <b>false</b>.
        /// </value>
        public bool IsHorizontal =>
<# if (type == "int") { #>
            this.y1 == this.y2;
<# } else { #>
            Line<#=suffix#>.AreEqual(this.y1, this.y2);
<# } #>

        /// <summary>
        /// Compares two <see cref="Line<#=suffix#>"/> objects.
        /// The result specifies whether the values of the <see cref="X1"/>, <see cref="Y1"/>, <see cref="X2"/>, and <see cref="Y2"/> properties of the two <see cref="Line<#=suffix#>"/> objects are equal.
        /// </summary>
        /// <param name="left">The <see cref="Line<#=suffix#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Line<#=suffix#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the <see cref="X1"/>, <see cref="Y1"/>, <see cref="X2"/>, and <see cref="Y2"/> values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Line<#=suffix#> left, Line<#=suffix#> right) => left.Equals(right);

        /// <summary>
        /// Compares two <see cref="Line<#=suffix#>"/> objects.
        /// The result specifies whether the values of the <see cref="X1"/>, <see cref="Y1"/>, <see cref="X2"/>, and <see cref="Y2"/> properties of the two <see cref="Line<#=suffix#>"/> objects are unequal.
        /// </summary>
        /// <param name="left">The <see cref="Line<#=suffix#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="Line<#=suffix#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values of either <see cref="X1"/>, <see cref="Y1"/>, <see cref="X2"/>, or <see cref="Y2"/> properties of <paramref name="left"/> and <paramref name="right"/> are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Line<#=suffix#> left, Line<#=suffix#> right) => !left.Equals(right);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Line<#=suffix#> other) =>
<# if (type == "int") { #>
            other.x1 == this.x1 &&
            other.y1 == this.y1 &&
            other.x2 == this.x2 &&
            other.y2 == this.y2;
<# } else { #>
            Line<#=suffix#>.AreEqual(other.x1, this.x1) &&
            Line<#=suffix#>.AreEqual(other.y1, this.y1) &&
            Line<#=suffix#>.AreEqual(other.x2, this.x2) &&
            Line<#=suffix#>.AreEqual(other.y2, this.y2);
<# } #>

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object obj) => obj is Line<#=suffix#> line && this.Equals(line);

        /// <inheritdoc />
        public override int GetHashCode() => unchecked((int)this.x1 ^ (int)this.y1 ^ (int)this.x2 ^ (int)this.y2);

        /// <inheritdoc />
        public override string ToString() =>
            this.x1.ToString(CultureInfo.CurrentCulture) + " " +
            this.y1.ToString(CultureInfo.CurrentCulture) + " " +
            this.x2.ToString(CultureInfo.CurrentCulture) + " " +
            this.y2.ToString(CultureInfo.CurrentCulture);

        /// <summary>
        /// Computes the y-coordinate of the point using specified x-coordinate.
        /// </summary>
        /// <param name="x">The x-coordinate of the point.</param>
        /// <returns>
        /// The computed y-coordinate.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// <para><see cref="X1"/> equals <see cref="X2"/>; cannot compute y-coordinate of the point for the vertical line.</para>
        /// </exception>
        public <#=type#> Y(<#=type#> x)
        {
            if (this.IsVertical)
            {
                throw new InvalidOperationException("Cannot compute y-coordinate of the point for the vertical line.");
            }

            <#=type#> dx = (this.x2 - this.x1);
            <#=type#> dy = (this.y2 - this.y1);
            return (<#=type#>)(((double)this.y1 - ((double)(this.x1 - x) * dy / dx))<# if (type == "int") { #>.Round()<# } #>);
        }

        /// <summary>
        /// Computes the x-coordinate of the point using specified y-coordinate.
        /// </summary>
        /// <param name="y">The y-coordinate of the point.</param>
        /// <returns>
        /// The computed x-coordinate.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// <para><see cref="Y1"/> equals <see cref="Y2"/>; cannot compute x-coordinate of the point for the horizontal line.</para>
        /// </exception>
        public <#=type#> X(<#=type#> y)
        {
            if (this.IsHorizontal)
            {
                throw new InvalidOperationException("Cannot compute x-coordinate of the point for the horizontal line.");
            }

            <#=type#> dx = (this.x2 - this.x1);
            <#=type#> dy = (this.y2 - this.y1);
            return (<#=type#>)(((double)this.x1 - ((double)(this.y1 - y) * dx / dy))<# if (type == "int") { #>.Round()<# } #>);
        }

        /// <summary>
        /// Determines if the specified point is on this <see cref="Line<#=suffix#>"/>.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the point defined by <paramref name="x"/> and <paramref name="y"/> is on this <see cref="Line<#=suffix#>"/>; otherwise, <b>false</b>.
        /// </returns>
        public bool Contains(<#=type#> x, <#=type#> y) =>
<# if (type == "int") { #>
            this.x1 == this.x2 ? this.x1 == x : this.Y(x) == y;
<# } else { #>
            Line<#=suffix#>.AreEqual(this.x1, this.x2) ? Line<#=suffix#>.AreEqual(this.x1, x) : Line<#=suffix#>.AreEqual(this.Y(x), y);
<# } #>

        /// <summary>
        /// Determines if the specified <see cref="Point<#=suffix#>"/> is on this <see cref="Line<#=suffix#>"/>.
        /// </summary>
        /// <param name="point">The <see cref="Point<#=suffix#>"/> to test.</param>
        /// <returns>
        /// <b>true</b> if the <see cref="Point<#=suffix#>"/> represented by <paramref name="point"/> is on this <see cref="Line<#=suffix#>"/>; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Point<#=suffix#> point) => this.Contains(point.X, point.Y);

        /// <summary>
        /// Computes a distance between this <see cref="Line<#=suffix#>"/> and the point specified by a pair of coordinates.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// The distance between this <see cref="Line<#=suffix#>"/> and a point specified by <paramref name="x"/> and <paramref name="y"/>.
        /// </returns>
        public double DistanceTo(<#=type#> x, <#=type#> y)
        {
            <#=type#> dx = (this.x2 - this.x1);
            <#=type#> dy = (this.y2 - this.y1);

            return (double)Math.Abs((dy * x) - (dx * y) + (this.x2 * this.y1) + (this.y2 * this.x1)) / Math.Sqrt((dy * dy) + (dx * dx));
        }

        /// <summary>
        /// Computes a distance between this <see cref="Line<#=suffix#>"/> and the specified point.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>
        /// The distance between this <see cref="Line<#=suffix#>"/> and a <paramref name="point"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceTo(Point<#=suffix#> point) => this.DistanceTo(point.X, point.Y);

        /// <summary>
        /// Create a <see cref="Line<#=suffix#>"/> that is parallel to this <see cref="Line<#=suffix#>"/> and passes through the point specified by a pair of coordinates.
        /// </summary>
        /// <param name="x">The x-coordinate of the point the line passes through.</param>
        /// <param name="y">The y-coordinate of the point the line passes through.</param>
        /// <returns>
        /// The <see cref="Line<#=suffix#>"/> this method creates.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Line<#=suffix#> Parallel(<#=type#> x, <#=type#> y)
        {
            return new Line<#=suffix#>(x, y, x - this.x1 + this.x2, y - this.y1 + this.y2);
        }

        /// <summary>
        /// Create a <see cref="Line<#=suffix#>"/> that is parallel to this <see cref="Line<#=suffix#>"/> and passes through the specified point.
        /// </summary>
        /// <param name="point">The point the line passes through.</param>
        /// <returns>
        /// The <see cref="Line<#=suffix#>"/> this method creates.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Line<#=suffix#> Parallel(Point<#=suffix#> point) => this.Parallel(point.X, point.Y);

        /// <summary>
        /// Create a <see cref="Line<#=suffix#>"/> that is perpendicular to this <see cref="Line<#=suffix#>"/> and passes through the point specified by a pair of coordinates.
        /// </summary>
        /// <param name="x">The x-coordinate of the point the line passes through.</param>
        /// <param name="y">The y-coordinate of the point the line passes through.</param>
        /// <returns>
        /// The <see cref="Line<#=suffix#>"/> this method creates.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Line<#=suffix#> Perpendicular(<#=type#> x, <#=type#> y)
        {
            return new Line<#=suffix#>(x, y, x + (this.y2 - this.y1), y - (this.x2 - this.x1));
        }

        /// <summary>
        /// Create a <see cref="Line<#=suffix#>"/> that is perpendicular to this <see cref="Line<#=suffix#>"/> and passes through the specified point.
        /// </summary>
        /// <param name="point">The point the line passes through.</param>
        /// <returns>
        /// The <see cref="Line<#=suffix#>"/> this method creates.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Line<#=suffix#> Perpendicular(Point<#=suffix#> point) => this.Perpendicular(point.X, point.Y);

        /// <summary>
        /// Determines if the specified point is located above this <see cref="Line<#=suffix#>"/>.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the specified point is located above this <see cref="Line<#=suffix#>"/>; otherwise, <b>false</b>.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// <para><see cref="X1"/> equals <see cref="X2"/>; cannot test the condition, the line is vertical.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsAbove(<#=type#> x, <#=type#> y) => y < this.Y(x);

        /// <summary>
        /// Determines if the specified point is located below this <see cref="Line<#=suffix#>"/>.
        /// </summary>
        /// <param name="x">The x-coordinate of the point to test.</param>
        /// <param name="y">The y-coordinate of the point to test.</param>
        /// <returns>
        /// <b>true</b> if the specified point is located below this <see cref="Line<#=suffix#>"/>; otherwise, <b>false</b>.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// <para><see cref="X1"/> equals <see cref="X2"/>; cannot text the condition, the line is vertical.</para>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsBelow(<#=type#> x, <#=type#> y) => y > this.Y(x);
<# if (type != "int") { #>

        /// <summary>
        /// Compares two <see cref="<#=type#>"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="<#=type#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="<#=type#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are equal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreEqual(<#=type#> left, <#=type#> right) => left.AreEqual(right, Line<#=suffix#>.Eps);

        /// <summary>
        /// Compares two <see cref="<#=type#>"/> objects.
        /// </summary>
        /// <param name="left">The <see cref="<#=type#>"/> structure that is to the left of the equality operator.</param>
        /// <param name="right">The <see cref="<#=type#>"/> structure that is to the right of the equality operator.</param>
        /// <returns><b>true</b> if the values are unequal; otherwise, <b>false</b>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool AreNotEqual(<#=type#> left, <#=type#> right) => !left.AreEqual(right, Line<#=suffix#>.Eps);
<#  } #>
    }
<#  } #>
}