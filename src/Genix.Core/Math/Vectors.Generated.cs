// -----------------------------------------------------------------------
// <copyright file="Vectors.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 9/25/2018 5:45:11 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------


namespace Genix.Core
{
    using System;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;

    /// <summary>
    /// Provides mathematical methods for numeric vectors manipulation.
    /// </summary>
    [CLSCompliant(false)]
    public static class Vectors
    {

        /// <summary>
        /// Creates an array of 8-bit signed integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte[] Create(int length, sbyte value)
        {
            sbyte[] a = new sbyte[length];
            if (value != default(sbyte))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 8-bit signed integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            return NativeMethods.compare_s8(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 8-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 8-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.copy_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 8-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, sbyte[] x, int offx, int incx, sbyte[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_s8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 8-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, sbyte* x, int incx, sbyte* y, int incy)
        {
            NativeMethods.copy_inc_s8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 8-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 8-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.move_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, sbyte a, sbyte[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_s8(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, sbyte a, sbyte* y)
        {
            NativeMethods.set_s8(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, sbyte a, sbyte[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_s8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.set_inc_s8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.swap_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, sbyte[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_ip_s8(length, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, sbyte* y)
        {
            NativeMethods.abs_ip_s8(length, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.abs_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.addc_ip_s8(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, sbyte a, sbyte* y)
        {
            NativeMethods.addc_ip_s8(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_s8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.addc_inc_ip_s8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, sbyte[] x, int offx, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.addc_s8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, sbyte* x, sbyte a, sbyte* y)
        {
            NativeMethods.addc_s8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, sbyte[] x, int offx, int incx, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_s8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, sbyte* x, int incx, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.addc_inc_s8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.subc_ip_s8(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, sbyte a, sbyte* y)
        {
            NativeMethods.subc_ip_s8(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_s8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.subc_inc_ip_s8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, sbyte[] x, int offx, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.subc_s8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, sbyte* x, sbyte a, sbyte* y)
        {
            NativeMethods.subc_s8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, sbyte[] x, int offx, int incx, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_s8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, sbyte* x, int incx, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.subc_inc_s8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.mulc_ip_s8(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, sbyte a, sbyte* y)
        {
            NativeMethods.mulc_ip_s8(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_s8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.mulc_inc_ip_s8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, sbyte[] x, int offx, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.mulc_s8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, sbyte* x, sbyte a, sbyte* y)
        {
            NativeMethods.mulc_s8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, sbyte[] x, int offx, int incx, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_s8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, sbyte* x, int incx, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.mulc_inc_s8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.divc_ip_s8(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, sbyte a, sbyte* y)
        {
            NativeMethods.divc_ip_s8(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_s8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.divc_inc_ip_s8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, sbyte[] x, int offx, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.divc_s8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, sbyte* x, sbyte a, sbyte* y)
        {
            NativeMethods.divc_s8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, sbyte[] x, int offx, int incx, sbyte a, sbyte[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_s8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, sbyte* x, int incx, sbyte a, sbyte* y, int incy)
        {
            NativeMethods.divc_inc_s8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            NativeMethods.add_ip_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.add_ip_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, sbyte[] x, int offx, int incx, sbyte[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_s8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, sbyte* x, int incx, sbyte* y, int incy)
        {
            NativeMethods.add_inc_ip_s8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.add_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, sbyte* a, sbyte* b, sbyte* y)
        {
            NativeMethods.add_s8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, sbyte[] a, int offa, int inca, sbyte[] b, int offb, int incb, sbyte[] y, int offy, int incy)
        {
            NativeMethods.add_inc_s8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, sbyte* a, int inca, sbyte* b, int incb, sbyte* y, int incy)
        {
            NativeMethods.add_inc_s8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            NativeMethods.sub_ip_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.sub_ip_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, sbyte[] x, int offx, int incx, sbyte[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_s8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, sbyte* x, int incx, sbyte* y, int incy)
        {
            NativeMethods.sub_inc_ip_s8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.sub_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, sbyte* a, sbyte* b, sbyte* y)
        {
            NativeMethods.sub_s8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, sbyte[] a, int offa, int inca, sbyte[] b, int offb, int incb, sbyte[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_s8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, sbyte* a, int inca, sbyte* b, int incb, sbyte* y, int incy)
        {
            NativeMethods.sub_inc_s8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            NativeMethods.mul_ip_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.mul_ip_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, sbyte[] x, int offx, int incx, sbyte[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_s8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, sbyte* x, int incx, sbyte* y, int incy)
        {
            NativeMethods.mul_inc_ip_s8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.mul_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, sbyte* a, sbyte* b, sbyte* y)
        {
            NativeMethods.mul_s8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, sbyte[] a, int offa, int inca, sbyte[] b, int offb, int incb, sbyte[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_s8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, sbyte* a, int inca, sbyte* b, int incb, sbyte* y, int incy)
        {
            NativeMethods.mul_inc_s8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            NativeMethods.div_ip_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.div_ip_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, sbyte[] x, int offx, int incx, sbyte[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_s8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, sbyte* x, int incx, sbyte* y, int incy)
        {
            NativeMethods.div_inc_ip_s8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.div_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, sbyte* a, sbyte* b, sbyte* y)
        {
            NativeMethods.div_s8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, sbyte[] a, int offa, int inca, sbyte[] b, int offb, int incb, sbyte[] y, int offy, int incy)
        {
            NativeMethods.div_inc_s8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, sbyte* a, int inca, sbyte* b, int incb, sbyte* y, int incy)
        {
            NativeMethods.div_inc_s8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, sbyte[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_s8(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, sbyte* y)
        {
            NativeMethods.sqr_ip_s8(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.sqr_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, sbyte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_s8(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, sbyte* x)
        {
            return NativeMethods.argmin_ip_s8(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte Min(int length, sbyte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_s8(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe sbyte Min(int length, sbyte* x)
        {
            return NativeMethods._min_ip_s8(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, sbyte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_s8(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, sbyte* x)
        {
            return NativeMethods.argmax_ip_s8(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte Max(int length, sbyte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_s8(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe sbyte Max(int length, sbyte* x)
        {
            return NativeMethods._max_ip_s8(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.minc_ip_s8(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, sbyte a, sbyte* y)
        {
            NativeMethods.minc_ip_s8(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, sbyte[] x, int offx, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.minc_s8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, sbyte* x, sbyte a, sbyte* y)
        {
            NativeMethods.minc_s8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            NativeMethods.min_ip_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.min_ip_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.min_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, sbyte* a, sbyte* b, sbyte* y)
        {
            NativeMethods.min_s8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.maxc_ip_s8(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, sbyte a, sbyte* y)
        {
            NativeMethods.maxc_ip_s8(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, sbyte[] x, int offx, sbyte a, sbyte[] y, int offy)
        {
            NativeMethods.maxc_s8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, sbyte* x, sbyte a, sbyte* y)
        {
            NativeMethods.maxc_s8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            NativeMethods.max_ip_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, sbyte* x, sbyte* y)
        {
            NativeMethods.max_ip_s8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.max_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, sbyte* a, sbyte* b, sbyte* y)
        {
            NativeMethods.max_s8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Sum(int length, sbyte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_s8(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int Sum(int length, sbyte* x)
        {
            return NativeMethods.sum_ip_s8(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte CumulativeSum(int length, sbyte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_s8(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe sbyte CumulativeSum(int length, sbyte* x)
        {
            return NativeMethods.cumulative_sum_ip_s8(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte CumulativeSum(int length, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_s8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe sbyte CumulativeSum(int length, sbyte* x, sbyte* y)
        {
            return NativeMethods.cumulative_sum_s8(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 8-bit signed integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, sbyte minValue, sbyte maxValue, sbyte[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 8-bit signed integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, sbyte[] x, int offx, sbyte[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 8-bit signed integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, sbyte[] x, int offx, sbyte alpha, sbyte[] y, int offy)
        {
            NativeMethods.addproductc_s8(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 8-bit signed integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, sbyte[] a, int offa, sbyte[] b, int offb, sbyte[] y, int offy)
        {
            NativeMethods.addproduct_s8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, sbyte[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_s8(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 8-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, sbyte[] x, int offx, out sbyte min, out sbyte max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 8-bit signed integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, sbyte threshold, sbyte value, sbyte[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_s8(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 8-bit signed integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, sbyte threshold, sbyte value, sbyte[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_s8(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 8-bit signed integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, sbyte thresholdLT, sbyte valueLT, sbyte thresholdGT, sbyte valueGT, sbyte[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_s8(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 8-bit unsigned integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte[] Create(int length, byte value)
        {
            byte[] a = new byte[length];
            if (value != default(byte))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 8-bit unsigned integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, byte[] x, int offx, byte[] y, int offy)
        {
            return NativeMethods.compare_u8(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 8-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, byte[] x, int offx, byte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 8-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, byte* x, byte* y)
        {
            NativeMethods.copy_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 8-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, byte[] x, int offx, int incx, byte[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_u8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 8-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, byte* x, int incx, byte* y, int incy)
        {
            NativeMethods.copy_inc_u8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 8-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, byte[] x, int offx, byte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 8-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, byte* x, byte* y)
        {
            NativeMethods.move_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, byte a, byte[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_u8(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, byte a, byte* y)
        {
            NativeMethods.set_u8(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, byte a, byte[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_u8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 8-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, byte a, byte* y, int incy)
        {
            NativeMethods.set_inc_u8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, byte[] x, int offx, byte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, byte* x, byte* y)
        {
            NativeMethods.swap_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, byte a, byte[] y, int offy)
        {
            NativeMethods.addc_ip_u8(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, byte a, byte* y)
        {
            NativeMethods.addc_ip_u8(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_u8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, byte a, byte* y, int incy)
        {
            NativeMethods.addc_inc_ip_u8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, byte[] x, int offx, byte a, byte[] y, int offy)
        {
            NativeMethods.addc_u8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, byte* x, byte a, byte* y)
        {
            NativeMethods.addc_u8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, byte[] x, int offx, int incx, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_u8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, byte* x, int incx, byte a, byte* y, int incy)
        {
            NativeMethods.addc_inc_u8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, byte a, byte[] y, int offy)
        {
            NativeMethods.subc_ip_u8(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, byte a, byte* y)
        {
            NativeMethods.subc_ip_u8(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_u8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, byte a, byte* y, int incy)
        {
            NativeMethods.subc_inc_ip_u8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, byte[] x, int offx, byte a, byte[] y, int offy)
        {
            NativeMethods.subc_u8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, byte* x, byte a, byte* y)
        {
            NativeMethods.subc_u8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, byte[] x, int offx, int incx, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_u8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, byte* x, int incx, byte a, byte* y, int incy)
        {
            NativeMethods.subc_inc_u8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, byte a, byte[] y, int offy)
        {
            NativeMethods.mulc_ip_u8(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, byte a, byte* y)
        {
            NativeMethods.mulc_ip_u8(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_u8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, byte a, byte* y, int incy)
        {
            NativeMethods.mulc_inc_ip_u8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, byte[] x, int offx, byte a, byte[] y, int offy)
        {
            NativeMethods.mulc_u8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, byte* x, byte a, byte* y)
        {
            NativeMethods.mulc_u8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, byte[] x, int offx, int incx, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_u8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 8-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, byte* x, int incx, byte a, byte* y, int incy)
        {
            NativeMethods.mulc_inc_u8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, byte a, byte[] y, int offy)
        {
            NativeMethods.divc_ip_u8(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, byte a, byte* y)
        {
            NativeMethods.divc_ip_u8(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_u8(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, byte a, byte* y, int incy)
        {
            NativeMethods.divc_inc_ip_u8(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, byte[] x, int offx, byte a, byte[] y, int offy)
        {
            NativeMethods.divc_u8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, byte* x, byte a, byte* y)
        {
            NativeMethods.divc_u8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, byte[] x, int offx, int incx, byte a, byte[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_u8(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 8-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, byte* x, int incx, byte a, byte* y, int incy)
        {
            NativeMethods.divc_inc_u8(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, byte[] x, int offx, byte[] y, int offy)
        {
            NativeMethods.add_ip_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, byte* x, byte* y)
        {
            NativeMethods.add_ip_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, byte[] x, int offx, int incx, byte[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_u8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, byte* x, int incx, byte* y, int incy)
        {
            NativeMethods.add_inc_ip_u8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.add_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, byte* a, byte* b, byte* y)
        {
            NativeMethods.add_u8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, byte[] a, int offa, int inca, byte[] b, int offb, int incb, byte[] y, int offy, int incy)
        {
            NativeMethods.add_inc_u8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, byte* a, int inca, byte* b, int incb, byte* y, int incy)
        {
            NativeMethods.add_inc_u8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, byte[] x, int offx, byte[] y, int offy)
        {
            NativeMethods.sub_ip_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, byte* x, byte* y)
        {
            NativeMethods.sub_ip_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, byte[] x, int offx, int incx, byte[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_u8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, byte* x, int incx, byte* y, int incy)
        {
            NativeMethods.sub_inc_ip_u8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.sub_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, byte* a, byte* b, byte* y)
        {
            NativeMethods.sub_u8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, byte[] a, int offa, int inca, byte[] b, int offb, int incb, byte[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_u8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, byte* a, int inca, byte* b, int incb, byte* y, int incy)
        {
            NativeMethods.sub_inc_u8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, byte[] x, int offx, byte[] y, int offy)
        {
            NativeMethods.mul_ip_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, byte* x, byte* y)
        {
            NativeMethods.mul_ip_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, byte[] x, int offx, int incx, byte[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_u8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, byte* x, int incx, byte* y, int incy)
        {
            NativeMethods.mul_inc_ip_u8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.mul_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, byte* a, byte* b, byte* y)
        {
            NativeMethods.mul_u8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, byte[] a, int offa, int inca, byte[] b, int offb, int incb, byte[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_u8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, byte* a, int inca, byte* b, int incb, byte* y, int incy)
        {
            NativeMethods.mul_inc_u8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, byte[] x, int offx, byte[] y, int offy)
        {
            NativeMethods.div_ip_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, byte* x, byte* y)
        {
            NativeMethods.div_ip_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, byte[] x, int offx, int incx, byte[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_u8(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, byte* x, int incx, byte* y, int incy)
        {
            NativeMethods.div_inc_ip_u8(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.div_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, byte* a, byte* b, byte* y)
        {
            NativeMethods.div_u8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, byte[] a, int offa, int inca, byte[] b, int offb, int incb, byte[] y, int offy, int incy)
        {
            NativeMethods.div_inc_u8(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 8-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, byte* a, int inca, byte* b, int incb, byte* y, int incy)
        {
            NativeMethods.div_inc_u8(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, byte[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_u8(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, byte* y)
        {
            NativeMethods.sqr_ip_u8(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, byte[] x, int offx, byte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, byte* x, byte* y)
        {
            NativeMethods.sqr_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, byte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_u8(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, byte* x)
        {
            return NativeMethods.argmin_ip_u8(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Min(int length, byte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_u8(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe byte Min(int length, byte* x)
        {
            return NativeMethods._min_ip_u8(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, byte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_u8(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, byte* x)
        {
            return NativeMethods.argmax_ip_u8(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Max(int length, byte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_u8(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe byte Max(int length, byte* x)
        {
            return NativeMethods._max_ip_u8(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, byte a, byte[] y, int offy)
        {
            NativeMethods.minc_ip_u8(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, byte a, byte* y)
        {
            NativeMethods.minc_ip_u8(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, byte[] x, int offx, byte a, byte[] y, int offy)
        {
            NativeMethods.minc_u8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 8-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, byte* x, byte a, byte* y)
        {
            NativeMethods.minc_u8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, byte[] x, int offx, byte[] y, int offy)
        {
            NativeMethods.min_ip_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, byte* x, byte* y)
        {
            NativeMethods.min_ip_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.min_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, byte* a, byte* b, byte* y)
        {
            NativeMethods.min_u8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, byte a, byte[] y, int offy)
        {
            NativeMethods.maxc_ip_u8(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, byte a, byte* y)
        {
            NativeMethods.maxc_ip_u8(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, byte[] x, int offx, byte a, byte[] y, int offy)
        {
            NativeMethods.maxc_u8(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 8-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, byte* x, byte a, byte* y)
        {
            NativeMethods.maxc_u8(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, byte[] x, int offx, byte[] y, int offy)
        {
            NativeMethods.max_ip_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, byte* x, byte* y)
        {
            NativeMethods.max_ip_u8(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.max_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, byte* a, byte* b, byte* y)
        {
            NativeMethods.max_u8(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Sum(int length, byte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_u8(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint Sum(int length, byte* x)
        {
            return NativeMethods.sum_ip_u8(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte CumulativeSum(int length, byte[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_u8(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe byte CumulativeSum(int length, byte* x)
        {
            return NativeMethods.cumulative_sum_ip_u8(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte CumulativeSum(int length, byte[] x, int offx, byte[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_u8(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe byte CumulativeSum(int length, byte* x, byte* y)
        {
            return NativeMethods.cumulative_sum_u8(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 8-bit unsigned integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, byte minValue, byte maxValue, byte[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 8-bit unsigned integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, byte[] x, int offx, byte[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 8-bit unsigned integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, byte[] x, int offx, byte alpha, byte[] y, int offy)
        {
            NativeMethods.addproductc_u8(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 8-bit unsigned integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, byte[] a, int offa, byte[] b, int offb, byte[] y, int offy)
        {
            NativeMethods.addproduct_u8(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, byte[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_u8(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, byte[] x, int offx, out byte min, out byte max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 8-bit unsigned integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, byte threshold, byte value, byte[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_u8(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 8-bit unsigned integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, byte threshold, byte value, byte[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_u8(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 8-bit unsigned integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, byte thresholdLT, byte valueLT, byte thresholdGT, byte valueGT, byte[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_u8(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 16-bit signed integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short[] Create(int length, short value)
        {
            short[] a = new short[length];
            if (value != default(short))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 16-bit signed integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, short[] x, int offx, short[] y, int offy)
        {
            return NativeMethods.compare_s16(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 16-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, short[] x, int offx, short[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 16-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, short* x, short* y)
        {
            NativeMethods.copy_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 16-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, short[] x, int offx, int incx, short[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_s16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 16-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, short* x, int incx, short* y, int incy)
        {
            NativeMethods.copy_inc_s16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 16-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, short[] x, int offx, short[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 16-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, short* x, short* y)
        {
            NativeMethods.move_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, short a, short[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_s16(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, short a, short* y)
        {
            NativeMethods.set_s16(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, short a, short[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_s16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, short a, short* y, int incy)
        {
            NativeMethods.set_inc_s16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, short[] x, int offx, short[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, short* x, short* y)
        {
            NativeMethods.swap_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, short[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_ip_s16(length, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, short* y)
        {
            NativeMethods.abs_ip_s16(length, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, short[] x, int offx, short[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, short* x, short* y)
        {
            NativeMethods.abs_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, short a, short[] y, int offy)
        {
            NativeMethods.addc_ip_s16(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, short a, short* y)
        {
            NativeMethods.addc_ip_s16(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, short a, short[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_s16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, short a, short* y, int incy)
        {
            NativeMethods.addc_inc_ip_s16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, short[] x, int offx, short a, short[] y, int offy)
        {
            NativeMethods.addc_s16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, short* x, short a, short* y)
        {
            NativeMethods.addc_s16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, short[] x, int offx, int incx, short a, short[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_s16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, short* x, int incx, short a, short* y, int incy)
        {
            NativeMethods.addc_inc_s16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, short a, short[] y, int offy)
        {
            NativeMethods.subc_ip_s16(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, short a, short* y)
        {
            NativeMethods.subc_ip_s16(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, short a, short[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_s16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, short a, short* y, int incy)
        {
            NativeMethods.subc_inc_ip_s16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, short[] x, int offx, short a, short[] y, int offy)
        {
            NativeMethods.subc_s16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, short* x, short a, short* y)
        {
            NativeMethods.subc_s16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, short[] x, int offx, int incx, short a, short[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_s16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, short* x, int incx, short a, short* y, int incy)
        {
            NativeMethods.subc_inc_s16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, short a, short[] y, int offy)
        {
            NativeMethods.mulc_ip_s16(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, short a, short* y)
        {
            NativeMethods.mulc_ip_s16(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, short a, short[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_s16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, short a, short* y, int incy)
        {
            NativeMethods.mulc_inc_ip_s16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, short[] x, int offx, short a, short[] y, int offy)
        {
            NativeMethods.mulc_s16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, short* x, short a, short* y)
        {
            NativeMethods.mulc_s16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, short[] x, int offx, int incx, short a, short[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_s16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, short* x, int incx, short a, short* y, int incy)
        {
            NativeMethods.mulc_inc_s16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, short a, short[] y, int offy)
        {
            NativeMethods.divc_ip_s16(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, short a, short* y)
        {
            NativeMethods.divc_ip_s16(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, short a, short[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_s16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, short a, short* y, int incy)
        {
            NativeMethods.divc_inc_ip_s16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, short[] x, int offx, short a, short[] y, int offy)
        {
            NativeMethods.divc_s16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, short* x, short a, short* y)
        {
            NativeMethods.divc_s16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, short[] x, int offx, int incx, short a, short[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_s16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, short* x, int incx, short a, short* y, int incy)
        {
            NativeMethods.divc_inc_s16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, short[] x, int offx, short[] y, int offy)
        {
            NativeMethods.add_ip_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, short* x, short* y)
        {
            NativeMethods.add_ip_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, short[] x, int offx, int incx, short[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_s16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, short* x, int incx, short* y, int incy)
        {
            NativeMethods.add_inc_ip_s16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.add_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, short* a, short* b, short* y)
        {
            NativeMethods.add_s16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, short[] a, int offa, int inca, short[] b, int offb, int incb, short[] y, int offy, int incy)
        {
            NativeMethods.add_inc_s16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, short* a, int inca, short* b, int incb, short* y, int incy)
        {
            NativeMethods.add_inc_s16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, short[] x, int offx, short[] y, int offy)
        {
            NativeMethods.sub_ip_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, short* x, short* y)
        {
            NativeMethods.sub_ip_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, short[] x, int offx, int incx, short[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_s16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, short* x, int incx, short* y, int incy)
        {
            NativeMethods.sub_inc_ip_s16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.sub_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, short* a, short* b, short* y)
        {
            NativeMethods.sub_s16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, short[] a, int offa, int inca, short[] b, int offb, int incb, short[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_s16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, short* a, int inca, short* b, int incb, short* y, int incy)
        {
            NativeMethods.sub_inc_s16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, short[] x, int offx, short[] y, int offy)
        {
            NativeMethods.mul_ip_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, short* x, short* y)
        {
            NativeMethods.mul_ip_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, short[] x, int offx, int incx, short[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_s16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, short* x, int incx, short* y, int incy)
        {
            NativeMethods.mul_inc_ip_s16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.mul_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, short* a, short* b, short* y)
        {
            NativeMethods.mul_s16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, short[] a, int offa, int inca, short[] b, int offb, int incb, short[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_s16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, short* a, int inca, short* b, int incb, short* y, int incy)
        {
            NativeMethods.mul_inc_s16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, short[] x, int offx, short[] y, int offy)
        {
            NativeMethods.div_ip_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, short* x, short* y)
        {
            NativeMethods.div_ip_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, short[] x, int offx, int incx, short[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_s16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, short* x, int incx, short* y, int incy)
        {
            NativeMethods.div_inc_ip_s16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.div_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, short* a, short* b, short* y)
        {
            NativeMethods.div_s16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, short[] a, int offa, int inca, short[] b, int offb, int incb, short[] y, int offy, int incy)
        {
            NativeMethods.div_inc_s16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, short* a, int inca, short* b, int incb, short* y, int incy)
        {
            NativeMethods.div_inc_s16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, short[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_s16(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, short* y)
        {
            NativeMethods.sqr_ip_s16(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, short[] x, int offx, short[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, short* x, short* y)
        {
            NativeMethods.sqr_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, short[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_s16(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, short* x)
        {
            return NativeMethods.argmin_ip_s16(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short Min(int length, short[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_s16(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe short Min(int length, short* x)
        {
            return NativeMethods._min_ip_s16(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, short[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_s16(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, short* x)
        {
            return NativeMethods.argmax_ip_s16(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short Max(int length, short[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_s16(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe short Max(int length, short* x)
        {
            return NativeMethods._max_ip_s16(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, short a, short[] y, int offy)
        {
            NativeMethods.minc_ip_s16(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, short a, short* y)
        {
            NativeMethods.minc_ip_s16(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, short[] x, int offx, short a, short[] y, int offy)
        {
            NativeMethods.minc_s16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, short* x, short a, short* y)
        {
            NativeMethods.minc_s16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, short[] x, int offx, short[] y, int offy)
        {
            NativeMethods.min_ip_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, short* x, short* y)
        {
            NativeMethods.min_ip_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.min_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, short* a, short* b, short* y)
        {
            NativeMethods.min_s16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, short a, short[] y, int offy)
        {
            NativeMethods.maxc_ip_s16(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, short a, short* y)
        {
            NativeMethods.maxc_ip_s16(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, short[] x, int offx, short a, short[] y, int offy)
        {
            NativeMethods.maxc_s16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, short* x, short a, short* y)
        {
            NativeMethods.maxc_s16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, short[] x, int offx, short[] y, int offy)
        {
            NativeMethods.max_ip_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, short* x, short* y)
        {
            NativeMethods.max_ip_s16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.max_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, short* a, short* b, short* y)
        {
            NativeMethods.max_s16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short Sum(int length, short[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_s16(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe short Sum(int length, short* x)
        {
            return NativeMethods.sum_ip_s16(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short CumulativeSum(int length, short[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_s16(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe short CumulativeSum(int length, short* x)
        {
            return NativeMethods.cumulative_sum_ip_s16(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short CumulativeSum(int length, short[] x, int offx, short[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_s16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe short CumulativeSum(int length, short* x, short* y)
        {
            return NativeMethods.cumulative_sum_s16(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 16-bit signed integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, short minValue, short maxValue, short[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 16-bit signed integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, short[] x, int offx, short[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 16-bit signed integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, short[] x, int offx, short alpha, short[] y, int offy)
        {
            NativeMethods.addproductc_s16(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 16-bit signed integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, short[] a, int offa, short[] b, int offb, short[] y, int offy)
        {
            NativeMethods.addproduct_s16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, short[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_s16(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 16-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, short[] x, int offx, out short min, out short max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 16-bit signed integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, short threshold, short value, short[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_s16(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 16-bit signed integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, short threshold, short value, short[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_s16(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 16-bit signed integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, short thresholdLT, short valueLT, short thresholdGT, short valueGT, short[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_s16(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 16-bit unsigned integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort[] Create(int length, ushort value)
        {
            ushort[] a = new ushort[length];
            if (value != default(ushort))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 16-bit unsigned integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            return NativeMethods.compare_u16(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 16-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 16-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, ushort* x, ushort* y)
        {
            NativeMethods.copy_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 16-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, ushort[] x, int offx, int incx, ushort[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_u16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 16-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, ushort* x, int incx, ushort* y, int incy)
        {
            NativeMethods.copy_inc_u16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 16-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 16-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, ushort* x, ushort* y)
        {
            NativeMethods.move_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, ushort a, ushort[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_u16(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, ushort a, ushort* y)
        {
            NativeMethods.set_u16(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, ushort a, ushort[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_u16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 16-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, ushort a, ushort* y, int incy)
        {
            NativeMethods.set_inc_u16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, ushort* x, ushort* y)
        {
            NativeMethods.swap_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ushort a, ushort[] y, int offy)
        {
            NativeMethods.addc_ip_u16(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ushort a, ushort* y)
        {
            NativeMethods.addc_ip_u16(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_u16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ushort a, ushort* y, int incy)
        {
            NativeMethods.addc_inc_ip_u16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ushort[] x, int offx, ushort a, ushort[] y, int offy)
        {
            NativeMethods.addc_u16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ushort* x, ushort a, ushort* y)
        {
            NativeMethods.addc_u16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ushort[] x, int offx, int incx, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_u16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ushort* x, int incx, ushort a, ushort* y, int incy)
        {
            NativeMethods.addc_inc_u16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ushort a, ushort[] y, int offy)
        {
            NativeMethods.subc_ip_u16(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ushort a, ushort* y)
        {
            NativeMethods.subc_ip_u16(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_u16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ushort a, ushort* y, int incy)
        {
            NativeMethods.subc_inc_ip_u16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ushort[] x, int offx, ushort a, ushort[] y, int offy)
        {
            NativeMethods.subc_u16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ushort* x, ushort a, ushort* y)
        {
            NativeMethods.subc_u16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ushort[] x, int offx, int incx, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_u16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ushort* x, int incx, ushort a, ushort* y, int incy)
        {
            NativeMethods.subc_inc_u16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ushort a, ushort[] y, int offy)
        {
            NativeMethods.mulc_ip_u16(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ushort a, ushort* y)
        {
            NativeMethods.mulc_ip_u16(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_u16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ushort a, ushort* y, int incy)
        {
            NativeMethods.mulc_inc_ip_u16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ushort[] x, int offx, ushort a, ushort[] y, int offy)
        {
            NativeMethods.mulc_u16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ushort* x, ushort a, ushort* y)
        {
            NativeMethods.mulc_u16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ushort[] x, int offx, int incx, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_u16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 16-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ushort* x, int incx, ushort a, ushort* y, int incy)
        {
            NativeMethods.mulc_inc_u16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ushort a, ushort[] y, int offy)
        {
            NativeMethods.divc_ip_u16(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ushort a, ushort* y)
        {
            NativeMethods.divc_ip_u16(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_u16(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ushort a, ushort* y, int incy)
        {
            NativeMethods.divc_inc_ip_u16(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ushort[] x, int offx, ushort a, ushort[] y, int offy)
        {
            NativeMethods.divc_u16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ushort* x, ushort a, ushort* y)
        {
            NativeMethods.divc_u16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ushort[] x, int offx, int incx, ushort a, ushort[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_u16(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 16-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ushort* x, int incx, ushort a, ushort* y, int incy)
        {
            NativeMethods.divc_inc_u16(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            NativeMethods.add_ip_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ushort* x, ushort* y)
        {
            NativeMethods.add_ip_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ushort[] x, int offx, int incx, ushort[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_u16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ushort* x, int incx, ushort* y, int incy)
        {
            NativeMethods.add_inc_ip_u16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.add_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ushort* a, ushort* b, ushort* y)
        {
            NativeMethods.add_u16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ushort[] a, int offa, int inca, ushort[] b, int offb, int incb, ushort[] y, int offy, int incy)
        {
            NativeMethods.add_inc_u16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ushort* a, int inca, ushort* b, int incb, ushort* y, int incy)
        {
            NativeMethods.add_inc_u16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            NativeMethods.sub_ip_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ushort* x, ushort* y)
        {
            NativeMethods.sub_ip_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ushort[] x, int offx, int incx, ushort[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_u16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ushort* x, int incx, ushort* y, int incy)
        {
            NativeMethods.sub_inc_ip_u16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.sub_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ushort* a, ushort* b, ushort* y)
        {
            NativeMethods.sub_u16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ushort[] a, int offa, int inca, ushort[] b, int offb, int incb, ushort[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_u16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ushort* a, int inca, ushort* b, int incb, ushort* y, int incy)
        {
            NativeMethods.sub_inc_u16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            NativeMethods.mul_ip_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ushort* x, ushort* y)
        {
            NativeMethods.mul_ip_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ushort[] x, int offx, int incx, ushort[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_u16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ushort* x, int incx, ushort* y, int incy)
        {
            NativeMethods.mul_inc_ip_u16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.mul_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ushort* a, ushort* b, ushort* y)
        {
            NativeMethods.mul_u16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ushort[] a, int offa, int inca, ushort[] b, int offb, int incb, ushort[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_u16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ushort* a, int inca, ushort* b, int incb, ushort* y, int incy)
        {
            NativeMethods.mul_inc_u16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            NativeMethods.div_ip_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ushort* x, ushort* y)
        {
            NativeMethods.div_ip_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ushort[] x, int offx, int incx, ushort[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_u16(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ushort* x, int incx, ushort* y, int incy)
        {
            NativeMethods.div_inc_ip_u16(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.div_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ushort* a, ushort* b, ushort* y)
        {
            NativeMethods.div_u16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ushort[] a, int offa, int inca, ushort[] b, int offb, int incb, ushort[] y, int offy, int incy)
        {
            NativeMethods.div_inc_u16(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 16-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ushort* a, int inca, ushort* b, int incb, ushort* y, int incy)
        {
            NativeMethods.div_inc_u16(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, ushort[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_u16(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, ushort* y)
        {
            NativeMethods.sqr_ip_u16(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, ushort* x, ushort* y)
        {
            NativeMethods.sqr_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, ushort[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_u16(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, ushort* x)
        {
            return NativeMethods.argmin_ip_u16(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Min(int length, ushort[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_u16(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ushort Min(int length, ushort* x)
        {
            return NativeMethods._min_ip_u16(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, ushort[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_u16(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, ushort* x)
        {
            return NativeMethods.argmax_ip_u16(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Max(int length, ushort[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_u16(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ushort Max(int length, ushort* x)
        {
            return NativeMethods._max_ip_u16(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, ushort a, ushort[] y, int offy)
        {
            NativeMethods.minc_ip_u16(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, ushort a, ushort* y)
        {
            NativeMethods.minc_ip_u16(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, ushort[] x, int offx, ushort a, ushort[] y, int offy)
        {
            NativeMethods.minc_u16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 16-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, ushort* x, ushort a, ushort* y)
        {
            NativeMethods.minc_u16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            NativeMethods.min_ip_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, ushort* x, ushort* y)
        {
            NativeMethods.min_ip_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.min_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, ushort* a, ushort* b, ushort* y)
        {
            NativeMethods.min_u16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, ushort a, ushort[] y, int offy)
        {
            NativeMethods.maxc_ip_u16(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, ushort a, ushort* y)
        {
            NativeMethods.maxc_ip_u16(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, ushort[] x, int offx, ushort a, ushort[] y, int offy)
        {
            NativeMethods.maxc_u16(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 16-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, ushort* x, ushort a, ushort* y)
        {
            NativeMethods.maxc_u16(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            NativeMethods.max_ip_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, ushort* x, ushort* y)
        {
            NativeMethods.max_ip_u16(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.max_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, ushort* a, ushort* b, ushort* y)
        {
            NativeMethods.max_u16(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Sum(int length, ushort[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_u16(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ushort Sum(int length, ushort* x)
        {
            return NativeMethods.sum_ip_u16(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort CumulativeSum(int length, ushort[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_u16(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ushort CumulativeSum(int length, ushort* x)
        {
            return NativeMethods.cumulative_sum_ip_u16(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort CumulativeSum(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_u16(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ushort CumulativeSum(int length, ushort* x, ushort* y)
        {
            return NativeMethods.cumulative_sum_u16(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 16-bit unsigned integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, ushort minValue, ushort maxValue, ushort[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 16-bit unsigned integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, ushort[] x, int offx, ushort[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 16-bit unsigned integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, ushort[] x, int offx, ushort alpha, ushort[] y, int offy)
        {
            NativeMethods.addproductc_u16(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 16-bit unsigned integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, ushort[] a, int offa, ushort[] b, int offb, ushort[] y, int offy)
        {
            NativeMethods.addproduct_u16(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, ushort[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_u16(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, ushort[] x, int offx, out ushort min, out ushort max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 16-bit unsigned integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, ushort threshold, ushort value, ushort[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_u16(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 16-bit unsigned integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, ushort threshold, ushort value, ushort[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_u16(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 16-bit unsigned integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, ushort thresholdLT, ushort valueLT, ushort thresholdGT, ushort valueGT, ushort[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_u16(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 32-bit signed integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int[] Create(int length, int value)
        {
            int[] a = new int[length];
            if (value != default(int))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 32-bit signed integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, int[] x, int offx, int[] y, int offy)
        {
            return NativeMethods.compare_s32(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 32-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, int[] x, int offx, int[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 32-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, int* x, int* y)
        {
            NativeMethods.copy_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 32-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, int[] x, int offx, int incx, int[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_s32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 32-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, int* x, int incx, int* y, int incy)
        {
            NativeMethods.copy_inc_s32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 32-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, int[] x, int offx, int[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 32-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, int* x, int* y)
        {
            NativeMethods.move_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, int a, int[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_s32(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, int a, int* y)
        {
            NativeMethods.set_s32(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, int a, int[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_s32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, int a, int* y, int incy)
        {
            NativeMethods.set_inc_s32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, int[] x, int offx, int[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, int* x, int* y)
        {
            NativeMethods.swap_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, int[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_ip_s32(length, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, int* y)
        {
            NativeMethods.abs_ip_s32(length, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, int[] x, int offx, int[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, int* x, int* y)
        {
            NativeMethods.abs_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, int a, int[] y, int offy)
        {
            NativeMethods.addc_ip_s32(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, int a, int* y)
        {
            NativeMethods.addc_ip_s32(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, int a, int[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_s32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, int a, int* y, int incy)
        {
            NativeMethods.addc_inc_ip_s32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, int[] x, int offx, int a, int[] y, int offy)
        {
            NativeMethods.addc_s32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, int* x, int a, int* y)
        {
            NativeMethods.addc_s32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, int[] x, int offx, int incx, int a, int[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_s32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, int* x, int incx, int a, int* y, int incy)
        {
            NativeMethods.addc_inc_s32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, int a, int[] y, int offy)
        {
            NativeMethods.subc_ip_s32(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, int a, int* y)
        {
            NativeMethods.subc_ip_s32(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, int a, int[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_s32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, int a, int* y, int incy)
        {
            NativeMethods.subc_inc_ip_s32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, int[] x, int offx, int a, int[] y, int offy)
        {
            NativeMethods.subc_s32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, int* x, int a, int* y)
        {
            NativeMethods.subc_s32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, int[] x, int offx, int incx, int a, int[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_s32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, int* x, int incx, int a, int* y, int incy)
        {
            NativeMethods.subc_inc_s32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, int a, int[] y, int offy)
        {
            NativeMethods.mulc_ip_s32(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, int a, int* y)
        {
            NativeMethods.mulc_ip_s32(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, int a, int[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_s32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, int a, int* y, int incy)
        {
            NativeMethods.mulc_inc_ip_s32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, int[] x, int offx, int a, int[] y, int offy)
        {
            NativeMethods.mulc_s32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, int* x, int a, int* y)
        {
            NativeMethods.mulc_s32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, int[] x, int offx, int incx, int a, int[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_s32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, int* x, int incx, int a, int* y, int incy)
        {
            NativeMethods.mulc_inc_s32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, int a, int[] y, int offy)
        {
            NativeMethods.divc_ip_s32(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, int a, int* y)
        {
            NativeMethods.divc_ip_s32(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, int a, int[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_s32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, int a, int* y, int incy)
        {
            NativeMethods.divc_inc_ip_s32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, int[] x, int offx, int a, int[] y, int offy)
        {
            NativeMethods.divc_s32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, int* x, int a, int* y)
        {
            NativeMethods.divc_s32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, int[] x, int offx, int incx, int a, int[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_s32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, int* x, int incx, int a, int* y, int incy)
        {
            NativeMethods.divc_inc_s32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.add_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, int* x, int* y)
        {
            NativeMethods.add_ip_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, int[] x, int offx, int incx, int[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_s32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, int* x, int incx, int* y, int incy)
        {
            NativeMethods.add_inc_ip_s32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.add_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, int* a, int* b, int* y)
        {
            NativeMethods.add_s32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, int[] a, int offa, int inca, int[] b, int offb, int incb, int[] y, int offy, int incy)
        {
            NativeMethods.add_inc_s32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, int* a, int inca, int* b, int incb, int* y, int incy)
        {
            NativeMethods.add_inc_s32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.sub_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, int* x, int* y)
        {
            NativeMethods.sub_ip_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, int[] x, int offx, int incx, int[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_s32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, int* x, int incx, int* y, int incy)
        {
            NativeMethods.sub_inc_ip_s32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.sub_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, int* a, int* b, int* y)
        {
            NativeMethods.sub_s32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, int[] a, int offa, int inca, int[] b, int offb, int incb, int[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_s32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, int* a, int inca, int* b, int incb, int* y, int incy)
        {
            NativeMethods.sub_inc_s32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.mul_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, int* x, int* y)
        {
            NativeMethods.mul_ip_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, int[] x, int offx, int incx, int[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_s32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, int* x, int incx, int* y, int incy)
        {
            NativeMethods.mul_inc_ip_s32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.mul_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, int* a, int* b, int* y)
        {
            NativeMethods.mul_s32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, int[] a, int offa, int inca, int[] b, int offb, int incb, int[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_s32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, int* a, int inca, int* b, int incb, int* y, int incy)
        {
            NativeMethods.mul_inc_s32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.div_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, int* x, int* y)
        {
            NativeMethods.div_ip_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, int[] x, int offx, int incx, int[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_s32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, int* x, int incx, int* y, int incy)
        {
            NativeMethods.div_inc_ip_s32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.div_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, int* a, int* b, int* y)
        {
            NativeMethods.div_s32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, int[] a, int offa, int inca, int[] b, int offb, int incb, int[] y, int offy, int incy)
        {
            NativeMethods.div_inc_s32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, int* a, int inca, int* b, int incb, int* y, int incy)
        {
            NativeMethods.div_inc_s32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, int[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_s32(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, int* y)
        {
            NativeMethods.sqr_ip_s32(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, int[] x, int offx, int[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, int* x, int* y)
        {
            NativeMethods.sqr_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, int[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_s32(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, int* x)
        {
            return NativeMethods.argmin_ip_s32(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Min(int length, int[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_s32(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int Min(int length, int* x)
        {
            return NativeMethods._min_ip_s32(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, int[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_s32(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, int* x)
        {
            return NativeMethods.argmax_ip_s32(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Max(int length, int[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_s32(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int Max(int length, int* x)
        {
            return NativeMethods._max_ip_s32(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, int a, int[] y, int offy)
        {
            NativeMethods.minc_ip_s32(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, int a, int* y)
        {
            NativeMethods.minc_ip_s32(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, int[] x, int offx, int a, int[] y, int offy)
        {
            NativeMethods.minc_s32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, int* x, int a, int* y)
        {
            NativeMethods.minc_s32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.min_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, int* x, int* y)
        {
            NativeMethods.min_ip_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.min_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, int* a, int* b, int* y)
        {
            NativeMethods.min_s32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, int a, int[] y, int offy)
        {
            NativeMethods.maxc_ip_s32(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, int a, int* y)
        {
            NativeMethods.maxc_ip_s32(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, int[] x, int offx, int a, int[] y, int offy)
        {
            NativeMethods.maxc_s32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, int* x, int a, int* y)
        {
            NativeMethods.maxc_s32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.max_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, int* x, int* y)
        {
            NativeMethods.max_ip_s32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.max_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, int* a, int* b, int* y)
        {
            NativeMethods.max_s32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Sum(int length, int[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_s32(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int Sum(int length, int* x)
        {
            return NativeMethods.sum_ip_s32(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CumulativeSum(int length, int[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_s32(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int CumulativeSum(int length, int* x)
        {
            return NativeMethods.cumulative_sum_ip_s32(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CumulativeSum(int length, int[] x, int offx, int[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int CumulativeSum(int length, int* x, int* y)
        {
            return NativeMethods.cumulative_sum_s32(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 32-bit signed integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, int minValue, int maxValue, int[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 32-bit signed integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, int[] x, int offx, int[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 32-bit signed integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, int[] x, int offx, int alpha, int[] y, int offy)
        {
            NativeMethods.addproductc_s32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 32-bit signed integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.addproduct_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, int[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_s32(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 32-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, int[] x, int offx, out int min, out int max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 32-bit signed integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, int threshold, int value, int[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_s32(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 32-bit signed integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, int threshold, int value, int[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_s32(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 32-bit signed integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, int thresholdLT, int valueLT, int thresholdGT, int valueGT, int[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_s32(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 32-bit unsigned integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint[] Create(int length, uint value)
        {
            uint[] a = new uint[length];
            if (value != default(uint))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 32-bit unsigned integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, uint[] x, int offx, uint[] y, int offy)
        {
            return NativeMethods.compare_u32(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 32-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, uint[] x, int offx, uint[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 32-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, uint* x, uint* y)
        {
            NativeMethods.copy_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 32-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, uint[] x, int offx, int incx, uint[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_u32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 32-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, uint* x, int incx, uint* y, int incy)
        {
            NativeMethods.copy_inc_u32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 32-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, uint[] x, int offx, uint[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 32-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, uint* x, uint* y)
        {
            NativeMethods.move_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, uint a, uint[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_u32(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, uint a, uint* y)
        {
            NativeMethods.set_u32(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, uint a, uint[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_u32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 32-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, uint a, uint* y, int incy)
        {
            NativeMethods.set_inc_u32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, uint[] x, int offx, uint[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, uint* x, uint* y)
        {
            NativeMethods.swap_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.addc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, uint a, uint* y)
        {
            NativeMethods.addc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_u32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, uint a, uint* y, int incy)
        {
            NativeMethods.addc_inc_ip_u32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.addc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.addc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, uint[] x, int offx, int incx, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_u32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, uint* x, int incx, uint a, uint* y, int incy)
        {
            NativeMethods.addc_inc_u32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.subc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, uint a, uint* y)
        {
            NativeMethods.subc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_u32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, uint a, uint* y, int incy)
        {
            NativeMethods.subc_inc_ip_u32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.subc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.subc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, uint[] x, int offx, int incx, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_u32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, uint* x, int incx, uint a, uint* y, int incy)
        {
            NativeMethods.subc_inc_u32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.mulc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, uint a, uint* y)
        {
            NativeMethods.mulc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_u32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, uint a, uint* y, int incy)
        {
            NativeMethods.mulc_inc_ip_u32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.mulc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.mulc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, uint[] x, int offx, int incx, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_u32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, uint* x, int incx, uint a, uint* y, int incy)
        {
            NativeMethods.mulc_inc_u32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.divc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, uint a, uint* y)
        {
            NativeMethods.divc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_u32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, uint a, uint* y, int incy)
        {
            NativeMethods.divc_inc_ip_u32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.divc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.divc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, uint[] x, int offx, int incx, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_u32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, uint* x, int incx, uint a, uint* y, int incy)
        {
            NativeMethods.divc_inc_u32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.add_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, uint* x, uint* y)
        {
            NativeMethods.add_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, uint[] x, int offx, int incx, uint[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_u32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, uint* x, int incx, uint* y, int incy)
        {
            NativeMethods.add_inc_ip_u32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.add_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.add_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, uint[] a, int offa, int inca, uint[] b, int offb, int incb, uint[] y, int offy, int incy)
        {
            NativeMethods.add_inc_u32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, uint* a, int inca, uint* b, int incb, uint* y, int incy)
        {
            NativeMethods.add_inc_u32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.sub_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, uint* x, uint* y)
        {
            NativeMethods.sub_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, uint[] x, int offx, int incx, uint[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_u32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, uint* x, int incx, uint* y, int incy)
        {
            NativeMethods.sub_inc_ip_u32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.sub_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.sub_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, uint[] a, int offa, int inca, uint[] b, int offb, int incb, uint[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_u32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, uint* a, int inca, uint* b, int incb, uint* y, int incy)
        {
            NativeMethods.sub_inc_u32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.mul_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, uint* x, uint* y)
        {
            NativeMethods.mul_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, uint[] x, int offx, int incx, uint[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_u32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, uint* x, int incx, uint* y, int incy)
        {
            NativeMethods.mul_inc_ip_u32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.mul_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.mul_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, uint[] a, int offa, int inca, uint[] b, int offb, int incb, uint[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_u32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, uint* a, int inca, uint* b, int incb, uint* y, int incy)
        {
            NativeMethods.mul_inc_u32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.div_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, uint* x, uint* y)
        {
            NativeMethods.div_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, uint[] x, int offx, int incx, uint[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_u32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, uint* x, int incx, uint* y, int incy)
        {
            NativeMethods.div_inc_ip_u32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.div_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.div_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, uint[] a, int offa, int inca, uint[] b, int offb, int incb, uint[] y, int offy, int incy)
        {
            NativeMethods.div_inc_u32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 32-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, uint* a, int inca, uint* b, int incb, uint* y, int incy)
        {
            NativeMethods.div_inc_u32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, uint[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_u32(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, uint* y)
        {
            NativeMethods.sqr_ip_u32(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, uint[] x, int offx, uint[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, uint* x, uint* y)
        {
            NativeMethods.sqr_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, uint[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_u32(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, uint* x)
        {
            return NativeMethods.argmin_ip_u32(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Min(int length, uint[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_u32(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint Min(int length, uint* x)
        {
            return NativeMethods._min_ip_u32(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, uint[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_u32(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, uint* x)
        {
            return NativeMethods.argmax_ip_u32(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Max(int length, uint[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_u32(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint Max(int length, uint* x)
        {
            return NativeMethods._max_ip_u32(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.minc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, uint a, uint* y)
        {
            NativeMethods.minc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.minc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.minc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.min_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, uint* x, uint* y)
        {
            NativeMethods.min_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.min_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.min_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.maxc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, uint a, uint* y)
        {
            NativeMethods.maxc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.maxc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.maxc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.max_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, uint* x, uint* y)
        {
            NativeMethods.max_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.max_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.max_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SwapBits(int length, int bitCount, uint[] y, int offy)
        {
            NativeMethods.swap_bits_ip_u32(length, bitCount, y, offy);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SwapBits(int length, int bitCount, uint* y)
        {
            NativeMethods.swap_bits_ip_u32(length, bitCount, y, 0);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SwapBits(int length, uint[] x, int offx, int bitCount, uint[] y, int offy)
        {
            NativeMethods.swap_bits_u32(length, x, offx, bitCount, y, offy);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SwapBits(int length, uint* x, int bitCount, uint* y)
        {
            NativeMethods.swap_bits_u32(length, x, 0, bitCount, y, 0);
        }

        /// <summary>
        /// Performs logical NOT on array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] == ~y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Not(int length, uint[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.not_ip_u32(length, y, offy);
        }

        /// <summary>
        /// Performs logical NOT on array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] == ~y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Not(int length, uint* y)
        {
            NativeMethods.not_ip_u32(length, y, 0);
        }

        /// <summary>
        /// Performs logical NOT on array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ~x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Not(int length, uint[] x, int offx, uint[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.not_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical NOT on array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ~x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Not(int length, uint* x, uint* y)
        {
            NativeMethods.not_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] |= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.orc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] |= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void OrC(int length, uint a, uint* y)
        {
            NativeMethods.orc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] | a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.orc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] | a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void OrC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.orc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y |= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.or_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y |= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, uint* x, uint* y)
        {
            NativeMethods.or_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.or_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.or_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of three arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, uint[] a, int offa, uint[] b, int offb, uint[] c, int offc, uint[] y, int offy)
        {
            NativeMethods.or3_u32(length, a, offa, b, offb, c, offc, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of three arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, uint* a, uint* b, uint* c, uint* y)
        {
            NativeMethods.or3_u32(length, a, 0, b, 0, c, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of four arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="offd">The starting element position in <paramref name="d"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c | d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, uint[] a, int offa, uint[] b, int offb, uint[] c, int offc, uint[] d, int offd, uint[] y, int offy)
        {
            NativeMethods.or4_u32(length, a, offa, b, offb, c, offc, d, offd, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of four arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c | d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, uint* a, uint* b, uint* c, uint* d, uint* y)
        {
            NativeMethods.or4_u32(length, a, 0, b, 0, c, 0, d, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.andc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, uint a, uint* y)
        {
            NativeMethods.andc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.andc_inc_ip_u32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, uint a, uint* y, int incy)
        {
            NativeMethods.andc_inc_ip_u32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.andc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.andc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, uint[] x, int offx, int incx, uint a, uint[] y, int offy, int incy)
        {
            NativeMethods.andc_inc_u32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 32-bit unsigned integers and a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, uint* x, int incx, uint a, uint* y, int incy)
        {
            NativeMethods.andc_inc_u32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.and_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, uint* x, uint* y)
        {
            NativeMethods.and_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.and_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.and_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of three arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, uint[] a, int offa, uint[] b, int offb, uint[] c, int offc, uint[] y, int offy)
        {
            NativeMethods.and3_u32(length, a, offa, b, offb, c, offc, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of three arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, uint* a, uint* b, uint* c, uint* y)
        {
            NativeMethods.and3_u32(length, a, 0, b, 0, c, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of four arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="offd">The starting element position in <paramref name="d"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c &amp; d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, uint[] a, int offa, uint[] b, int offb, uint[] c, int offc, uint[] d, int offd, uint[] y, int offy)
        {
            NativeMethods.and4_u32(length, a, offa, b, offb, c, offc, d, offd, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of four arrays of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c &amp; d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, uint* a, uint* b, uint* c, uint* d, uint* y)
        {
            NativeMethods.and4_u32(length, a, 0, b, 0, c, 0, d, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] ^= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XorC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.xorc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] ^= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XorC(int length, uint a, uint* y)
        {
            NativeMethods.xorc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] ^ a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XorC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.xorc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] ^ a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XorC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.xorc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y ^= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xor(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.xor_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y ^= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xor(int length, uint* x, uint* y)
        {
            NativeMethods.xor_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a ^ b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xor(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.xor_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a ^ b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xor(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.xor_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XandC(int length, uint a, uint[] y, int offy)
        {
            NativeMethods.xandc_ip_u32(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 32-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XandC(int length, uint a, uint* y)
        {
            NativeMethods.xandc_ip_u32(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XandC(int length, uint[] x, int offx, uint a, uint[] y, int offy)
        {
            NativeMethods.xandc_u32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 32-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XandC(int length, uint* x, uint a, uint* y)
        {
            NativeMethods.xandc_u32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= ~x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xand(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.xand_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= ~x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xand(int length, uint* x, uint* y)
        {
            NativeMethods.xand_ip_u32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; ~b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xand(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.xand_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; ~b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xand(int length, uint* a, uint* b, uint* y)
        {
            NativeMethods.xand_u32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the right (from MSB to LSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &gt;&gt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shr(int length, int shift, uint[] y, int offy)
        {
            NativeMethods.shr_ip_u32(length, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the right (from MSB to LSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &gt;&gt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shr(int length, int shift, uint* y)
        {
            NativeMethods.shr_ip_u32(length, shift, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the right (from MSB to LSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &gt;&gt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shr(int length, uint[] x, int offx, int shift, uint[] y, int offy)
        {
            NativeMethods.shr_u32(length, x, offx, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the right (from MSB to LSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &gt;&gt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shr(int length, uint* x, int shift, uint* y)
        {
            NativeMethods.shr_u32(length, x, 0, shift, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the left (from LSB to MSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &lt;&lt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shl(int length, int shift, uint[] y, int offy)
        {
            NativeMethods.shl_ip_u32(length, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the left (from LSB to MSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &lt;&lt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shl(int length, int shift, uint* y)
        {
            NativeMethods.shl_ip_u32(length, shift, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the left (from LSB to MSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &lt;&lt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shl(int length, uint[] x, int offx, int shift, uint[] y, int offy)
        {
            NativeMethods.shl_u32(length, x, offx, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 32-bit unsigned integers to the left (from LSB to MSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &lt;&lt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shl(int length, uint* x, int shift, uint* y)
        {
            NativeMethods.shl_u32(length, x, 0, shift, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Sum(int length, uint[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_u32(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint Sum(int length, uint* x)
        {
            return NativeMethods.sum_ip_u32(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint CumulativeSum(int length, uint[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_u32(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint CumulativeSum(int length, uint* x)
        {
            return NativeMethods.cumulative_sum_ip_u32(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint CumulativeSum(int length, uint[] x, int offx, uint[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint CumulativeSum(int length, uint* x, uint* y)
        {
            return NativeMethods.cumulative_sum_u32(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 32-bit unsigned integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, uint minValue, uint maxValue, uint[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 32-bit unsigned integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, uint[] x, int offx, uint[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 32-bit unsigned integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, uint[] x, int offx, uint alpha, uint[] y, int offy)
        {
            NativeMethods.addproductc_u32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 32-bit unsigned integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.addproduct_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, uint[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_u32(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, uint[] x, int offx, out uint min, out uint max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 32-bit unsigned integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, uint threshold, uint value, uint[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_u32(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 32-bit unsigned integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, uint threshold, uint value, uint[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_u32(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 32-bit unsigned integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, uint thresholdLT, uint valueLT, uint thresholdGT, uint valueGT, uint[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_u32(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 64-bit signed integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long[] Create(int length, long value)
        {
            long[] a = new long[length];
            if (value != default(long))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 64-bit signed integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, long[] x, int offx, long[] y, int offy)
        {
            return NativeMethods.compare_s64(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 64-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, long[] x, int offx, long[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 64-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, long* x, long* y)
        {
            NativeMethods.copy_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 64-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, long[] x, int offx, int incx, long[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_s64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 64-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, long* x, int incx, long* y, int incy)
        {
            NativeMethods.copy_inc_s64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 64-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, long[] x, int offx, long[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 64-bit signed integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, long* x, long* y)
        {
            NativeMethods.move_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, long a, long[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_s64(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit signed integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, long a, long* y)
        {
            NativeMethods.set_s64(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, long a, long[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_s64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit signed integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, long a, long* y, int incy)
        {
            NativeMethods.set_inc_s64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, long[] x, int offx, long[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, long* x, long* y)
        {
            NativeMethods.swap_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, long[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_ip_s64(length, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, long* y)
        {
            NativeMethods.abs_ip_s64(length, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, long[] x, int offx, long[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, long* x, long* y)
        {
            NativeMethods.abs_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, long a, long[] y, int offy)
        {
            NativeMethods.addc_ip_s64(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, long a, long* y)
        {
            NativeMethods.addc_ip_s64(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, long a, long[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_s64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, long a, long* y, int incy)
        {
            NativeMethods.addc_inc_ip_s64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, long[] x, int offx, long a, long[] y, int offy)
        {
            NativeMethods.addc_s64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, long* x, long a, long* y)
        {
            NativeMethods.addc_s64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, long[] x, int offx, int incx, long a, long[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_s64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, long* x, int incx, long a, long* y, int incy)
        {
            NativeMethods.addc_inc_s64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, long a, long[] y, int offy)
        {
            NativeMethods.subc_ip_s64(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, long a, long* y)
        {
            NativeMethods.subc_ip_s64(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, long a, long[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_s64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, long a, long* y, int incy)
        {
            NativeMethods.subc_inc_ip_s64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, long[] x, int offx, long a, long[] y, int offy)
        {
            NativeMethods.subc_s64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, long* x, long a, long* y)
        {
            NativeMethods.subc_s64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, long[] x, int offx, int incx, long a, long[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_s64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, long* x, int incx, long a, long* y, int incy)
        {
            NativeMethods.subc_inc_s64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, long a, long[] y, int offy)
        {
            NativeMethods.mulc_ip_s64(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, long a, long* y)
        {
            NativeMethods.mulc_ip_s64(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, long a, long[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_s64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, long a, long* y, int incy)
        {
            NativeMethods.mulc_inc_ip_s64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, long[] x, int offx, long a, long[] y, int offy)
        {
            NativeMethods.mulc_s64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, long* x, long a, long* y)
        {
            NativeMethods.mulc_s64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, long[] x, int offx, int incx, long a, long[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_s64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, long* x, int incx, long a, long* y, int incy)
        {
            NativeMethods.mulc_inc_s64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, long a, long[] y, int offy)
        {
            NativeMethods.divc_ip_s64(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, long a, long* y)
        {
            NativeMethods.divc_ip_s64(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, long a, long[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_s64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, long a, long* y, int incy)
        {
            NativeMethods.divc_inc_ip_s64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, long[] x, int offx, long a, long[] y, int offy)
        {
            NativeMethods.divc_s64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, long* x, long a, long* y)
        {
            NativeMethods.divc_s64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, long[] x, int offx, int incx, long a, long[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_s64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, long* x, int incx, long a, long* y, int incy)
        {
            NativeMethods.divc_inc_s64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.add_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, long* x, long* y)
        {
            NativeMethods.add_ip_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, long[] x, int offx, int incx, long[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_s64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, long* x, int incx, long* y, int incy)
        {
            NativeMethods.add_inc_ip_s64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.add_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, long* a, long* b, long* y)
        {
            NativeMethods.add_s64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, long[] a, int offa, int inca, long[] b, int offb, int incb, long[] y, int offy, int incy)
        {
            NativeMethods.add_inc_s64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, long* a, int inca, long* b, int incb, long* y, int incy)
        {
            NativeMethods.add_inc_s64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.sub_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, long* x, long* y)
        {
            NativeMethods.sub_ip_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, long[] x, int offx, int incx, long[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_s64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, long* x, int incx, long* y, int incy)
        {
            NativeMethods.sub_inc_ip_s64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.sub_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, long* a, long* b, long* y)
        {
            NativeMethods.sub_s64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, long[] a, int offa, int inca, long[] b, int offb, int incb, long[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_s64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, long* a, int inca, long* b, int incb, long* y, int incy)
        {
            NativeMethods.sub_inc_s64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.mul_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, long* x, long* y)
        {
            NativeMethods.mul_ip_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, long[] x, int offx, int incx, long[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_s64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, long* x, int incx, long* y, int incy)
        {
            NativeMethods.mul_inc_ip_s64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.mul_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, long* a, long* b, long* y)
        {
            NativeMethods.mul_s64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, long[] a, int offa, int inca, long[] b, int offb, int incb, long[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_s64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, long* a, int inca, long* b, int incb, long* y, int incy)
        {
            NativeMethods.mul_inc_s64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.div_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, long* x, long* y)
        {
            NativeMethods.div_ip_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, long[] x, int offx, int incx, long[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_s64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, long* x, int incx, long* y, int incy)
        {
            NativeMethods.div_inc_ip_s64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.div_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, long* a, long* b, long* y)
        {
            NativeMethods.div_s64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, long[] a, int offa, int inca, long[] b, int offb, int incb, long[] y, int offy, int incy)
        {
            NativeMethods.div_inc_s64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit signed integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, long* a, int inca, long* b, int incb, long* y, int incy)
        {
            NativeMethods.div_inc_s64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, long[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_s64(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, long* y)
        {
            NativeMethods.sqr_ip_s64(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, long[] x, int offx, long[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, long* x, long* y)
        {
            NativeMethods.sqr_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, long[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_s64(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, long* x)
        {
            return NativeMethods.argmin_ip_s64(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Min(int length, long[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_s64(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe long Min(int length, long* x)
        {
            return NativeMethods._min_ip_s64(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, long[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_s64(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, long* x)
        {
            return NativeMethods.argmax_ip_s64(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Max(int length, long[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_s64(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe long Max(int length, long* x)
        {
            return NativeMethods._max_ip_s64(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, long a, long[] y, int offy)
        {
            NativeMethods.minc_ip_s64(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, long a, long* y)
        {
            NativeMethods.minc_ip_s64(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, long[] x, int offx, long a, long[] y, int offy)
        {
            NativeMethods.minc_s64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, long* x, long a, long* y)
        {
            NativeMethods.minc_s64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.min_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, long* x, long* y)
        {
            NativeMethods.min_ip_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.min_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, long* a, long* b, long* y)
        {
            NativeMethods.min_s64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, long a, long[] y, int offy)
        {
            NativeMethods.maxc_ip_s64(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit signed integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, long a, long* y)
        {
            NativeMethods.maxc_ip_s64(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, long[] x, int offx, long a, long[] y, int offy)
        {
            NativeMethods.maxc_s64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit signed integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, long* x, long a, long* y)
        {
            NativeMethods.maxc_s64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.max_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, long* x, long* y)
        {
            NativeMethods.max_ip_s64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.max_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, long* a, long* b, long* y)
        {
            NativeMethods.max_s64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Sum(int length, long[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_s64(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe long Sum(int length, long* x)
        {
            return NativeMethods.sum_ip_s64(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long CumulativeSum(int length, long[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_s64(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe long CumulativeSum(int length, long* x)
        {
            return NativeMethods.cumulative_sum_ip_s64(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long CumulativeSum(int length, long[] x, int offx, long[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe long CumulativeSum(int length, long* x, long* y)
        {
            return NativeMethods.cumulative_sum_s64(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 64-bit signed integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, long minValue, long maxValue, long[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 64-bit signed integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, long[] x, int offx, long[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 64-bit signed integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, long[] x, int offx, long alpha, long[] y, int offy)
        {
            NativeMethods.addproductc_s64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 64-bit signed integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.addproduct_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, long[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_s64(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 64-bit signed integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, long[] x, int offx, out long min, out long max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 64-bit signed integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, long threshold, long value, long[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_s64(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 64-bit signed integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, long threshold, long value, long[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_s64(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 64-bit signed integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, long thresholdLT, long valueLT, long thresholdGT, long valueGT, long[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_s64(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of 64-bit unsigned integers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong[] Create(int length, ulong value)
        {
            ulong[] a = new ulong[length];
            if (value != default(ulong))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of 64-bit unsigned integers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            return NativeMethods.compare_u64(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of 64-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of 64-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, ulong* x, ulong* y)
        {
            NativeMethods.copy_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of 64-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, ulong[] x, int offx, int incx, ulong[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_u64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of 64-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, ulong* x, int incx, ulong* y, int incy)
        {
            NativeMethods.copy_inc_u64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of 64-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of 64-bit unsigned integers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, ulong* x, ulong* y)
        {
            NativeMethods.move_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, ulong a, ulong[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_u64(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit unsigned integers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, ulong a, ulong* y)
        {
            NativeMethods.set_u64(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, ulong a, ulong[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_u64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of 64-bit unsigned integers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, ulong a, ulong* y, int incy)
        {
            NativeMethods.set_inc_u64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, ulong* x, ulong* y)
        {
            NativeMethods.swap_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.addc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ulong a, ulong* y)
        {
            NativeMethods.addc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_u64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ulong a, ulong* y, int incy)
        {
            NativeMethods.addc_inc_ip_u64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.addc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.addc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ulong[] x, int offx, int incx, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_u64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, ulong* x, int incx, ulong a, ulong* y, int incy)
        {
            NativeMethods.addc_inc_u64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.subc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ulong a, ulong* y)
        {
            NativeMethods.subc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_u64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ulong a, ulong* y, int incy)
        {
            NativeMethods.subc_inc_ip_u64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.subc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.subc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ulong[] x, int offx, int incx, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_u64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, ulong* x, int incx, ulong a, ulong* y, int incy)
        {
            NativeMethods.subc_inc_u64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.mulc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ulong a, ulong* y)
        {
            NativeMethods.mulc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_u64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ulong a, ulong* y, int incy)
        {
            NativeMethods.mulc_inc_ip_u64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.mulc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.mulc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ulong[] x, int offx, int incx, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_u64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, ulong* x, int incx, ulong a, ulong* y, int incy)
        {
            NativeMethods.mulc_inc_u64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.divc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ulong a, ulong* y)
        {
            NativeMethods.divc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_u64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ulong a, ulong* y, int incy)
        {
            NativeMethods.divc_inc_ip_u64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.divc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.divc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ulong[] x, int offx, int incx, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_u64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, ulong* x, int incx, ulong a, ulong* y, int incy)
        {
            NativeMethods.divc_inc_u64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.add_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ulong* x, ulong* y)
        {
            NativeMethods.add_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ulong[] x, int offx, int incx, ulong[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_u64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ulong* x, int incx, ulong* y, int incy)
        {
            NativeMethods.add_inc_ip_u64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.add_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.add_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ulong[] a, int offa, int inca, ulong[] b, int offb, int incb, ulong[] y, int offy, int incy)
        {
            NativeMethods.add_inc_u64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, ulong* a, int inca, ulong* b, int incb, ulong* y, int incy)
        {
            NativeMethods.add_inc_u64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.sub_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ulong* x, ulong* y)
        {
            NativeMethods.sub_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ulong[] x, int offx, int incx, ulong[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_u64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ulong* x, int incx, ulong* y, int incy)
        {
            NativeMethods.sub_inc_ip_u64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.sub_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.sub_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ulong[] a, int offa, int inca, ulong[] b, int offb, int incb, ulong[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_u64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, ulong* a, int inca, ulong* b, int incb, ulong* y, int incy)
        {
            NativeMethods.sub_inc_u64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.mul_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ulong* x, ulong* y)
        {
            NativeMethods.mul_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ulong[] x, int offx, int incx, ulong[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_u64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ulong* x, int incx, ulong* y, int incy)
        {
            NativeMethods.mul_inc_ip_u64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.mul_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.mul_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ulong[] a, int offa, int inca, ulong[] b, int offb, int incb, ulong[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_u64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, ulong* a, int inca, ulong* b, int incb, ulong* y, int incy)
        {
            NativeMethods.mul_inc_u64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.div_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ulong* x, ulong* y)
        {
            NativeMethods.div_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ulong[] x, int offx, int incx, ulong[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_u64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ulong* x, int incx, ulong* y, int incy)
        {
            NativeMethods.div_inc_ip_u64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.div_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.div_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, ulong[] a, int offa, int inca, ulong[] b, int offb, int incb, ulong[] y, int offy, int incy)
        {
            NativeMethods.div_inc_u64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of 64-bit unsigned integers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, ulong* a, int inca, ulong* b, int incb, ulong* y, int incy)
        {
            NativeMethods.div_inc_u64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, ulong[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_u64(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, ulong* y)
        {
            NativeMethods.sqr_ip_u64(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, ulong* x, ulong* y)
        {
            NativeMethods.sqr_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, ulong[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_u64(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, ulong* x)
        {
            return NativeMethods.argmin_ip_u64(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Min(int length, ulong[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_u64(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ulong Min(int length, ulong* x)
        {
            return NativeMethods._min_ip_u64(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, ulong[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_u64(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, ulong* x)
        {
            return NativeMethods.argmax_ip_u64(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Max(int length, ulong[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_u64(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ulong Max(int length, ulong* x)
        {
            return NativeMethods._max_ip_u64(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.minc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, ulong a, ulong* y)
        {
            NativeMethods.minc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.minc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.minc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.min_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, ulong* x, ulong* y)
        {
            NativeMethods.min_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.min_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.min_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.maxc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, ulong a, ulong* y)
        {
            NativeMethods.maxc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.maxc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.maxc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.max_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, ulong* x, ulong* y)
        {
            NativeMethods.max_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.max_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.max_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SwapBits(int length, int bitCount, ulong[] y, int offy)
        {
            NativeMethods.swap_bits_ip_u64(length, bitCount, y, offy);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SwapBits(int length, int bitCount, ulong* y)
        {
            NativeMethods.swap_bits_ip_u64(length, bitCount, y, 0);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SwapBits(int length, ulong[] x, int offx, int bitCount, ulong[] y, int offy)
        {
            NativeMethods.swap_bits_u64(length, x, offx, bitCount, y, offy);
        }

        /// <summary>
        /// Reverses the order of groups of bits in each byte an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="bitCount">The number of bits in a group (1, 2, or 4).</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>{TBD}</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SwapBits(int length, ulong* x, int bitCount, ulong* y)
        {
            NativeMethods.swap_bits_u64(length, x, 0, bitCount, y, 0);
        }

        /// <summary>
        /// Performs logical NOT on array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] == ~y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Not(int length, ulong[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.not_ip_u64(length, y, offy);
        }

        /// <summary>
        /// Performs logical NOT on array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] == ~y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Not(int length, ulong* y)
        {
            NativeMethods.not_ip_u64(length, y, 0);
        }

        /// <summary>
        /// Performs logical NOT on array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ~x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Not(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.not_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical NOT on array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ~x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Not(int length, ulong* x, ulong* y)
        {
            NativeMethods.not_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] |= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.orc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] |= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void OrC(int length, ulong a, ulong* y)
        {
            NativeMethods.orc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] | a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.orc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] | a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void OrC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.orc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y |= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.or_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y |= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, ulong* x, ulong* y)
        {
            NativeMethods.or_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.or_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.or_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of three arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] c, int offc, ulong[] y, int offy)
        {
            NativeMethods.or3_u64(length, a, offa, b, offb, c, offc, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of three arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, ulong* a, ulong* b, ulong* c, ulong* y)
        {
            NativeMethods.or3_u64(length, a, 0, b, 0, c, 0, y, 0);
        }

        /// <summary>
        /// Performs logical OR operation between elements of four arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="offd">The starting element position in <paramref name="d"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c | d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] c, int offc, ulong[] d, int offd, ulong[] y, int offy)
        {
            NativeMethods.or4_u64(length, a, offa, b, offb, c, offc, d, offd, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation between elements of four arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a | b | c | d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Or(int length, ulong* a, ulong* b, ulong* c, ulong* d, ulong* y)
        {
            NativeMethods.or4_u64(length, a, 0, b, 0, c, 0, d, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.andc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, ulong a, ulong* y)
        {
            NativeMethods.andc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.andc_inc_ip_u64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, ulong a, ulong* y, int incy)
        {
            NativeMethods.andc_inc_ip_u64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.andc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.andc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AndC(int length, ulong[] x, int offx, int incx, ulong a, ulong[] y, int offy, int incy)
        {
            NativeMethods.andc_inc_u64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of an array of 64-bit unsigned integers and a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AndC(int length, ulong* x, int incx, ulong a, ulong* y, int incy)
        {
            NativeMethods.andc_inc_u64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.and_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, ulong* x, ulong* y)
        {
            NativeMethods.and_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.and_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.and_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of three arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] c, int offc, ulong[] y, int offy)
        {
            NativeMethods.and3_u64(length, a, offa, b, offb, c, offc, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of three arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, ulong* a, ulong* b, ulong* c, ulong* y)
        {
            NativeMethods.and3_u64(length, a, 0, b, 0, c, 0, y, 0);
        }

        /// <summary>
        /// Performs logical AND operation between elements of four arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="offd">The starting element position in <paramref name="d"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c &amp; d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] c, int offc, ulong[] d, int offd, ulong[] y, int offy)
        {
            NativeMethods.and4_u64(length, a, offa, b, offb, c, offc, d, offd, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation between elements of four arrays of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; b &amp; c &amp; d</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void And(int length, ulong* a, ulong* b, ulong* c, ulong* d, ulong* y)
        {
            NativeMethods.and4_u64(length, a, 0, b, 0, c, 0, d, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] ^= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XorC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.xorc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] ^= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XorC(int length, ulong a, ulong* y)
        {
            NativeMethods.xorc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] ^ a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XorC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.xorc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] ^ a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XorC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.xorc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y ^= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xor(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.xor_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y ^= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xor(int length, ulong* x, ulong* y)
        {
            NativeMethods.xor_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a ^ b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xor(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.xor_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a ^ b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xor(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.xor_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XandC(int length, ulong a, ulong[] y, int offy)
        {
            NativeMethods.xandc_ip_u64(length, a, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 64-bit unsigned integers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] &amp;= ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XandC(int length, ulong a, ulong* y)
        {
            NativeMethods.xandc_ip_u64(length, a, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void XandC(int length, ulong[] x, int offx, ulong a, ulong[] y, int offy)
        {
            NativeMethods.xandc_u64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of an array of 64-bit unsigned integers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] &amp; ~a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void XandC(int length, ulong* x, ulong a, ulong* y)
        {
            NativeMethods.xandc_u64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= ~x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xand(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.xand_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &amp;= ~x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xand(int length, ulong* x, ulong* y)
        {
            NativeMethods.xand_ip_u64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; ~b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xand(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.xand_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation between elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a &amp; ~b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Xand(int length, ulong* a, ulong* b, ulong* y)
        {
            NativeMethods.xand_u64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the right (from MSB to LSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &gt;&gt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shr(int length, int shift, ulong[] y, int offy)
        {
            NativeMethods.shr_ip_u64(length, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the right (from MSB to LSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &gt;&gt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shr(int length, int shift, ulong* y)
        {
            NativeMethods.shr_ip_u64(length, shift, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the right (from MSB to LSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &gt;&gt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shr(int length, ulong[] x, int offx, int shift, ulong[] y, int offy)
        {
            NativeMethods.shr_u64(length, x, offx, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the right (from MSB to LSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &gt;&gt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shr(int length, ulong* x, int shift, ulong* y)
        {
            NativeMethods.shr_u64(length, x, 0, shift, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the left (from LSB to MSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &lt;&lt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shl(int length, int shift, ulong[] y, int offy)
        {
            NativeMethods.shl_ip_u64(length, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the left (from LSB to MSB) in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y &lt;&lt;= shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shl(int length, int shift, ulong* y)
        {
            NativeMethods.shl_ip_u64(length, shift, y, 0);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the left (from LSB to MSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &lt;&lt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Shl(int length, ulong[] x, int offx, int shift, ulong[] y, int offy)
        {
            NativeMethods.shl_u64(length, x, offx, shift, y, offy);
        }

        /// <summary>
        /// Shifts bits in the array of 64-bit unsigned integers to the left (from LSB to MSB) not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="shift">The number of bits by which the method shifts each element.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = x &lt;&lt; shift</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Shl(int length, ulong* x, int shift, ulong* y)
        {
            NativeMethods.shl_u64(length, x, 0, shift, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Sum(int length, ulong[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_u64(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ulong Sum(int length, ulong* x)
        {
            return NativeMethods.sum_ip_u64(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong CumulativeSum(int length, ulong[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_u64(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ulong CumulativeSum(int length, ulong* x)
        {
            return NativeMethods.cumulative_sum_ip_u64(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong CumulativeSum(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ulong CumulativeSum(int length, ulong* x, ulong* y)
        {
            return NativeMethods.cumulative_sum_u64(length, x, 0, y, 0);
        }


        /// <summary>
        /// Clips elements of an array of 64-bit unsigned integers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, ulong minValue, ulong maxValue, ulong[] x, int offx)
        {
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
        }

        /// <summary>
        /// Copies a range of values from a array of 64-bit unsigned integers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, ulong[] x, int offx, ulong[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of 64-bit unsigned integers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, ulong[] x, int offx, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.addproductc_u64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of 64-bit unsigned integers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.addproduct_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, ulong[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_u64(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, ulong[] x, int offx, out ulong min, out ulong max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 64-bit unsigned integers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, ulong threshold, ulong value, ulong[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_u64(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 64-bit unsigned integers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, ulong threshold, ulong value, ulong[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_u64(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of 64-bit unsigned integers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, ulong thresholdLT, ulong valueLT, ulong thresholdGT, ulong valueGT, ulong[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_u64(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Creates an array of single-precision floating point numbers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float[] Create(int length, float value)
        {
            float[] a = new float[length];
            if (value != default(float))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of single-precision floating point numbers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.compare_f32(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of single-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of single-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, float* x, float* y)
        {
            NativeMethods.copy_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of single-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, float[] x, int offx, int incx, float[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_f32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of single-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, float* x, int incx, float* y, int incy)
        {
            NativeMethods.copy_inc_f32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of single-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of single-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, float* x, float* y)
        {
            NativeMethods.move_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of single-precision floating point numbers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, float a, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_f32(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of single-precision floating point numbers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, float a, float* y)
        {
            NativeMethods.set_f32(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of single-precision floating point numbers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, float a, float[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_f32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of single-precision floating point numbers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, float a, float* y, int incy)
        {
            NativeMethods.set_inc_f32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, float* x, float* y)
        {
            NativeMethods.swap_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, float* y)
        {
            NativeMethods.abs_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, float* x, float* y)
        {
            NativeMethods.abs_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Abs(int, float[], int, float[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Abs(int, float[], int, float[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Abs(int, float[], int, float[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="Abs(int, float[], int, float[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AbsGradient(int length, float[] x, float[] dx, int offx, bool cleardx, float[] y, float[] dy, int offdy)
        {
            NativeMethods.abs_gradient_f32(length, x, dx, offx, cleardx, y, dy, offdy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, float a, float[] y, int offy)
        {
            NativeMethods.addc_ip_f32(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, float a, float* y)
        {
            NativeMethods.addc_ip_f32(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, float a, float[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_f32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, float a, float* y, int incy)
        {
            NativeMethods.addc_inc_ip_f32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, float[] x, int offx, float a, float[] y, int offy)
        {
            NativeMethods.addc_f32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, float* x, float a, float* y)
        {
            NativeMethods.addc_f32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, float[] x, int offx, int incx, float a, float[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_f32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, float* x, int incx, float a, float* y, int incy)
        {
            NativeMethods.addc_inc_f32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, float a, float[] y, int offy)
        {
            NativeMethods.subc_ip_f32(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, float a, float* y)
        {
            NativeMethods.subc_ip_f32(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, float a, float[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_f32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, float a, float* y, int incy)
        {
            NativeMethods.subc_inc_ip_f32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, float[] x, int offx, float a, float[] y, int offy)
        {
            NativeMethods.subc_f32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, float* x, float a, float* y)
        {
            NativeMethods.subc_f32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, float[] x, int offx, int incx, float a, float[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_f32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, float* x, int incx, float a, float* y, int incy)
        {
            NativeMethods.subc_inc_f32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, float a, float[] y, int offy)
        {
            NativeMethods.mulc_ip_f32(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, float a, float* y)
        {
            NativeMethods.mulc_ip_f32(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, float a, float[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_f32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, float a, float* y, int incy)
        {
            NativeMethods.mulc_inc_ip_f32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, float[] x, int offx, float a, float[] y, int offy)
        {
            NativeMethods.mulc_f32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, float* x, float a, float* y)
        {
            NativeMethods.mulc_f32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, float[] x, int offx, int incx, float a, float[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_f32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, float* x, int incx, float a, float* y, int incy)
        {
            NativeMethods.mulc_inc_f32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, float a, float[] y, int offy)
        {
            NativeMethods.divc_ip_f32(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, float a, float* y)
        {
            NativeMethods.divc_ip_f32(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, float a, float[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_f32(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, float a, float* y, int incy)
        {
            NativeMethods.divc_inc_ip_f32(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, float[] x, int offx, float a, float[] y, int offy)
        {
            NativeMethods.divc_f32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, float* x, float a, float* y)
        {
            NativeMethods.divc_f32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, float[] x, int offx, int incx, float a, float[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_f32(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, float* x, int incx, float a, float* y, int incy)
        {
            NativeMethods.divc_inc_f32(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.add_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, float* x, float* y)
        {
            NativeMethods.add_ip_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, float[] x, int offx, int incx, float[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_f32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, float* x, int incx, float* y, int incy)
        {
            NativeMethods.add_inc_ip_f32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.add_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, float* a, float* b, float* y)
        {
            NativeMethods.add_f32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, float[] a, int offa, int inca, float[] b, int offb, int incb, float[] y, int offy, int incy)
        {
            NativeMethods.add_inc_f32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, float* a, int inca, float* b, int incb, float* y, int incy)
        {
            NativeMethods.add_inc_f32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.sub_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, float* x, float* y)
        {
            NativeMethods.sub_ip_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, float[] x, int offx, int incx, float[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_f32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, float* x, int incx, float* y, int incy)
        {
            NativeMethods.sub_inc_ip_f32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.sub_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, float* a, float* b, float* y)
        {
            NativeMethods.sub_f32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, float[] a, int offa, int inca, float[] b, int offb, int incb, float[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_f32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, float* a, int inca, float* b, int incb, float* y, int incy)
        {
            NativeMethods.sub_inc_f32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.mul_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, float* x, float* y)
        {
            NativeMethods.mul_ip_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, float[] x, int offx, int incx, float[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_f32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, float* x, int incx, float* y, int incy)
        {
            NativeMethods.mul_inc_ip_f32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.mul_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, float* a, float* b, float* y)
        {
            NativeMethods.mul_f32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, float[] a, int offa, int inca, float[] b, int offb, int incb, float[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_f32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, float* a, int inca, float* b, int incb, float* y, int incy)
        {
            NativeMethods.mul_inc_f32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.div_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, float* x, float* y)
        {
            NativeMethods.div_ip_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, float[] x, int offx, int incx, float[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_f32(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, float* x, int incx, float* y, int incy)
        {
            NativeMethods.div_inc_ip_f32(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.div_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, float* a, float* b, float* y)
        {
            NativeMethods.div_f32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, float[] a, int offa, int inca, float[] b, int offb, int incb, float[] y, int offy, int incy)
        {
            NativeMethods.div_inc_f32(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of single-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, float* a, int inca, float* b, int incb, float* y, int incy)
        {
            NativeMethods.div_inc_f32(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, float* y)
        {
            NativeMethods.sqr_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, float* x, float* y)
        {
            NativeMethods.sqr_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a square root of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqrt_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sqrt(int length, float* y)
        {
            NativeMethods.sqrt_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Computes a square root of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqrt_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sqrt(int length, float* x, float* y)
        {
            NativeMethods.sqrt_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = ln(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.log_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = ln(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Log(int length, float* y)
        {
            NativeMethods.log_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ln(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.log_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ln(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Log(int length, float* x, float* y)
        {
            NativeMethods.log_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = exp(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.exp_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = exp(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Exp(int length, float* y)
        {
            NativeMethods.exp_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = exp(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.exp_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = exp(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Exp(int length, float* x, float* y)
        {
            NativeMethods.exp_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sin(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sin_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sin(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sin(int length, float* y)
        {
            NativeMethods.sin_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sin(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sin_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sin(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sin(int length, float* x, float* y)
        {
            NativeMethods.sin_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Sin(int, float[], int, float[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Sin(int, float[], int, float[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Sin(int, float[], int, float[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="Sin(int, float[], int, float[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SinGradient(int length, float[] x, float[] dx, int offx, bool cleardx, float[] y, float[] dy, int offdy)
        {
            NativeMethods.sin_gradient_f32(length, x, dx, offx, cleardx, y, dy, offdy);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = cos(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, float[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.cos_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = cos(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Cos(int length, float* y)
        {
            NativeMethods.cos_ip_f32(length, y, 0);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = cos(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.cos_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = cos(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Cos(int length, float* x, float* y)
        {
            NativeMethods.cos_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Cos(int, float[], int, float[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Cos(int, float[], int, float[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Cos(int, float[], int, float[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="Cos(int, float[], int, float[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CosGradient(int length, float[] x, float[] dx, int offx, bool cleardx, float[] y, float[] dy, int offdy)
        {
            NativeMethods.cos_gradient_f32(length, x, dx, offx, cleardx, y, dy, offdy);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, float* x)
        {
            return NativeMethods.argmin_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Min(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe float Min(int length, float* x)
        {
            return NativeMethods._min_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, float* x)
        {
            return NativeMethods.argmax_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Max(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe float Max(int length, float* x)
        {
            return NativeMethods._max_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of single-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, float a, float[] y, int offy)
        {
            NativeMethods.minc_ip_f32(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of single-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, float a, float* y)
        {
            NativeMethods.minc_ip_f32(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of single-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, float[] x, int offx, float a, float[] y, int offy)
        {
            NativeMethods.minc_f32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of single-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, float* x, float a, float* y)
        {
            NativeMethods.minc_f32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.min_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, float* x, float* y)
        {
            NativeMethods.min_ip_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.min_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, float* a, float* b, float* y)
        {
            NativeMethods.min_f32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of single-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, float a, float[] y, int offy)
        {
            NativeMethods.maxc_ip_f32(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of single-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, float a, float* y)
        {
            NativeMethods.maxc_ip_f32(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of single-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, float[] x, int offx, float a, float[] y, int offy)
        {
            NativeMethods.maxc_f32(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of single-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, float* x, float a, float* y)
        {
            NativeMethods.maxc_f32(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.max_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, float* x, float* y)
        {
            NativeMethods.max_ip_f32(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.max_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, float* a, float* b, float* y)
        {
            NativeMethods.max_f32(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sum(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe float Sum(int length, float* x)
        {
            return NativeMethods.sum_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float CumulativeSum(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe float CumulativeSum(int length, float* x)
        {
            return NativeMethods.cumulative_sum_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float CumulativeSum(int length, float[] x, int offx, float[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe float CumulativeSum(int length, float* x, float* y)
        {
            return NativeMethods.cumulative_sum_f32(length, x, 0, y, 0);
        }


        /// <summary>
        /// Computes the variance of all elements in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The variance of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>variance(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Variance(int length, float[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.variance_ip_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the variance of all elements in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The variance of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>variance(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe float Variance(int length, float* x)
        {
            return NativeMethods.variance_ip_f32(length, x, 0);
        }


        /// <summary>
        /// Clips elements of an array of single-precision floating point numbers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, float minValue, float maxValue, float[] x, int offx)
        {
            if (!float.IsNaN(minValue))
            {
                Vectors.MaxC(length, minValue, x, offx);
            }

            if (!float.IsNaN(maxValue))
            {
                Vectors.MinC(length, maxValue, x, offx);
            }
        }

        /// <summary>
        /// Copies a range of values from a array of single-precision floating point numbers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, float[] x, int offx, float[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of single-precision floating point numbers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, float[] x, int offx, float alpha, float[] y, int offy)
        {
            NativeMethods.addproductc_f32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of single-precision floating point numbers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.addproduct_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, float[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_f32(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, float[] x, int offx, out float min, out float max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of single-precision floating point numbers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, float threshold, float value, float[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_f32(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of single-precision floating point numbers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, float threshold, float value, float[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_f32(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of single-precision floating point numbers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, float thresholdLT, float valueLT, float thresholdGT, float valueGT, float[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_f32(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Computes the L1-Norm (sum of magnitudes) of the array of single-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L1-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float L1Norm(int length, float[] x, int offx)
        {
            return NativeMethods.nrm1_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the L2-Norm (Euclidian norm) of the array of single-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L2-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float L2Norm(int length, float[] x, int offx)
        {
            return NativeMethods.nrm2_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the Manhattan distance between elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Manhattan distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum(abs(x[i] - y[i])).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ManhattanDistance(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.manhattan_distance_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum((x[i] - y[i])^2).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float EuclideanDistanceSquared(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.euclidean_distance_squared_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the Euclidean distance between elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sqrt(sum((x[i] - y[i])^2)).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float EuclideanDistance(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.euclidean_distance_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Creates an array of double-precision floating point numbers with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double[] Create(int length, double value)
        {
            double[] a = new double[length];
            if (value != default(double))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of double-precision floating point numbers contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.compare_f64(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of double-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.copy_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of double-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, double* x, double* y)
        {
            NativeMethods.copy_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Copies a range of double-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, double[] x, int offx, int incx, double[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.copy_inc_f64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Copies a range of double-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Copy(int length, double* x, int incx, double* y, int incy)
        {
            NativeMethods.copy_inc_f64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Copies an overlapping range of double-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies an overlapping range of double-precision floating point numbers from an array starting at the specified source index to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Move(int length, double* x, double* y)
        {
            NativeMethods.move_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of double-precision floating point numbers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, double a, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.set_f64(length, a, y, offy);
        }

        /// <summary>
        /// Sets all elements in the array of double-precision floating point numbers starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, double a, double* y)
        {
            NativeMethods.set_f64(length, a, y, 0);
        }

        /// <summary>
        /// Sets all elements in the array of double-precision floating point numbers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, double a, double[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.set_inc_f64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Sets all elements in the array of double-precision floating point numbers starting at the specified source index to the specified value with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = a</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Set(int length, double a, double* y, int incy)
        {
            NativeMethods.set_inc_f64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Swaps elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.swap_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = x, x = y</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Swap(int length, double* x, double* y)
        {
            NativeMethods.swap_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, double* y)
        {
            NativeMethods.abs_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.abs_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an absolute value of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y = abs(x)</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Abs(int length, double* x, double* y)
        {
            NativeMethods.abs_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Abs(int, double[], int, double[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Abs(int, double[], int, double[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Abs(int, double[], int, double[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="Abs(int, double[], int, double[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AbsGradient(int length, double[] x, double[] dx, int offx, bool cleardx, double[] y, double[] dy, int offdy)
        {
            NativeMethods.abs_gradient_f64(length, x, dx, offx, cleardx, y, dy, offdy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, double a, double[] y, int offy)
        {
            NativeMethods.addc_ip_f64(length, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, double a, double* y)
        {
            NativeMethods.addc_ip_f64(length, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, double a, double[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_ip_f64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, double a, double* y, int incy)
        {
            NativeMethods.addc_inc_ip_f64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, double[] x, int offx, double a, double[] y, int offy)
        {
            NativeMethods.addc_f64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, double* x, double a, double* y)
        {
            NativeMethods.addc_f64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, double[] x, int offx, int incx, double a, double[] y, int offy, int incy)
        {
            NativeMethods.addc_inc_f64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void AddC(int length, double* x, int incx, double a, double* y, int incy)
        {
            NativeMethods.addc_inc_f64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, double a, double[] y, int offy)
        {
            NativeMethods.subc_ip_f64(length, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, double a, double* y)
        {
            NativeMethods.subc_ip_f64(length, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, double a, double[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_ip_f64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, double a, double* y, int incy)
        {
            NativeMethods.subc_inc_ip_f64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, double[] x, int offx, double a, double[] y, int offy)
        {
            NativeMethods.subc_f64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, double* x, double a, double* y)
        {
            NativeMethods.subc_f64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, double[] x, int offx, int incx, double a, double[] y, int offy, int incy)
        {
            NativeMethods.subc_inc_f64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void SubC(int length, double* x, int incx, double a, double* y, int incy)
        {
            NativeMethods.subc_inc_f64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, double a, double[] y, int offy)
        {
            NativeMethods.mulc_ip_f64(length, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, double a, double* y)
        {
            NativeMethods.mulc_ip_f64(length, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, double a, double[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_ip_f64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, double a, double* y, int incy)
        {
            NativeMethods.mulc_inc_ip_f64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, double[] x, int offx, double a, double[] y, int offy)
        {
            NativeMethods.mulc_f64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, double* x, double a, double* y)
        {
            NativeMethods.mulc_f64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, double[] x, int offx, int incx, double a, double[] y, int offy, int incy)
        {
            NativeMethods.mulc_inc_f64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MulC(int length, double* x, int incx, double a, double* y, int incy)
        {
            NativeMethods.mulc_inc_f64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, double a, double[] y, int offy)
        {
            NativeMethods.divc_ip_f64(length, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, double a, double* y)
        {
            NativeMethods.divc_ip_f64(length, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, double a, double[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_ip_f64(length, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, double a, double* y, int incy)
        {
            NativeMethods.divc_inc_ip_f64(length, a, y, 0, incy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, double[] x, int offx, double a, double[] y, int offy)
        {
            NativeMethods.divc_f64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, double* x, double a, double* y)
        {
            NativeMethods.divc_f64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, double[] x, int offx, int incx, double a, double[] y, int offy, int incy)
        {
            NativeMethods.divc_inc_f64(length, x, offx, incx, a, y, offy, incy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / a</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void DivC(int length, double* x, int incx, double a, double* y, int incy)
        {
            NativeMethods.divc_inc_f64(length, x, 0, incx, a, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.add_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, double* x, double* y)
        {
            NativeMethods.add_ip_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, double[] x, int offx, int incx, double[] y, int offy, int incy)
        {
            NativeMethods.add_inc_ip_f64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, double* x, int incx, double* y, int incy)
        {
            NativeMethods.add_inc_ip_f64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.add_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, double* a, double* b, double* y)
        {
            NativeMethods.add_f64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, double[] a, int offa, int inca, double[] b, int offb, int incb, double[] y, int offy, int incy)
        {
            NativeMethods.add_inc_f64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Add(int length, double* a, int inca, double* b, int incb, double* y, int incy)
        {
            NativeMethods.add_inc_f64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.sub_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, double* x, double* y)
        {
            NativeMethods.sub_ip_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, double[] x, int offx, int incx, double[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_ip_f64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, double* x, int incx, double* y, int incy)
        {
            NativeMethods.sub_inc_ip_f64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.sub_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, double* a, double* b, double* y)
        {
            NativeMethods.sub_f64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, double[] a, int offa, int inca, double[] b, int offb, int incb, double[] y, int offy, int incy)
        {
            NativeMethods.sub_inc_f64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sub(int length, double* a, int inca, double* b, int incb, double* y, int incy)
        {
            NativeMethods.sub_inc_f64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.mul_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, double* x, double* y)
        {
            NativeMethods.mul_ip_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, double[] x, int offx, int incx, double[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_ip_f64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, double* x, int incx, double* y, int incy)
        {
            NativeMethods.mul_inc_ip_f64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.mul_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, double* a, double* b, double* y)
        {
            NativeMethods.mul_f64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, double[] a, int offa, int inca, double[] b, int offb, int incb, double[] y, int offy, int incy)
        {
            NativeMethods.mul_inc_f64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Mul(int length, double* a, int inca, double* b, int incb, double* y, int incy)
        {
            NativeMethods.mul_inc_f64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.div_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, double* x, double* y)
        {
            NativeMethods.div_ip_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, double[] x, int offx, int incx, double[] y, int offy, int incy)
        {
            NativeMethods.div_inc_ip_f64(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers with increment in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y /= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, double* x, int incx, double* y, int incy)
        {
            NativeMethods.div_inc_ip_f64(length, x, 0, incx, y, 0, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.div_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, double* a, double* b, double* y)
        {
            NativeMethods.div_f64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Div(int length, double[] a, int offa, int inca, double[] b, int offb, int incb, double[] y, int offy, int incy)
        {
            NativeMethods.div_inc_f64(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// Divides the elements of two arrays of double-precision floating point numbers with increment not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a / b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Div(int length, double* a, int inca, double* b, int incb, double* y, int incy)
        {
            NativeMethods.div_inc_f64(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }

        /// <summary>
        /// Squares elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, double* y)
        {
            NativeMethods.sqr_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Squares elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqr_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Square(int length, double* x, double* y)
        {
            NativeMethods.sqr_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a square root of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqrt_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sqrt(int length, double* y)
        {
            NativeMethods.sqrt_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Computes a square root of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sqrt_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sqrt(int length, double* x, double* y)
        {
            NativeMethods.sqrt_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = ln(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.log_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = ln(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Log(int length, double* y)
        {
            NativeMethods.log_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ln(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.log_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = ln(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Log(int length, double* x, double* y)
        {
            NativeMethods.log_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = exp(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.exp_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = exp(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Exp(int length, double* y)
        {
            NativeMethods.exp_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = exp(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.exp_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an exponential logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = exp(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Exp(int length, double* x, double* y)
        {
            NativeMethods.exp_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sin(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sin_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sin(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sin(int length, double* y)
        {
            NativeMethods.sin_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sin(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.sin_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a sine logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = sin(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Sin(int length, double* x, double* y)
        {
            NativeMethods.sin_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Sin(int, double[], int, double[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Sin(int, double[], int, double[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Sin(int, double[], int, double[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="Sin(int, double[], int, double[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SinGradient(int length, double[] x, double[] dx, int offx, bool cleardx, double[] y, double[] dy, int offdy)
        {
            NativeMethods.sin_gradient_f64(length, x, dx, offx, cleardx, y, dy, offdy);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = cos(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, double[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.cos_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = cos(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Cos(int length, double* y)
        {
            NativeMethods.cos_ip_f64(length, y, 0);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = cos(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.cos_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a cosine logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c>y[i] = cos(x[i])</c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Cos(int length, double* x, double* y)
        {
            NativeMethods.cos_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Cos(int, double[], int, double[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Cos(int, double[], int, double[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Cos(int, double[], int, double[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="Cos(int, double[], int, double[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CosGradient(int length, double[] x, double[] dx, int offx, bool cleardx, double[] y, double[] dy, int offdy)
        {
            NativeMethods.cos_gradient_f64(length, x, dx, offx, cleardx, y, dy, offdy);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmin_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmin(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMin(int length, double* x)
        {
            return NativeMethods.argmin_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Returns the minimum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Min(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._min_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Returns the minimum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The minimum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmin(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe double Min(int length, double* x)
        {
            return NativeMethods._min_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Returns the position of maximum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.argmax_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Returns the position of maximum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The zero-based index of maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>argmax(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int ArgMax(int length, double* x)
        {
            return NativeMethods.argmax_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Returns the maximum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Max(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods._max_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Returns the maximum value in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The maximum value in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>x[argmax(x)]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe double Max(int length, double* x)
        {
            return NativeMethods._max_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Computes a smaller of each element of an array of double-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, double a, double[] y, int offy)
        {
            NativeMethods.minc_ip_f64(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of double-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, double a, double* y)
        {
            NativeMethods.minc_ip_f64(length, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of double-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, double[] x, int offx, double a, double[] y, int offy)
        {
            NativeMethods.minc_f64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of double-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = min(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MinC(int length, double* x, double a, double* y)
        {
            NativeMethods.minc_f64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.min_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, double* x, double* y)
        {
            NativeMethods.min_ip_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.min_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = min(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Min(int length, double* a, double* b, double* y)
        {
            NativeMethods.min_f64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of double-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, double a, double[] y, int offy)
        {
            NativeMethods.maxc_ip_f64(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of double-precision floating point numbers and a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(x[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, double a, double* y)
        {
            NativeMethods.maxc_ip_f64(length, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of an array of double-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, double[] x, int offx, double a, double[] y, int offy)
        {
            NativeMethods.maxc_f64(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of double-precision floating point numbers and a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="a">The constant value.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = max(y[i], a)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void MaxC(int length, double* x, double a, double* y)
        {
            NativeMethods.maxc_f64(length, x, 0, a, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.max_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(x, y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, double* x, double* y)
        {
            NativeMethods.max_ip_f64(length, x, 0, y, 0);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.max_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = max(a, b)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Max(int length, double* a, double* b, double* y)
        {
            NativeMethods.max_f64(length, a, 0, b, 0, y, 0);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sum(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.sum_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the sum of all elements in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe double Sum(int length, double* x)
        {
            return NativeMethods.sum_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CumulativeSum(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.cumulative_sum_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe double CumulativeSum(int length, double* x)
        {
            return NativeMethods.cumulative_sum_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Computes the cumulative sum of elements of an array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double CumulativeSum(int length, double[] x, int offx, double[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.cumulative_sum_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the cumulative sum of elements of an array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns>The sum of elements in <paramref name="x"/></returns>
        /// <remarks>
        /// The method performs operation defined as <c>sum(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe double CumulativeSum(int length, double* x, double* y)
        {
            return NativeMethods.cumulative_sum_f64(length, x, 0, y, 0);
        }


        /// <summary>
        /// Computes the variance of all elements in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns>The variance of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>variance(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Variance(int length, double[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.variance_ip_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the variance of all elements in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns>The variance of elements in the array.</returns>
        /// <remarks>
        /// The method performs operation defined as <c>variance(x)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe double Variance(int length, double* x)
        {
            return NativeMethods.variance_ip_f64(length, x, 0);
        }


        /// <summary>
        /// Clips elements of an array of double-precision floating point numbers to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, double minValue, double maxValue, double[] x, int offx)
        {
            if (!double.IsNaN(minValue))
            {
                Vectors.MaxC(length, minValue, x, offx);
            }

            if (!double.IsNaN(maxValue))
            {
                Vectors.MinC(length, maxValue, x, offx);
            }
        }

        /// <summary>
        /// Copies a range of values from a array of double-precision floating point numbers starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, double[] x, int offx, double[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Adds product of element of an array of double-precision floating point numbers and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, double[] x, int offx, double alpha, double[] y, int offy)
        {
            NativeMethods.addproductc_f64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of double-precision floating point numbers to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.addproduct_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, double[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_f64(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, double[] x, int offx, out double min, out double max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of double-precision floating point numbers.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, double threshold, double value, double[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_f64(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of double-precision floating point numbers.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, double threshold, double value, double[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_f64(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of double-precision floating point numbers.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, double thresholdLT, double valueLT, double thresholdGT, double valueGT, double[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_f64(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }

        /// <summary>
        /// Computes the L1-Norm (sum of magnitudes) of the array of double-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L1-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double L1Norm(int length, double[] x, int offx)
        {
            return NativeMethods.nrm1_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the L2-Norm (Euclidian norm) of the array of double-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L2-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double L2Norm(int length, double[] x, int offx)
        {
            return NativeMethods.nrm2_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the Manhattan distance between elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Manhattan distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum(abs(x[i] - y[i])).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ManhattanDistance(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.manhattan_distance_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum((x[i] - y[i])^2).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double EuclideanDistanceSquared(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.euclidean_distance_squared_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the Euclidean distance between elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sqrt(sum((x[i] - y[i])^2)).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double EuclideanDistance(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.euclidean_distance_f64(length, x, offx, y, offy);
        }

        [SuppressUnmanagedCodeSecurity]
        private static class NativeMethods
        {
            private const string DllName = "Genix.Core.Native.dll";

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_s8(int n, [In] sbyte[] x, int offx, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_s8(int n, [In] sbyte[] x, int offx, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_s8(int n, [In] sbyte* x, int offx, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_s8(int n, [In] sbyte[] x, int offx, int incx, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_s8(int n, [In] sbyte* x, int offx, int incx, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_s8(int n, [In] sbyte[] x, int offx, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_s8(int n, [In] sbyte* x, int offx, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_s8(int n, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_s8(int n, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_s8(int n, sbyte a, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_s8(int n, sbyte a, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_s8(int n, [In] sbyte[] x, int offx, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_s8(int n, [In] sbyte* x, int offx, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_s8(int n, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_ip_s8(int n, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_s8(int n, [In] sbyte[] x, int offx, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_s8(int n, [In] sbyte* x, int offx, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_s8(int n, [In] sbyte* x, int offx, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_s8(int n, [In] sbyte[] x, int offx, int incx, sbyte a, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_s8(int n, [In] sbyte* x, int offx, int incx, sbyte a, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_s8(int n, [In] sbyte* x, int offx, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_s8(int n, [In] sbyte[] x, int offx, int incx, sbyte a, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_s8(int n, [In] sbyte* x, int offx, int incx, sbyte a, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_s8(int n, [In] sbyte* x, int offx, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_s8(int n, [In] sbyte[] x, int offx, int incx, sbyte a, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_s8(int n, [In] sbyte* x, int offx, int incx, sbyte a, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_s8(int n, [In] sbyte* x, int offx, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_s8(int n, [In] sbyte[] x, int offx, int incx, sbyte a, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_s8(int n, [In] sbyte* x, int offx, int incx, sbyte a, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_s8(int n, [In] sbyte[] x, int offx, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_s8(int n, [In] sbyte* x, int offx, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_s8(int n, [In] sbyte[] x, int offx, int incx, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_s8(int n, [In] sbyte* x, int offx, int incx, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_s8(int n, [In] sbyte* a, int offa, [In] sbyte* b, int offb, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_s8(int n, [In] sbyte[] a, int offa, int inca, [In] sbyte[] b, int offb, int incb, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_s8(int n, [In] sbyte* a, int offa, int inca, [In] sbyte* b, int offb, int incb, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_s8(int n, [In] sbyte[] x, int offx, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_s8(int n, [In] sbyte* x, int offx, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_s8(int n, [In] sbyte[] x, int offx, int incx, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_s8(int n, [In] sbyte* x, int offx, int incx, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_s8(int n, [In] sbyte* a, int offa, [In] sbyte* b, int offb, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_s8(int n, [In] sbyte[] a, int offa, int inca, [In] sbyte[] b, int offb, int incb, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_s8(int n, [In] sbyte* a, int offa, int inca, [In] sbyte* b, int offb, int incb, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_s8(int n, [In] sbyte[] x, int offx, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_s8(int n, [In] sbyte* x, int offx, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_s8(int n, [In] sbyte[] x, int offx, int incx, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_s8(int n, [In] sbyte* x, int offx, int incx, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_s8(int n, [In] sbyte* a, int offa, [In] sbyte* b, int offb, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_s8(int n, [In] sbyte[] a, int offa, int inca, [In] sbyte[] b, int offb, int incb, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_s8(int n, [In] sbyte* a, int offa, int inca, [In] sbyte* b, int offb, int incb, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_s8(int n, [In] sbyte[] x, int offx, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_s8(int n, [In] sbyte* x, int offx, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_s8(int n, [In] sbyte[] x, int offx, int incx, [In, Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_s8(int n, [In] sbyte* x, int offx, int incx, [In, Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_s8(int n, [In] sbyte* a, int offa, [In] sbyte* b, int offb, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_s8(int n, [In] sbyte[] a, int offa, int inca, [In] sbyte[] b, int offb, int incb, [Out] sbyte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_s8(int n, [In] sbyte* a, int offa, int inca, [In] sbyte* b, int offb, int incb, [Out] sbyte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_s8(int n, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_s8(int n, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_s8(int n, [In] sbyte[] x, int offx, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_s8(int n, [In] sbyte* x, int offx, [Out] sbyte* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_s8(int n, [In] sbyte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_s8(int n, [In] sbyte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern sbyte _min_ip_s8(int n, [In] sbyte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe sbyte _min_ip_s8(int n, [In] sbyte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_s8(int n, [In] sbyte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_s8(int n, [In] sbyte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern sbyte _max_ip_s8(int n, [In] sbyte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe sbyte _max_ip_s8(int n, [In] sbyte* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_s8(int n, [In] sbyte* x, int offx, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_s8(int n, [In] sbyte[] x, int offx, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_s8(int n, [In] sbyte* x, int offx, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_s8(int n, [In] sbyte* a, int offa, [In] sbyte* b, int offb, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_s8(int n, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_s8(int n, sbyte a, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_s8(int n, [In] sbyte* x, int offx, sbyte a, [Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_s8(int n, [In] sbyte[] x, int offx, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_s8(int n, [In] sbyte* x, int offx, [In, Out] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_s8(int n, [In] sbyte* a, int offa, [In] sbyte* b, int offb, [Out] sbyte* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int sum_ip_s8(int n, [In] sbyte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int sum_ip_s8(int n, [In] sbyte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern sbyte cumulative_sum_ip_s8(int n, [In] sbyte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe sbyte cumulative_sum_ip_s8(int n, [In] sbyte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern sbyte cumulative_sum_s8(int n, [In] sbyte[] x, int offx, [In] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe sbyte cumulative_sum_s8(int n, [In] sbyte* x, int offx, [In] sbyte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_s8(int n, [In] sbyte[] x, int offx, sbyte a, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_s8(int n, [In] sbyte[] a, int offa, [In] sbyte[] b, int offb, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_s8(int n, [In] sbyte[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_s8(int n, sbyte threshold, sbyte value, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_s8(int n, sbyte threshold, sbyte value, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_s8(int n, sbyte thresholdLT, sbyte valueLT, sbyte thresholdGT, sbyte valueGT, [In, Out] sbyte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_u8(int n, [In] byte[] x, int offx, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_u8(int n, [In] byte[] x, int offx, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_u8(int n, [In] byte* x, int offx, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_u8(int n, [In] byte[] x, int offx, int incx, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_u8(int n, [In] byte* x, int offx, int incx, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_u8(int n, [In] byte[] x, int offx, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_u8(int n, [In] byte* x, int offx, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_u8(int n, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_u8(int n, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_u8(int n, byte a, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_u8(int n, byte a, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_u8(int n, [In] byte[] x, int offx, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_u8(int n, [In] byte* x, int offx, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_u8(int n, byte a, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_u8(int n, byte a, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_u8(int n, [In] byte[] x, int offx, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_u8(int n, [In] byte* x, int offx, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_u8(int n, [In] byte[] x, int offx, int incx, byte a, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_u8(int n, [In] byte* x, int offx, int incx, byte a, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_u8(int n, byte a, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_u8(int n, byte a, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_u8(int n, [In] byte[] x, int offx, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_u8(int n, [In] byte* x, int offx, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_u8(int n, [In] byte[] x, int offx, int incx, byte a, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_u8(int n, [In] byte* x, int offx, int incx, byte a, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_u8(int n, byte a, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_u8(int n, byte a, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_u8(int n, [In] byte[] x, int offx, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_u8(int n, [In] byte* x, int offx, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_u8(int n, [In] byte[] x, int offx, int incx, byte a, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_u8(int n, [In] byte* x, int offx, int incx, byte a, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_u8(int n, byte a, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_u8(int n, byte a, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_u8(int n, [In] byte[] x, int offx, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_u8(int n, [In] byte* x, int offx, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_u8(int n, [In] byte[] x, int offx, int incx, byte a, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_u8(int n, [In] byte* x, int offx, int incx, byte a, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_u8(int n, [In] byte[] x, int offx, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_u8(int n, [In] byte* x, int offx, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_u8(int n, [In] byte[] x, int offx, int incx, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_u8(int n, [In] byte* x, int offx, int incx, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_u8(int n, [In] byte* a, int offa, [In] byte* b, int offb, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_u8(int n, [In] byte[] a, int offa, int inca, [In] byte[] b, int offb, int incb, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_u8(int n, [In] byte* a, int offa, int inca, [In] byte* b, int offb, int incb, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_u8(int n, [In] byte[] x, int offx, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_u8(int n, [In] byte* x, int offx, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_u8(int n, [In] byte[] x, int offx, int incx, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_u8(int n, [In] byte* x, int offx, int incx, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_u8(int n, [In] byte* a, int offa, [In] byte* b, int offb, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_u8(int n, [In] byte[] a, int offa, int inca, [In] byte[] b, int offb, int incb, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_u8(int n, [In] byte* a, int offa, int inca, [In] byte* b, int offb, int incb, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_u8(int n, [In] byte[] x, int offx, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_u8(int n, [In] byte* x, int offx, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_u8(int n, [In] byte[] x, int offx, int incx, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_u8(int n, [In] byte* x, int offx, int incx, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_u8(int n, [In] byte* a, int offa, [In] byte* b, int offb, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_u8(int n, [In] byte[] a, int offa, int inca, [In] byte[] b, int offb, int incb, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_u8(int n, [In] byte* a, int offa, int inca, [In] byte* b, int offb, int incb, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_u8(int n, [In] byte[] x, int offx, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_u8(int n, [In] byte* x, int offx, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_u8(int n, [In] byte[] x, int offx, int incx, [In, Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_u8(int n, [In] byte* x, int offx, int incx, [In, Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_u8(int n, [In] byte* a, int offa, [In] byte* b, int offb, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_u8(int n, [In] byte[] a, int offa, int inca, [In] byte[] b, int offb, int incb, [Out] byte[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_u8(int n, [In] byte* a, int offa, int inca, [In] byte* b, int offb, int incb, [Out] byte* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_u8(int n, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_u8(int n, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_u8(int n, [In] byte[] x, int offx, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_u8(int n, [In] byte* x, int offx, [Out] byte* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_u8(int n, [In] byte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_u8(int n, [In] byte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern byte _min_ip_u8(int n, [In] byte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe byte _min_ip_u8(int n, [In] byte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_u8(int n, [In] byte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_u8(int n, [In] byte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern byte _max_ip_u8(int n, [In] byte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe byte _max_ip_u8(int n, [In] byte* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_u8(int n, byte a, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_u8(int n, [In] byte[] x, int offx, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_u8(int n, [In] byte* x, int offx, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_u8(int n, [In] byte[] x, int offx, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_u8(int n, [In] byte* x, int offx, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_u8(int n, [In] byte* a, int offa, [In] byte* b, int offb, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_u8(int n, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_u8(int n, byte a, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_u8(int n, [In] byte[] x, int offx, byte a, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_u8(int n, [In] byte* x, int offx, byte a, [Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_u8(int n, [In] byte[] x, int offx, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_u8(int n, [In] byte* x, int offx, [In, Out] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_u8(int n, [In] byte* a, int offa, [In] byte* b, int offb, [Out] byte* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern uint sum_ip_u8(int n, [In] byte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe uint sum_ip_u8(int n, [In] byte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern byte cumulative_sum_ip_u8(int n, [In] byte[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe byte cumulative_sum_ip_u8(int n, [In] byte* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern byte cumulative_sum_u8(int n, [In] byte[] x, int offx, [In] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe byte cumulative_sum_u8(int n, [In] byte* x, int offx, [In] byte* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_u8(int n, [In] byte[] x, int offx, byte a, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_u8(int n, [In] byte[] a, int offa, [In] byte[] b, int offb, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_u8(int n, [In] byte[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_u8(int n, byte threshold, byte value, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_u8(int n, byte threshold, byte value, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_u8(int n, byte thresholdLT, byte valueLT, byte thresholdGT, byte valueGT, [In, Out] byte[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_s16(int n, [In] short[] x, int offx, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_s16(int n, [In] short[] x, int offx, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_s16(int n, [In] short* x, int offx, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_s16(int n, [In] short[] x, int offx, int incx, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_s16(int n, [In] short* x, int offx, int incx, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_s16(int n, [In] short[] x, int offx, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_s16(int n, [In] short* x, int offx, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_s16(int n, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_s16(int n, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_s16(int n, short a, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_s16(int n, short a, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_s16(int n, [In] short[] x, int offx, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_s16(int n, [In] short* x, int offx, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_s16(int n, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_ip_s16(int n, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_s16(int n, [In] short[] x, int offx, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_s16(int n, [In] short* x, int offx, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_s16(int n, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_s16(int n, short a, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_s16(int n, short a, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_s16(int n, short a, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_s16(int n, [In] short[] x, int offx, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_s16(int n, [In] short* x, int offx, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_s16(int n, [In] short[] x, int offx, int incx, short a, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_s16(int n, [In] short* x, int offx, int incx, short a, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_s16(int n, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_s16(int n, short a, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_s16(int n, short a, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_s16(int n, short a, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_s16(int n, [In] short[] x, int offx, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_s16(int n, [In] short* x, int offx, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_s16(int n, [In] short[] x, int offx, int incx, short a, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_s16(int n, [In] short* x, int offx, int incx, short a, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_s16(int n, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_s16(int n, short a, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_s16(int n, short a, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_s16(int n, short a, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_s16(int n, [In] short[] x, int offx, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_s16(int n, [In] short* x, int offx, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_s16(int n, [In] short[] x, int offx, int incx, short a, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_s16(int n, [In] short* x, int offx, int incx, short a, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_s16(int n, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_s16(int n, short a, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_s16(int n, short a, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_s16(int n, short a, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_s16(int n, [In] short[] x, int offx, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_s16(int n, [In] short* x, int offx, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_s16(int n, [In] short[] x, int offx, int incx, short a, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_s16(int n, [In] short* x, int offx, int incx, short a, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_s16(int n, [In] short[] x, int offx, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_s16(int n, [In] short* x, int offx, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_s16(int n, [In] short[] x, int offx, int incx, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_s16(int n, [In] short* x, int offx, int incx, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_s16(int n, [In] short* a, int offa, [In] short* b, int offb, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_s16(int n, [In] short[] a, int offa, int inca, [In] short[] b, int offb, int incb, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_s16(int n, [In] short* a, int offa, int inca, [In] short* b, int offb, int incb, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_s16(int n, [In] short[] x, int offx, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_s16(int n, [In] short* x, int offx, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_s16(int n, [In] short[] x, int offx, int incx, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_s16(int n, [In] short* x, int offx, int incx, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_s16(int n, [In] short* a, int offa, [In] short* b, int offb, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_s16(int n, [In] short[] a, int offa, int inca, [In] short[] b, int offb, int incb, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_s16(int n, [In] short* a, int offa, int inca, [In] short* b, int offb, int incb, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_s16(int n, [In] short[] x, int offx, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_s16(int n, [In] short* x, int offx, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_s16(int n, [In] short[] x, int offx, int incx, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_s16(int n, [In] short* x, int offx, int incx, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_s16(int n, [In] short* a, int offa, [In] short* b, int offb, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_s16(int n, [In] short[] a, int offa, int inca, [In] short[] b, int offb, int incb, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_s16(int n, [In] short* a, int offa, int inca, [In] short* b, int offb, int incb, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_s16(int n, [In] short[] x, int offx, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_s16(int n, [In] short* x, int offx, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_s16(int n, [In] short[] x, int offx, int incx, [In, Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_s16(int n, [In] short* x, int offx, int incx, [In, Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_s16(int n, [In] short* a, int offa, [In] short* b, int offb, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_s16(int n, [In] short[] a, int offa, int inca, [In] short[] b, int offb, int incb, [Out] short[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_s16(int n, [In] short* a, int offa, int inca, [In] short* b, int offb, int incb, [Out] short* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_s16(int n, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_s16(int n, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_s16(int n, [In] short[] x, int offx, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_s16(int n, [In] short* x, int offx, [Out] short* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_s16(int n, [In] short[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_s16(int n, [In] short* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern short _min_ip_s16(int n, [In] short[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe short _min_ip_s16(int n, [In] short* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_s16(int n, [In] short[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_s16(int n, [In] short* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern short _max_ip_s16(int n, [In] short[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe short _max_ip_s16(int n, [In] short* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_s16(int n, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_s16(int n, short a, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_s16(int n, [In] short[] x, int offx, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_s16(int n, [In] short* x, int offx, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_s16(int n, [In] short[] x, int offx, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_s16(int n, [In] short* x, int offx, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_s16(int n, [In] short* a, int offa, [In] short* b, int offb, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_s16(int n, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_s16(int n, short a, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_s16(int n, [In] short[] x, int offx, short a, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_s16(int n, [In] short* x, int offx, short a, [Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_s16(int n, [In] short[] x, int offx, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_s16(int n, [In] short* x, int offx, [In, Out] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_s16(int n, [In] short* a, int offa, [In] short* b, int offb, [Out] short* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern short sum_ip_s16(int n, [In] short[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe short sum_ip_s16(int n, [In] short* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern short cumulative_sum_ip_s16(int n, [In] short[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe short cumulative_sum_ip_s16(int n, [In] short* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern short cumulative_sum_s16(int n, [In] short[] x, int offx, [In] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe short cumulative_sum_s16(int n, [In] short* x, int offx, [In] short* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_s16(int n, [In] short[] x, int offx, short a, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_s16(int n, [In] short[] a, int offa, [In] short[] b, int offb, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_s16(int n, [In] short[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_s16(int n, short threshold, short value, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_s16(int n, short threshold, short value, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_s16(int n, short thresholdLT, short valueLT, short thresholdGT, short valueGT, [In, Out] short[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_u16(int n, [In] ushort[] x, int offx, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_u16(int n, [In] ushort[] x, int offx, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_u16(int n, [In] ushort* x, int offx, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_u16(int n, [In] ushort[] x, int offx, int incx, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_u16(int n, [In] ushort* x, int offx, int incx, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_u16(int n, [In] ushort[] x, int offx, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_u16(int n, [In] ushort* x, int offx, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_u16(int n, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_u16(int n, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_u16(int n, ushort a, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_u16(int n, ushort a, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_u16(int n, [In] ushort[] x, int offx, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_u16(int n, [In] ushort* x, int offx, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_u16(int n, [In] ushort[] x, int offx, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_u16(int n, [In] ushort* x, int offx, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_u16(int n, [In] ushort[] x, int offx, int incx, ushort a, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_u16(int n, [In] ushort* x, int offx, int incx, ushort a, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_u16(int n, [In] ushort[] x, int offx, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_u16(int n, [In] ushort* x, int offx, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_u16(int n, [In] ushort[] x, int offx, int incx, ushort a, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_u16(int n, [In] ushort* x, int offx, int incx, ushort a, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_u16(int n, [In] ushort[] x, int offx, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_u16(int n, [In] ushort* x, int offx, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_u16(int n, [In] ushort[] x, int offx, int incx, ushort a, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_u16(int n, [In] ushort* x, int offx, int incx, ushort a, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_u16(int n, [In] ushort[] x, int offx, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_u16(int n, [In] ushort* x, int offx, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_u16(int n, [In] ushort[] x, int offx, int incx, ushort a, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_u16(int n, [In] ushort* x, int offx, int incx, ushort a, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_u16(int n, [In] ushort[] x, int offx, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_u16(int n, [In] ushort* x, int offx, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_u16(int n, [In] ushort[] x, int offx, int incx, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_u16(int n, [In] ushort* x, int offx, int incx, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_u16(int n, [In] ushort* a, int offa, [In] ushort* b, int offb, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_u16(int n, [In] ushort[] a, int offa, int inca, [In] ushort[] b, int offb, int incb, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_u16(int n, [In] ushort* a, int offa, int inca, [In] ushort* b, int offb, int incb, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_u16(int n, [In] ushort[] x, int offx, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_u16(int n, [In] ushort* x, int offx, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_u16(int n, [In] ushort[] x, int offx, int incx, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_u16(int n, [In] ushort* x, int offx, int incx, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_u16(int n, [In] ushort* a, int offa, [In] ushort* b, int offb, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_u16(int n, [In] ushort[] a, int offa, int inca, [In] ushort[] b, int offb, int incb, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_u16(int n, [In] ushort* a, int offa, int inca, [In] ushort* b, int offb, int incb, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_u16(int n, [In] ushort[] x, int offx, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_u16(int n, [In] ushort* x, int offx, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_u16(int n, [In] ushort[] x, int offx, int incx, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_u16(int n, [In] ushort* x, int offx, int incx, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_u16(int n, [In] ushort* a, int offa, [In] ushort* b, int offb, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_u16(int n, [In] ushort[] a, int offa, int inca, [In] ushort[] b, int offb, int incb, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_u16(int n, [In] ushort* a, int offa, int inca, [In] ushort* b, int offb, int incb, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_u16(int n, [In] ushort[] x, int offx, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_u16(int n, [In] ushort* x, int offx, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_u16(int n, [In] ushort[] x, int offx, int incx, [In, Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_u16(int n, [In] ushort* x, int offx, int incx, [In, Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_u16(int n, [In] ushort* a, int offa, [In] ushort* b, int offb, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_u16(int n, [In] ushort[] a, int offa, int inca, [In] ushort[] b, int offb, int incb, [Out] ushort[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_u16(int n, [In] ushort* a, int offa, int inca, [In] ushort* b, int offb, int incb, [Out] ushort* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_u16(int n, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_u16(int n, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_u16(int n, [In] ushort[] x, int offx, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_u16(int n, [In] ushort* x, int offx, [Out] ushort* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_u16(int n, [In] ushort[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_u16(int n, [In] ushort* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ushort _min_ip_u16(int n, [In] ushort[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ushort _min_ip_u16(int n, [In] ushort* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_u16(int n, [In] ushort[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_u16(int n, [In] ushort* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ushort _max_ip_u16(int n, [In] ushort[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ushort _max_ip_u16(int n, [In] ushort* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_u16(int n, [In] ushort[] x, int offx, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_u16(int n, [In] ushort* x, int offx, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_u16(int n, [In] ushort[] x, int offx, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_u16(int n, [In] ushort* x, int offx, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_u16(int n, [In] ushort* a, int offa, [In] ushort* b, int offb, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_u16(int n, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_u16(int n, ushort a, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_u16(int n, [In] ushort[] x, int offx, ushort a, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_u16(int n, [In] ushort* x, int offx, ushort a, [Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_u16(int n, [In] ushort[] x, int offx, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_u16(int n, [In] ushort* x, int offx, [In, Out] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_u16(int n, [In] ushort* a, int offa, [In] ushort* b, int offb, [Out] ushort* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern ushort sum_ip_u16(int n, [In] ushort[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ushort sum_ip_u16(int n, [In] ushort* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ushort cumulative_sum_ip_u16(int n, [In] ushort[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ushort cumulative_sum_ip_u16(int n, [In] ushort* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ushort cumulative_sum_u16(int n, [In] ushort[] x, int offx, [In] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ushort cumulative_sum_u16(int n, [In] ushort* x, int offx, [In] ushort* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_u16(int n, [In] ushort[] x, int offx, ushort a, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_u16(int n, [In] ushort[] a, int offa, [In] ushort[] b, int offb, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_u16(int n, [In] ushort[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_u16(int n, ushort threshold, ushort value, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_u16(int n, ushort threshold, ushort value, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_u16(int n, ushort thresholdLT, ushort valueLT, ushort thresholdGT, ushort valueGT, [In, Out] ushort[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_s32(int n, [In] int* x, int offx, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_s32(int n, [In] int[] x, int offx, int incx, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_s32(int n, [In] int* x, int offx, int incx, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_s32(int n, [In] int* x, int offx, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_s32(int n, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_s32(int n, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_s32(int n, int a, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_s32(int n, int a, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_s32(int n, [In] int* x, int offx, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_s32(int n, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_ip_s32(int n, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_s32(int n, [In] int* x, int offx, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_s32(int n, int a, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_s32(int n, int a, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_s32(int n, int a, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_s32(int n, [In] int* x, int offx, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_s32(int n, [In] int[] x, int offx, int incx, int a, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_s32(int n, [In] int* x, int offx, int incx, int a, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_s32(int n, int a, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_s32(int n, int a, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_s32(int n, int a, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_s32(int n, [In] int* x, int offx, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_s32(int n, [In] int[] x, int offx, int incx, int a, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_s32(int n, [In] int* x, int offx, int incx, int a, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_s32(int n, int a, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_s32(int n, int a, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_s32(int n, int a, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_s32(int n, [In] int* x, int offx, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_s32(int n, [In] int[] x, int offx, int incx, int a, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_s32(int n, [In] int* x, int offx, int incx, int a, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_s32(int n, int a, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_s32(int n, int a, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_s32(int n, int a, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_s32(int n, [In] int* x, int offx, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_s32(int n, [In] int[] x, int offx, int incx, int a, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_s32(int n, [In] int* x, int offx, int incx, int a, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_s32(int n, [In] int[] x, int offx, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_s32(int n, [In] int* x, int offx, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_s32(int n, [In] int[] x, int offx, int incx, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_s32(int n, [In] int* x, int offx, int incx, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_s32(int n, [In] int* a, int offa, [In] int* b, int offb, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_s32(int n, [In] int[] a, int offa, int inca, [In] int[] b, int offb, int incb, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_s32(int n, [In] int* a, int offa, int inca, [In] int* b, int offb, int incb, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_s32(int n, [In] int[] x, int offx, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_s32(int n, [In] int* x, int offx, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_s32(int n, [In] int[] x, int offx, int incx, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_s32(int n, [In] int* x, int offx, int incx, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_s32(int n, [In] int* a, int offa, [In] int* b, int offb, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_s32(int n, [In] int[] a, int offa, int inca, [In] int[] b, int offb, int incb, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_s32(int n, [In] int* a, int offa, int inca, [In] int* b, int offb, int incb, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_s32(int n, [In] int[] x, int offx, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_s32(int n, [In] int* x, int offx, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_s32(int n, [In] int[] x, int offx, int incx, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_s32(int n, [In] int* x, int offx, int incx, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_s32(int n, [In] int* a, int offa, [In] int* b, int offb, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_s32(int n, [In] int[] a, int offa, int inca, [In] int[] b, int offb, int incb, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_s32(int n, [In] int* a, int offa, int inca, [In] int* b, int offb, int incb, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_s32(int n, [In] int[] x, int offx, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_s32(int n, [In] int* x, int offx, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_s32(int n, [In] int[] x, int offx, int incx, [In, Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_s32(int n, [In] int* x, int offx, int incx, [In, Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_s32(int n, [In] int* a, int offa, [In] int* b, int offb, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_s32(int n, [In] int[] a, int offa, int inca, [In] int[] b, int offb, int incb, [Out] int[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_s32(int n, [In] int* a, int offa, int inca, [In] int* b, int offb, int incb, [Out] int* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_s32(int n, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_s32(int n, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_s32(int n, [In] int* x, int offx, [Out] int* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_s32(int n, [In] int[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_s32(int n, [In] int* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int _min_ip_s32(int n, [In] int[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int _min_ip_s32(int n, [In] int* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_s32(int n, [In] int[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_s32(int n, [In] int* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int _max_ip_s32(int n, [In] int[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int _max_ip_s32(int n, [In] int* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_s32(int n, int a, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_s32(int n, [In] int* x, int offx, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_s32(int n, [In] int[] x, int offx, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_s32(int n, [In] int* x, int offx, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_s32(int n, [In] int* a, int offa, [In] int* b, int offb, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_s32(int n, int a, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_s32(int n, [In] int* x, int offx, int a, [Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_s32(int n, [In] int[] x, int offx, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_s32(int n, [In] int* x, int offx, [In, Out] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_s32(int n, [In] int* a, int offa, [In] int* b, int offb, [Out] int* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int sum_ip_s32(int n, [In] int[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int sum_ip_s32(int n, [In] int* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int cumulative_sum_ip_s32(int n, [In] int[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int cumulative_sum_ip_s32(int n, [In] int* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int cumulative_sum_s32(int n, [In] int[] x, int offx, [In] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int cumulative_sum_s32(int n, [In] int* x, int offx, [In] int* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_s32(int n, [In] int[] x, int offx, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_s32(int n, [In] int[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_s32(int n, int threshold, int value, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_s32(int n, int threshold, int value, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_s32(int n, int thresholdLT, int valueLT, int thresholdGT, int valueGT, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_u32(int n, [In] uint* x, int offx, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_u32(int n, [In] uint[] x, int offx, int incx, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_u32(int n, [In] uint* x, int offx, int incx, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_u32(int n, [In] uint* x, int offx, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_u32(int n, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_u32(int n, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_u32(int n, uint a, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_u32(int n, uint a, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_u32(int n, [In] uint* x, int offx, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_u32(int n, uint a, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_u32(int n, [In] uint[] x, int offx, int incx, uint a, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_u32(int n, [In] uint* x, int offx, int incx, uint a, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_u32(int n, uint a, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_u32(int n, [In] uint[] x, int offx, int incx, uint a, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_u32(int n, [In] uint* x, int offx, int incx, uint a, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_u32(int n, uint a, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_u32(int n, [In] uint[] x, int offx, int incx, uint a, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_u32(int n, [In] uint* x, int offx, int incx, uint a, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_u32(int n, uint a, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_u32(int n, [In] uint[] x, int offx, int incx, uint a, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_u32(int n, [In] uint* x, int offx, int incx, uint a, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_u32(int n, [In] uint[] x, int offx, int incx, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_u32(int n, [In] uint* x, int offx, int incx, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_u32(int n, [In] uint[] a, int offa, int inca, [In] uint[] b, int offb, int incb, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_u32(int n, [In] uint* a, int offa, int inca, [In] uint* b, int offb, int incb, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_u32(int n, [In] uint[] x, int offx, int incx, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_u32(int n, [In] uint* x, int offx, int incx, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_u32(int n, [In] uint[] a, int offa, int inca, [In] uint[] b, int offb, int incb, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_u32(int n, [In] uint* a, int offa, int inca, [In] uint* b, int offb, int incb, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_u32(int n, [In] uint[] x, int offx, int incx, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_u32(int n, [In] uint* x, int offx, int incx, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_u32(int n, [In] uint[] a, int offa, int inca, [In] uint[] b, int offb, int incb, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_u32(int n, [In] uint* a, int offa, int inca, [In] uint* b, int offb, int incb, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_u32(int n, [In] uint[] x, int offx, int incx, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_u32(int n, [In] uint* x, int offx, int incx, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_u32(int n, [In] uint[] a, int offa, int inca, [In] uint[] b, int offb, int incb, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_u32(int n, [In] uint* a, int offa, int inca, [In] uint* b, int offb, int incb, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_u32(int n, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_u32(int n, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_u32(int n, [In] uint* x, int offx, [Out] uint* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_u32(int n, [In] uint[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_u32(int n, [In] uint* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern uint _min_ip_u32(int n, [In] uint[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe uint _min_ip_u32(int n, [In] uint* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_u32(int n, [In] uint[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_u32(int n, [In] uint* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern uint _max_ip_u32(int n, [In] uint[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe uint _max_ip_u32(int n, [In] uint* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_bits_ip_u32(int n, int bitCount, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_bits_ip_u32(int n, int bitCount, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_bits_u32(int n, [In] uint[] x, int offx, int bitCount, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_bits_u32(int n, [In] uint* x, int offx, int bitCount, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void not_ip_u32(int n, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void not_ip_u32(int n, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void not_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void not_u32(int n, [In] uint* x, int offx, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void orc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void orc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void orc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void orc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or3_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [In] uint[] c, int offc, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or3_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [In] uint* c, int offc, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or4_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [In] uint[] c, int offc, [In] uint[] d, int offd, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or4_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [In] uint* c, int offc, [In] uint* d, int offd, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_inc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_inc_ip_u32(int n, uint a, [In, Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_inc_u32(int n, [In] uint[] x, int offx, int incx, uint a, [Out] uint[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_inc_u32(int n, [In] uint* x, int offx, int incx, uint a, [Out] uint* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and3_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [In] uint[] c, int offc, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and3_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [In] uint* c, int offc, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and4_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [In] uint[] c, int offc, [In] uint[] d, int offd, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and4_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [In] uint* c, int offc, [In] uint* d, int offd, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xorc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xorc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xorc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xorc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xor_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xor_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xor_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xor_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xandc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xandc_ip_u32(int n, uint a, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xandc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xandc_u32(int n, [In] uint* x, int offx, uint a, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xand_ip_u32(int n, [In] uint[] x, int offx, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xand_ip_u32(int n, [In] uint* x, int offx, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xand_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xand_u32(int n, [In] uint* a, int offa, [In] uint* b, int offb, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shr_ip_u32(int n, int shift, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shr_ip_u32(int n, int shift, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shr_u32(int n, [In] uint[] x, int offx, int shift, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shr_u32(int n, [In] uint* x, int offx, int shift, [Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shl_ip_u32(int n, int shift, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shl_ip_u32(int n, int shift, [In, Out] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shl_u32(int n, [In] uint[] x, int offx, int shift, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shl_u32(int n, [In] uint* x, int offx, int shift, [Out] uint* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern uint sum_ip_u32(int n, [In] uint[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe uint sum_ip_u32(int n, [In] uint* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern uint cumulative_sum_ip_u32(int n, [In] uint[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe uint cumulative_sum_ip_u32(int n, [In] uint* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern uint cumulative_sum_u32(int n, [In] uint[] x, int offx, [In] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe uint cumulative_sum_u32(int n, [In] uint* x, int offx, [In] uint* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_u32(int n, [In] uint[] x, int offx, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_u32(int n, [In] uint[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_u32(int n, uint threshold, uint value, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_u32(int n, uint threshold, uint value, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_u32(int n, uint thresholdLT, uint valueLT, uint thresholdGT, uint valueGT, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_s64(int n, [In] long* x, int offx, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_s64(int n, [In] long[] x, int offx, int incx, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_s64(int n, [In] long* x, int offx, int incx, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_s64(int n, [In] long* x, int offx, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_s64(int n, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_s64(int n, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_s64(int n, long a, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_s64(int n, long a, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_s64(int n, [In] long* x, int offx, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_s64(int n, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_ip_s64(int n, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_s64(int n, [In] long* x, int offx, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_s64(int n, long a, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_s64(int n, long a, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_s64(int n, long a, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_s64(int n, [In] long* x, int offx, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_s64(int n, [In] long[] x, int offx, int incx, long a, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_s64(int n, [In] long* x, int offx, int incx, long a, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_s64(int n, long a, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_s64(int n, long a, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_s64(int n, long a, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_s64(int n, [In] long* x, int offx, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_s64(int n, [In] long[] x, int offx, int incx, long a, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_s64(int n, [In] long* x, int offx, int incx, long a, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_s64(int n, long a, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_s64(int n, long a, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_s64(int n, long a, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_s64(int n, [In] long* x, int offx, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_s64(int n, [In] long[] x, int offx, int incx, long a, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_s64(int n, [In] long* x, int offx, int incx, long a, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_s64(int n, long a, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_s64(int n, long a, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_s64(int n, long a, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_s64(int n, [In] long* x, int offx, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_s64(int n, [In] long[] x, int offx, int incx, long a, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_s64(int n, [In] long* x, int offx, int incx, long a, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_s64(int n, [In] long[] x, int offx, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_s64(int n, [In] long* x, int offx, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_s64(int n, [In] long[] x, int offx, int incx, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_s64(int n, [In] long* x, int offx, int incx, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_s64(int n, [In] long* a, int offa, [In] long* b, int offb, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_s64(int n, [In] long[] a, int offa, int inca, [In] long[] b, int offb, int incb, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_s64(int n, [In] long* a, int offa, int inca, [In] long* b, int offb, int incb, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_s64(int n, [In] long[] x, int offx, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_s64(int n, [In] long* x, int offx, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_s64(int n, [In] long[] x, int offx, int incx, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_s64(int n, [In] long* x, int offx, int incx, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_s64(int n, [In] long* a, int offa, [In] long* b, int offb, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_s64(int n, [In] long[] a, int offa, int inca, [In] long[] b, int offb, int incb, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_s64(int n, [In] long* a, int offa, int inca, [In] long* b, int offb, int incb, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_s64(int n, [In] long[] x, int offx, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_s64(int n, [In] long* x, int offx, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_s64(int n, [In] long[] x, int offx, int incx, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_s64(int n, [In] long* x, int offx, int incx, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_s64(int n, [In] long* a, int offa, [In] long* b, int offb, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_s64(int n, [In] long[] a, int offa, int inca, [In] long[] b, int offb, int incb, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_s64(int n, [In] long* a, int offa, int inca, [In] long* b, int offb, int incb, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_s64(int n, [In] long[] x, int offx, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_s64(int n, [In] long* x, int offx, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_s64(int n, [In] long[] x, int offx, int incx, [In, Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_s64(int n, [In] long* x, int offx, int incx, [In, Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_s64(int n, [In] long* a, int offa, [In] long* b, int offb, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_s64(int n, [In] long[] a, int offa, int inca, [In] long[] b, int offb, int incb, [Out] long[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_s64(int n, [In] long* a, int offa, int inca, [In] long* b, int offb, int incb, [Out] long* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_s64(int n, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_s64(int n, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_s64(int n, [In] long* x, int offx, [Out] long* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_s64(int n, [In] long[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_s64(int n, [In] long* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern long _min_ip_s64(int n, [In] long[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe long _min_ip_s64(int n, [In] long* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_s64(int n, [In] long[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_s64(int n, [In] long* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern long _max_ip_s64(int n, [In] long[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe long _max_ip_s64(int n, [In] long* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_s64(int n, long a, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_s64(int n, [In] long* x, int offx, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_s64(int n, [In] long[] x, int offx, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_s64(int n, [In] long* x, int offx, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_s64(int n, [In] long* a, int offa, [In] long* b, int offb, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_s64(int n, long a, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_s64(int n, [In] long* x, int offx, long a, [Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_s64(int n, [In] long[] x, int offx, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_s64(int n, [In] long* x, int offx, [In, Out] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_s64(int n, [In] long* a, int offa, [In] long* b, int offb, [Out] long* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern long sum_ip_s64(int n, [In] long[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe long sum_ip_s64(int n, [In] long* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern long cumulative_sum_ip_s64(int n, [In] long[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe long cumulative_sum_ip_s64(int n, [In] long* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern long cumulative_sum_s64(int n, [In] long[] x, int offx, [In] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe long cumulative_sum_s64(int n, [In] long* x, int offx, [In] long* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_s64(int n, [In] long[] x, int offx, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_s64(int n, [In] long[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_s64(int n, long threshold, long value, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_s64(int n, long threshold, long value, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_s64(int n, long thresholdLT, long valueLT, long thresholdGT, long valueGT, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_u64(int n, [In] ulong* x, int offx, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_u64(int n, [In] ulong[] x, int offx, int incx, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_u64(int n, [In] ulong* x, int offx, int incx, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_u64(int n, [In] ulong* x, int offx, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_u64(int n, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_u64(int n, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_u64(int n, ulong a, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_u64(int n, ulong a, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_u64(int n, [In] ulong* x, int offx, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_u64(int n, [In] ulong[] x, int offx, int incx, ulong a, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_u64(int n, [In] ulong* x, int offx, int incx, ulong a, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_u64(int n, [In] ulong[] x, int offx, int incx, ulong a, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_u64(int n, [In] ulong* x, int offx, int incx, ulong a, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_u64(int n, [In] ulong[] x, int offx, int incx, ulong a, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_u64(int n, [In] ulong* x, int offx, int incx, ulong a, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_u64(int n, [In] ulong[] x, int offx, int incx, ulong a, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_u64(int n, [In] ulong* x, int offx, int incx, ulong a, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_u64(int n, [In] ulong[] x, int offx, int incx, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_u64(int n, [In] ulong* x, int offx, int incx, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_u64(int n, [In] ulong[] a, int offa, int inca, [In] ulong[] b, int offb, int incb, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_u64(int n, [In] ulong* a, int offa, int inca, [In] ulong* b, int offb, int incb, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_u64(int n, [In] ulong[] x, int offx, int incx, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_u64(int n, [In] ulong* x, int offx, int incx, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_u64(int n, [In] ulong[] a, int offa, int inca, [In] ulong[] b, int offb, int incb, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_u64(int n, [In] ulong* a, int offa, int inca, [In] ulong* b, int offb, int incb, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_u64(int n, [In] ulong[] x, int offx, int incx, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_u64(int n, [In] ulong* x, int offx, int incx, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_u64(int n, [In] ulong[] a, int offa, int inca, [In] ulong[] b, int offb, int incb, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_u64(int n, [In] ulong* a, int offa, int inca, [In] ulong* b, int offb, int incb, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_u64(int n, [In] ulong[] x, int offx, int incx, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_u64(int n, [In] ulong* x, int offx, int incx, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_u64(int n, [In] ulong[] a, int offa, int inca, [In] ulong[] b, int offb, int incb, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_u64(int n, [In] ulong* a, int offa, int inca, [In] ulong* b, int offb, int incb, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_u64(int n, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_u64(int n, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_u64(int n, [In] ulong* x, int offx, [Out] ulong* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_u64(int n, [In] ulong[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_u64(int n, [In] ulong* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ulong _min_ip_u64(int n, [In] ulong[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ulong _min_ip_u64(int n, [In] ulong* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_u64(int n, [In] ulong[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_u64(int n, [In] ulong* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ulong _max_ip_u64(int n, [In] ulong[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ulong _max_ip_u64(int n, [In] ulong* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_bits_ip_u64(int n, int bitCount, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_bits_ip_u64(int n, int bitCount, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_bits_u64(int n, [In] ulong[] x, int offx, int bitCount, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_bits_u64(int n, [In] ulong* x, int offx, int bitCount, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void not_ip_u64(int n, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void not_ip_u64(int n, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void not_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void not_u64(int n, [In] ulong* x, int offx, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void orc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void orc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void orc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void orc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or3_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [In] ulong[] c, int offc, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or3_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [In] ulong* c, int offc, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or4_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [In] ulong[] c, int offc, [In] ulong[] d, int offd, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void or4_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [In] ulong* c, int offc, [In] ulong* d, int offd, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_inc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_inc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void andc_inc_u64(int n, [In] ulong[] x, int offx, int incx, ulong a, [Out] ulong[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void andc_inc_u64(int n, [In] ulong* x, int offx, int incx, ulong a, [Out] ulong* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and3_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [In] ulong[] c, int offc, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and3_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [In] ulong* c, int offc, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and4_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [In] ulong[] c, int offc, [In] ulong[] d, int offd, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void and4_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [In] ulong* c, int offc, [In] ulong* d, int offd, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xorc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xorc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xorc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xorc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xor_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xor_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xor_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xor_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xandc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xandc_ip_u64(int n, ulong a, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xandc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xandc_u64(int n, [In] ulong* x, int offx, ulong a, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xand_ip_u64(int n, [In] ulong[] x, int offx, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xand_ip_u64(int n, [In] ulong* x, int offx, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xand_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void xand_u64(int n, [In] ulong* a, int offa, [In] ulong* b, int offb, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shr_ip_u64(int n, int shift, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shr_ip_u64(int n, int shift, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shr_u64(int n, [In] ulong[] x, int offx, int shift, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shr_u64(int n, [In] ulong* x, int offx, int shift, [Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shl_ip_u64(int n, int shift, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shl_ip_u64(int n, int shift, [In, Out] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void shl_u64(int n, [In] ulong[] x, int offx, int shift, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void shl_u64(int n, [In] ulong* x, int offx, int shift, [Out] ulong* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern ulong sum_ip_u64(int n, [In] ulong[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ulong sum_ip_u64(int n, [In] ulong* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ulong cumulative_sum_ip_u64(int n, [In] ulong[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ulong cumulative_sum_ip_u64(int n, [In] ulong* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern ulong cumulative_sum_u64(int n, [In] ulong[] x, int offx, [In] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe ulong cumulative_sum_u64(int n, [In] ulong* x, int offx, [In] ulong* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_u64(int n, [In] ulong[] x, int offx, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_u64(int n, [In] ulong[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_u64(int n, ulong threshold, ulong value, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_u64(int n, ulong threshold, ulong value, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_u64(int n, ulong thresholdLT, ulong valueLT, ulong thresholdGT, ulong valueGT, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_f32(int n, [In] float[] x, int offx, int incx, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_f32(int n, [In] float* x, int offx, int incx, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_f32(int n, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_f32(int n, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_f32(int n, float a, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_f32(int n, float a, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_gradient_f32(
                int n,
                [In] float[] x,
                [Out] float[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] float[] y,
                [In] float[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_f32(int n, float a, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_f32(int n, float a, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_f32(int n, float a, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_f32(int n, [In] float* x, int offx, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_f32(int n, [In] float[] x, int offx, int incx, float a, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_f32(int n, [In] float* x, int offx, int incx, float a, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_f32(int n, float a, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_f32(int n, float a, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_f32(int n, float a, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_f32(int n, [In] float* x, int offx, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_f32(int n, [In] float[] x, int offx, int incx, float a, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_f32(int n, [In] float* x, int offx, int incx, float a, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_f32(int n, float a, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_f32(int n, float a, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_f32(int n, float a, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_f32(int n, [In] float* x, int offx, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_f32(int n, [In] float[] x, int offx, int incx, float a, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_f32(int n, [In] float* x, int offx, int incx, float a, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_f32(int n, float a, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_f32(int n, float a, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_f32(int n, float a, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_f32(int n, [In] float* x, int offx, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_f32(int n, [In] float[] x, int offx, int incx, float a, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_f32(int n, [In] float* x, int offx, int incx, float a, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_f32(int n, [In] float[] x, int offx, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_f32(int n, [In] float* x, int offx, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_f32(int n, [In] float[] x, int offx, int incx, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_f32(int n, [In] float* x, int offx, int incx, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_f32(int n, [In] float* a, int offa, [In] float* b, int offb, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_f32(int n, [In] float[] a, int offa, int inca, [In] float[] b, int offb, int incb, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_f32(int n, [In] float* a, int offa, int inca, [In] float* b, int offb, int incb, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_f32(int n, [In] float[] x, int offx, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_f32(int n, [In] float* x, int offx, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_f32(int n, [In] float[] x, int offx, int incx, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_f32(int n, [In] float* x, int offx, int incx, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_f32(int n, [In] float* a, int offa, [In] float* b, int offb, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_f32(int n, [In] float[] a, int offa, int inca, [In] float[] b, int offb, int incb, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_f32(int n, [In] float* a, int offa, int inca, [In] float* b, int offb, int incb, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_f32(int n, [In] float[] x, int offx, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_f32(int n, [In] float* x, int offx, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_f32(int n, [In] float[] x, int offx, int incx, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_f32(int n, [In] float* x, int offx, int incx, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_f32(int n, [In] float* a, int offa, [In] float* b, int offb, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_f32(int n, [In] float[] a, int offa, int inca, [In] float[] b, int offb, int incb, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_f32(int n, [In] float* a, int offa, int inca, [In] float* b, int offb, int incb, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_f32(int n, [In] float[] x, int offx, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_f32(int n, [In] float* x, int offx, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_f32(int n, [In] float[] x, int offx, int incx, [In, Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_f32(int n, [In] float* x, int offx, int incx, [In, Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_f32(int n, [In] float* a, int offa, [In] float* b, int offb, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_f32(int n, [In] float[] a, int offa, int inca, [In] float[] b, int offb, int incb, [Out] float[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_f32(int n, [In] float* a, int offa, int inca, [In] float* b, int offb, int incb, [Out] float* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqrt_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqrt_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void log_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void log_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void exp_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void exp_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sin_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sin_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_gradient_f32(
                int n,
                [In] float[] x,
                [Out] float[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] float[] y,
                [In] float[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void cos_ip_f32(int n, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void cos_f32(int n, [In] float* x, int offx, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_gradient_f32(
                int n,
                [In] float[] x,
                [Out] float[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] float[] y,
                [In] float[] dy,
                int offdy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_f32(int n, [In] float* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern float _min_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe float _min_ip_f32(int n, [In] float* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_f32(int n, [In] float* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern float _max_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe float _max_ip_f32(int n, [In] float* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_f32(int n, float a, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_f32(int n, [In] float* x, int offx, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_f32(int n, [In] float[] x, int offx, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_f32(int n, [In] float* x, int offx, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_f32(int n, [In] float* a, int offa, [In] float* b, int offb, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_f32(int n, float a, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_f32(int n, [In] float* x, int offx, float a, [Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_f32(int n, [In] float[] x, int offx, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_f32(int n, [In] float* x, int offx, [In, Out] float* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_f32(int n, [In] float* a, int offa, [In] float* b, int offb, [Out] float* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern float sum_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe float sum_ip_f32(int n, [In] float* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern float cumulative_sum_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe float cumulative_sum_ip_f32(int n, [In] float* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern float cumulative_sum_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe float cumulative_sum_f32(int n, [In] float* x, int offx, [In] float* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern float variance_ip_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe float variance_ip_f32(int n, [In] float* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_f32(int n, [In] float[] x, int offx, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_f32(int n, [In] float[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_f32(int n, float threshold, float value, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_f32(int n, float threshold, float value, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_f32(int n, float thresholdLT, float valueLT, float thresholdGT, float valueGT, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern float nrm1_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern float nrm2_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern float manhattan_distance_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern float euclidean_distance_squared_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern float euclidean_distance_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_inc_f64(int n, [In] double[] x, int offx, int incx, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void copy_inc_f64(int n, [In] double* x, int offx, int incx, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void move_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_f64(int n, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_f64(int n, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_inc_f64(int n, double a, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void set_inc_f64(int n, double a, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void swap_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void abs_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_gradient_f64(
                int n,
                [In] double[] x,
                [Out] double[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] double[] y,
                [In] double[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_ip_f64(int n, double a, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_ip_f64(int n, double a, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_ip_f64(int n, double a, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_f64(int n, [In] double* x, int offx, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_inc_f64(int n, [In] double[] x, int offx, int incx, double a, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void addc_inc_f64(int n, [In] double* x, int offx, int incx, double a, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_ip_f64(int n, double a, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_ip_f64(int n, double a, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_ip_f64(int n, double a, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_f64(int n, [In] double* x, int offx, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_inc_f64(int n, [In] double[] x, int offx, int incx, double a, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void subc_inc_f64(int n, [In] double* x, int offx, int incx, double a, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_ip_f64(int n, double a, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_ip_f64(int n, double a, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_ip_f64(int n, double a, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_f64(int n, [In] double* x, int offx, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_inc_f64(int n, [In] double[] x, int offx, int incx, double a, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mulc_inc_f64(int n, [In] double* x, int offx, int incx, double a, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_ip_f64(int n, double a, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_ip_f64(int n, double a, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_ip_f64(int n, double a, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_f64(int n, [In] double* x, int offx, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_inc_f64(int n, [In] double[] x, int offx, int incx, double a, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void divc_inc_f64(int n, [In] double* x, int offx, int incx, double a, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_f64(int n, [In] double[] x, int offx, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_ip_f64(int n, [In] double* x, int offx, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_ip_f64(int n, [In] double[] x, int offx, int incx, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_ip_f64(int n, [In] double* x, int offx, int incx, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_f64(int n, [In] double* a, int offa, [In] double* b, int offb, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_inc_f64(int n, [In] double[] a, int offa, int inca, [In] double[] b, int offb, int incb, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void add_inc_f64(int n, [In] double* a, int offa, int inca, [In] double* b, int offb, int incb, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_f64(int n, [In] double[] x, int offx, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_ip_f64(int n, [In] double* x, int offx, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_ip_f64(int n, [In] double[] x, int offx, int incx, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_ip_f64(int n, [In] double* x, int offx, int incx, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_f64(int n, [In] double* a, int offa, [In] double* b, int offb, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_inc_f64(int n, [In] double[] a, int offa, int inca, [In] double[] b, int offb, int incb, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sub_inc_f64(int n, [In] double* a, int offa, int inca, [In] double* b, int offb, int incb, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_f64(int n, [In] double[] x, int offx, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_ip_f64(int n, [In] double* x, int offx, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_ip_f64(int n, [In] double[] x, int offx, int incx, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_ip_f64(int n, [In] double* x, int offx, int incx, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_f64(int n, [In] double* a, int offa, [In] double* b, int offb, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_inc_f64(int n, [In] double[] a, int offa, int inca, [In] double[] b, int offb, int incb, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void mul_inc_f64(int n, [In] double* a, int offa, int inca, [In] double* b, int offb, int incb, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_ip_f64(int n, [In] double[] x, int offx, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_ip_f64(int n, [In] double* x, int offx, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_ip_f64(int n, [In] double[] x, int offx, int incx, [In, Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_ip_f64(int n, [In] double* x, int offx, int incx, [In, Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_f64(int n, [In] double* a, int offa, [In] double* b, int offb, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void div_inc_f64(int n, [In] double[] a, int offa, int inca, [In] double[] b, int offb, int incb, [Out] double[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void div_inc_f64(int n, [In] double* a, int offa, int inca, [In] double* b, int offb, int incb, [Out] double* y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqr_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqrt_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sqrt_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void log_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void log_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void exp_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void exp_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sin_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void sin_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_gradient_f64(
                int n,
                [In] double[] x,
                [Out] double[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] double[] y,
                [In] double[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void cos_ip_f64(int n, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void cos_f64(int n, [In] double* x, int offx, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_gradient_f64(
                int n,
                [In] double[] x,
                [Out] double[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] double[] y,
                [In] double[] dy,
                int offdy);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmin_ip_f64(int n, [In] double* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern double _min_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe double _min_ip_f64(int n, [In] double* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe int argmax_ip_f64(int n, [In] double* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern double _max_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe double _max_ip_f64(int n, [In] double* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_ip_f64(int n, double a, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void minc_f64(int n, [In] double* x, int offx, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_f64(int n, [In] double[] x, int offx, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_ip_f64(int n, [In] double* x, int offx, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void min_f64(int n, [In] double* a, int offa, [In] double* b, int offb, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_ip_f64(int n, double a, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void maxc_f64(int n, [In] double* x, int offx, double a, [Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_f64(int n, [In] double[] x, int offx, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_ip_f64(int n, [In] double* x, int offx, [In, Out] double* y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void max_f64(int n, [In] double* a, int offa, [In] double* b, int offb, [Out] double* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern double sum_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe double sum_ip_f64(int n, [In] double* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern double cumulative_sum_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe double cumulative_sum_ip_f64(int n, [In] double* x, int offx);
            [DllImport(NativeMethods.DllName)]
            public static extern double cumulative_sum_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe double cumulative_sum_f64(int n, [In] double* x, int offx, [In] double* y, int offy);
            [DllImport(NativeMethods.DllName)]
            public static extern double variance_ip_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe double variance_ip_f64(int n, [In] double* x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_f64(int n, [In] double[] x, int offx, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_f64(int n, [In] double[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_f64(int n, double threshold, double value, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_f64(int n, double threshold, double value, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_f64(int n, double thresholdLT, double valueLT, double thresholdGT, double valueGT, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern double nrm1_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern double nrm2_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern double manhattan_distance_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern double euclidean_distance_squared_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern double euclidean_distance_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);
        }
    }
}

