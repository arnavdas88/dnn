// -----------------------------------------------------------------------
// <copyright file="Vectors.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 9/9/2018 11:02:17 AM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Core
{
    using System;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;

    /// <summary>
    /// Provides mathematical methods for numeric vectors manipulation.
    /// </summary>
	[CLSCompliant(false)]
    public static class Vectors
    {
        /// <summary>
        /// Computes the absolute value of elements of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = Math.Abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, int[] y, int offy)
        {
            NativeMethods.abs_ip_s32(length, y, offy);
        }

        /// <summary>
        /// Computes the absolute value of elements of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The array that receives the data.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.abs_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, int alpha, int[] y, int offy)
        {
            NativeMethods.addc_ip_s32(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, int[] x, int offx, int alpha, int[] y, int offy)
        {
            NativeMethods.addc_s32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.add_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.add_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] int alpha, int[] y, int offy)
        {
            NativeMethods.subc_ip_s32(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, int[] x, int offx, [In] int alpha, int[] y, int offy)
        {
            NativeMethods.subc_s32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.sub_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.sub_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, int alpha, int[] y, int offy)
        {
            NativeMethods.mulc_ip_s32(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, int[] x, int offx, int alpha, int[] y, int offy)
        {
            NativeMethods.mulc_s32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, int[] x, int offx, int[] y, int offy)
        {
            NativeMethods.mul_ip_s32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, int[] a, int offa, int[] b, int offb, int[] y, int offy)
        {
            NativeMethods.mul_s32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, int alpha, int[] y, int offy)
        {
            NativeMethods.divc_ip_s32(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, int[] x, int offx, int alpha, int[] y, int offy)
        {
            NativeMethods.divc_s32(length, x, offx, alpha, y, offy);
        }


        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, uint alpha, uint[] y, int offy)
        {
            NativeMethods.addc_ip_u32(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, uint[] x, int offx, uint alpha, uint[] y, int offy)
        {
            NativeMethods.addc_u32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.add_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.add_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] uint alpha, uint[] y, int offy)
        {
            NativeMethods.subc_ip_u32(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, uint[] x, int offx, [In] uint alpha, uint[] y, int offy)
        {
            NativeMethods.subc_u32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.sub_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.sub_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, uint alpha, uint[] y, int offy)
        {
            NativeMethods.mulc_ip_u32(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 32-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, uint[] x, int offx, uint alpha, uint[] y, int offy)
        {
            NativeMethods.mulc_u32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, uint[] x, int offx, uint[] y, int offy)
        {
            NativeMethods.mul_ip_u32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, uint[] a, int offa, uint[] b, int offb, uint[] y, int offy)
        {
            NativeMethods.mul_u32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, uint alpha, uint[] y, int offy)
        {
            NativeMethods.divc_ip_u32(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 32-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, uint[] x, int offx, uint alpha, uint[] y, int offy)
        {
            NativeMethods.divc_u32(length, x, offx, alpha, y, offy);
        }


        /// <summary>
        /// Computes the absolute value of elements of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = Math.Abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, long[] y, int offy)
        {
            NativeMethods.abs_ip_s64(length, y, offy);
        }

        /// <summary>
        /// Computes the absolute value of elements of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The array that receives the data.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.abs_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, long alpha, long[] y, int offy)
        {
            NativeMethods.addc_ip_s64(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, long[] x, int offx, long alpha, long[] y, int offy)
        {
            NativeMethods.addc_s64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.add_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.add_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] long alpha, long[] y, int offy)
        {
            NativeMethods.subc_ip_s64(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, long[] x, int offx, [In] long alpha, long[] y, int offy)
        {
            NativeMethods.subc_s64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.sub_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.sub_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, long alpha, long[] y, int offy)
        {
            NativeMethods.mulc_ip_s64(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, long[] x, int offx, long alpha, long[] y, int offy)
        {
            NativeMethods.mulc_s64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, long[] x, int offx, long[] y, int offy)
        {
            NativeMethods.mul_ip_s64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, long[] a, int offa, long[] b, int offb, long[] y, int offy)
        {
            NativeMethods.mul_s64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, long alpha, long[] y, int offy)
        {
            NativeMethods.divc_ip_s64(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit signed integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, long[] x, int offx, long alpha, long[] y, int offy)
        {
            NativeMethods.divc_s64(length, x, offx, alpha, y, offy);
        }


        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.addc_ip_u64(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, ulong[] x, int offx, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.addc_u64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.add_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.add_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.subc_ip_u64(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, ulong[] x, int offx, [In] ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.subc_u64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.sub_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.sub_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.mulc_ip_u64(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of 64-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, ulong[] x, int offx, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.mulc_u64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            NativeMethods.mul_ip_u64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, ulong[] a, int offa, ulong[] b, int offb, ulong[] y, int offy)
        {
            NativeMethods.mul_u64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.divc_ip_u64(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of 64-bit unsigned integers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, ulong[] x, int offx, ulong alpha, ulong[] y, int offy)
        {
            NativeMethods.divc_u64(length, x, offx, alpha, y, offy);
        }


        /// <summary>
        /// Computes the absolute value of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = Math.Abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, float[] y, int offy)
        {
            NativeMethods.abs_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes the absolute value of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The array that receives the data.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.abs_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Abs(int, float[], int, float[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Abs(int, float[], int, float[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Abs(int, float[], int, float[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient for <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/> and <paramref name="dy"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>dx[i] += x[i] == y[i] ? dy[i] : -dy[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AbsGradient(int length, float[] x, float[] dx, int offx, bool cleardx, float[] y, float[] dy, int offy)
        {
            NativeMethods.abs_gradient_f32(length, x, dx, offx, cleardx, y, dy, offy);
        }
        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, float alpha, float[] y, int offy)
        {
            NativeMethods.addc_ip_f32(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, float[] x, int offx, float alpha, float[] y, int offy)
        {
            NativeMethods.addc_f32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.add_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.add_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] float alpha, float[] y, int offy)
        {
            NativeMethods.subc_ip_f32(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, float[] x, int offx, [In] float alpha, float[] y, int offy)
        {
            NativeMethods.subc_f32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.sub_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.sub_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, float alpha, float[] y, int offy)
        {
            NativeMethods.mulc_ip_f32(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of single-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, float[] x, int offx, float alpha, float[] y, int offy)
        {
            NativeMethods.mulc_f32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.mul_ip_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, float[] a, int offa, float[] b, int offb, float[] y, int offy)
        {
            NativeMethods.mul_f32(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, float alpha, float[] y, int offy)
        {
            NativeMethods.divc_ip_f32(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of single-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, float[] x, int offx, float alpha, float[] y, int offy)
        {
            NativeMethods.divc_f32(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, float[] y, int offy)
        {
            NativeMethods.sqrt_ip_f32(length, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of single-precision floating point numbers not in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.sqrt_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.log_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an exponential of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.exp_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a sines of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.sin_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Sin(int, float[], int, float[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Sin(int, float[], int, float[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="dy">The array that contains gradient <see cref="Sin(int, float[], int, float[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SinGradient(int length, float[] x, float[] dx, int offx, bool cleardx, float[] dy, int offdy)
        {
            NativeMethods.sin_gradient_f32(length, x, dx, offx, cleardx, dy, offdy);
        }

        /// <summary>
        /// Computes a cosines of elements of an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, float[] x, int offx, float[] y, int offy)
        {
            NativeMethods.cos_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Cos(int, float[], int, float[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Cos(int, float[], int, float[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="dy">The array that contains gradient <see cref="Cos(int, float[], int, float[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CosGradient(int length, float[] x, float[] dx, int offx, bool cleardx, float[] dy, int offdy)
        {
            NativeMethods.cos_gradient_f32(length, x, dx, offx, cleardx, dy, offdy);
        }

        /// <summary>
        /// Computes the L1-Norm (sum of magnitudes) of the array of single-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L1-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float L1Norm(int length, float[] x, int offx)
        {
            return NativeMethods.nrm1_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the L2-Norm (Euclidian norm) of the array of single-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L2-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float L2Norm(int length, float[] x, int offx)
        {
            return NativeMethods.nrm2_f32(length, x, offx);
        }

        /// <summary>
        /// Computes the Manhattan distance between elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Manhattan distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum(abs(x[i] - y[i])).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ManhattanDistance(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.manhattan_distance_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum((x[i] - y[i])^2).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float EuclideanDistanceSquared(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.euclidean_distance_squared_f32(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the Euclidean distance between elements of two arrays of single-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sqrt(sum((x[i] - y[i])^2)).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float EuclideanDistance(int length, float[] x, int offx, float[] y, int offy)
        {
            return NativeMethods.euclidean_distance_f32(length, x, offx, y, offy);
        }


        /// <summary>
        /// Computes the absolute value of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = Math.Abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, double[] y, int offy)
        {
            NativeMethods.abs_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes the absolute value of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The array that receives the data.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.abs_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Abs(int, double[], int, double[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Abs(int, double[], int, double[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Abs(int, double[], int, double[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient for <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/> and <paramref name="dy"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>dx[i] += x[i] == y[i] ? dy[i] : -dy[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AbsGradient(int length, double[] x, double[] dx, int offx, bool cleardx, double[] y, double[] dy, int offy)
        {
            NativeMethods.abs_gradient_f64(length, x, dx, offx, cleardx, y, dy, offy);
        }
        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, double alpha, double[] y, int offy)
        {
            NativeMethods.addc_ip_f64(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, double[] x, int offx, double alpha, double[] y, int offy)
        {
            NativeMethods.addc_f64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.add_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.add_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] double alpha, double[] y, int offy)
        {
            NativeMethods.subc_ip_f64(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, double[] x, int offx, [In] double alpha, double[] y, int offy)
        {
            NativeMethods.subc_f64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.sub_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.sub_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, double alpha, double[] y, int offy)
        {
            NativeMethods.mulc_ip_f64(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of double-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, double[] x, int offx, double alpha, double[] y, int offy)
        {
            NativeMethods.mulc_f64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.mul_ip_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, double[] a, int offa, double[] b, int offb, double[] y, int offy)
        {
            NativeMethods.mul_f64(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, double alpha, double[] y, int offy)
        {
            NativeMethods.divc_ip_f64(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of double-precision floating point numbers by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, double[] x, int offx, double alpha, double[] y, int offy)
        {
            NativeMethods.divc_f64(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, double[] y, int offy)
        {
            NativeMethods.sqrt_ip_f64(length, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of double-precision floating point numbers not in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.sqrt_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.log_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an exponential of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.exp_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a sines of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.sin_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Sin(int, double[], int, double[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Sin(int, double[], int, double[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="dy">The array that contains gradient <see cref="Sin(int, double[], int, double[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SinGradient(int length, double[] x, double[] dx, int offx, bool cleardx, double[] dy, int offdy)
        {
            NativeMethods.sin_gradient_f64(length, x, dx, offx, cleardx, dy, offdy);
        }

        /// <summary>
        /// Computes a cosines of elements of an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, double[] x, int offx, double[] y, int offy)
        {
            NativeMethods.cos_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Cos(int, double[], int, double[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Cos(int, double[], int, double[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="dy">The array that contains gradient <see cref="Cos(int, double[], int, double[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CosGradient(int length, double[] x, double[] dx, int offx, bool cleardx, double[] dy, int offdy)
        {
            NativeMethods.cos_gradient_f64(length, x, dx, offx, cleardx, dy, offdy);
        }

        /// <summary>
        /// Computes the L1-Norm (sum of magnitudes) of the array of double-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L1-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double L1Norm(int length, double[] x, int offx)
        {
            return NativeMethods.nrm1_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the L2-Norm (Euclidian norm) of the array of double-precision floating point numbers elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L2-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double L2Norm(int length, double[] x, int offx)
        {
            return NativeMethods.nrm2_f64(length, x, offx);
        }

        /// <summary>
        /// Computes the Manhattan distance between elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Manhattan distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum(abs(x[i] - y[i])).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ManhattanDistance(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.manhattan_distance_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum((x[i] - y[i])^2).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double EuclideanDistanceSquared(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.euclidean_distance_squared_f64(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the Euclidean distance between elements of two arrays of double-precision floating point numbers.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sqrt(sum((x[i] - y[i])^2)).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double EuclideanDistance(int length, double[] x, int offx, double[] y, int offy)
        {
            return NativeMethods.euclidean_distance_f64(length, x, offx, y, offy);
        }


        [SuppressUnmanagedCodeSecurity]
        private static class NativeMethods
        {
            private const string DllName = "Genix.Core.Native.dll";

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_s32(int n, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_s32(int n, [In] int[] a, int offa, [Out] int[] y, int offy);


            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_s32(int n, [In] int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_s32(int n, [In] int[] x, int offx, [In] int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_s32(int n, [In] int[] x, int offx, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_s32(int n, [In] int[] a, int offa, [In] int[] b, int offb, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_s32(int n, int a, [In, Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_s32(int n, [In] int[] x, int offx, int a, [Out] int[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_u32(int n, [In] uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_u32(int n, [In] uint[] x, int offx, [In] uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_u32(int n, [In] uint[] x, int offx, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_u32(int n, [In] uint[] a, int offa, [In] uint[] b, int offb, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_u32(int n, uint a, [In, Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_u32(int n, [In] uint[] x, int offx, uint a, [Out] uint[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_s64(int n, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_s64(int n, [In] long[] a, int offa, [Out] long[] y, int offy);


            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_s64(int n, [In] long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_s64(int n, [In] long[] x, int offx, [In] long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_s64(int n, [In] long[] x, int offx, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_s64(int n, [In] long[] a, int offa, [In] long[] b, int offb, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_s64(int n, long a, [In, Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_s64(int n, [In] long[] x, int offx, long a, [Out] long[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_u64(int n, [In] ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_u64(int n, [In] ulong[] x, int offx, [In] ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_u64(int n, [In] ulong[] x, int offx, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_u64(int n, [In] ulong[] a, int offa, [In] ulong[] b, int offb, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_u64(int n, ulong a, [In, Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_u64(int n, [In] ulong[] x, int offx, ulong a, [Out] ulong[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_f32(int n, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_f32(int n, [In] float[] a, int offa, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_gradient_f32(
                int n,
                [In] float[] x,
                [Out] float[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] float[] y,
                [In] float[] dy,
                int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_f32(int n, [In] float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_f32(int n, [In] float[] x, int offx, [In] float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_f32(int n, [In] float[] a, int offa, [In] float[] b, int offb, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_f32(int n, float a, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_f32(int n, [In] float[] x, int offx, float a, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_ip_f32(int n, [In, Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_gradient_f32(
                int n,
                [In] float[] x,
                [Out] float[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] float[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_f32(int n, [In] float[] x, int offx, [Out] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_gradient_f32(
                int n,
                [In] float[] x,
                [Out] float[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] float[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern float nrm1_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern float nrm2_f32(int n, [In] float[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern float manhattan_distance_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern float euclidean_distance_squared_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern float euclidean_distance_f32(int n, [In] float[] x, int offx, [In] float[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_f64(int n, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_f64(int n, [In] double[] a, int offa, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_gradient_f64(
                int n,
                [In] double[] x,
                [Out] double[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] double[] y,
                [In] double[] dy,
                int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_f64(int n, [In] double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_f64(int n, [In] double[] x, int offx, [In] double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_f64(int n, [In] double[] a, int offa, [In] double[] b, int offb, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_f64(int n, double a, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_f64(int n, [In] double[] x, int offx, double a, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_ip_f64(int n, [In, Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_gradient_f64(
                int n,
                [In] double[] x,
                [Out] double[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] double[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_f64(int n, [In] double[] x, int offx, [Out] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_gradient_f64(
                int n,
                [In] double[] x,
                [Out] double[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] double[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern double nrm1_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern double nrm2_f64(int n, [In] double[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern double manhattan_distance_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern double euclidean_distance_squared_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern double euclidean_distance_f64(int n, [In] double[] x, int offx, [In] double[] y, int offy);
        }
    }
}