// -----------------------------------------------------------------------
// <copyright file="Statistic.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 10/16/2018 7:19:14 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Core
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Provides statistical methods for numeric vectors manipulation.
    /// </summary>
    [CLSCompliant(false)]
    public static class Statistic
    {

        /// <summary>
        /// Computes the first derivative of elements in array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 8-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 8-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static byte[] Derivative(this byte[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            byte[] dst = new byte[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (byte)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 8-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 8-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 8-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static byte[] SecondDerivative(this byte[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            byte[] dst = new byte[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (byte)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 8-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, byte[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            byte a = x[offx];
            byte b = x[offx + 1];
            x[offx] = (byte)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                byte c = x[offx + 1];
                x[offx] = (byte)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (byte)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 8-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, byte[] x, int offx, byte[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            byte a = x[offx];
            byte b = x[offx + 1];
            y[offy] = (byte)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                byte c = x[offx + 1];
                y[offy] = (byte)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (byte)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 8-bit unsigned integers.
        /// </summary>
        /// <param name="source">A sequence of 8-bit unsigned integers values to transform.</param>
        /// <returns>A sequence of 8-bit unsigned integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<byte> Smooth(this IEnumerable<byte> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<byte> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                byte prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    byte prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (byte)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        byte current = iterator.Current;
                        byte result = (byte)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (byte)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of 16-bit signed integers.
        /// </summary>
        /// <param name="source">An array of 16-bit signed integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 16-bit signed integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static short[] Derivative(this short[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            short[] dst = new short[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (short)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 16-bit signed integers.
        /// </summary>
        /// <param name="source">An array of 16-bit signed integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 16-bit signed integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static short[] SecondDerivative(this short[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            short[] dst = new short[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (short)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 16-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, short[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            short a = x[offx];
            short b = x[offx + 1];
            x[offx] = (short)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                short c = x[offx + 1];
                x[offx] = (short)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (short)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 16-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, short[] x, int offx, short[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            short a = x[offx];
            short b = x[offx + 1];
            y[offy] = (short)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                short c = x[offx + 1];
                y[offy] = (short)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (short)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 16-bit signed integers.
        /// </summary>
        /// <param name="source">A sequence of 16-bit signed integers values to transform.</param>
        /// <returns>A sequence of 16-bit signed integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<short> Smooth(this IEnumerable<short> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<short> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                short prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    short prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (short)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        short current = iterator.Current;
                        short result = (short)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (short)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 16-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 16-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static ushort[] Derivative(this ushort[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            ushort[] dst = new ushort[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (ushort)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 16-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 16-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 16-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static ushort[] SecondDerivative(this ushort[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            ushort[] dst = new ushort[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (ushort)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 16-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, ushort[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            ushort a = x[offx];
            ushort b = x[offx + 1];
            x[offx] = (ushort)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                ushort c = x[offx + 1];
                x[offx] = (ushort)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (ushort)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 16-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, ushort[] x, int offx, ushort[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            ushort a = x[offx];
            ushort b = x[offx + 1];
            y[offy] = (ushort)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                ushort c = x[offx + 1];
                y[offy] = (ushort)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (ushort)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 16-bit unsigned integers.
        /// </summary>
        /// <param name="source">A sequence of 16-bit unsigned integers values to transform.</param>
        /// <returns>A sequence of 16-bit unsigned integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<ushort> Smooth(this IEnumerable<ushort> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<ushort> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                ushort prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    ushort prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (ushort)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        ushort current = iterator.Current;
                        ushort result = (ushort)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (ushort)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of 32-bit signed integers.
        /// </summary>
        /// <param name="source">An array of 32-bit signed integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 32-bit signed integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static int[] Derivative(this int[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            int[] dst = new int[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (int)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 32-bit signed integers.
        /// </summary>
        /// <param name="source">An array of 32-bit signed integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 32-bit signed integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static int[] SecondDerivative(this int[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            int[] dst = new int[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (int)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 32-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, int[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            int a = x[offx];
            int b = x[offx + 1];
            x[offx] = (int)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                int c = x[offx + 1];
                x[offx] = (int)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (int)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 32-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, int[] x, int offx, int[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            int a = x[offx];
            int b = x[offx + 1];
            y[offy] = (int)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                int c = x[offx + 1];
                y[offy] = (int)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (int)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 32-bit signed integers.
        /// </summary>
        /// <param name="source">A sequence of 32-bit signed integers values to transform.</param>
        /// <returns>A sequence of 32-bit signed integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<int> Smooth(this IEnumerable<int> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<int> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                int prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    int prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (int)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        int current = iterator.Current;
                        int result = (int)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (int)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 32-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 32-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static uint[] Derivative(this uint[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            uint[] dst = new uint[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (uint)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 32-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 32-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 32-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static uint[] SecondDerivative(this uint[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            uint[] dst = new uint[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (uint)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 32-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, uint[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            uint a = x[offx];
            uint b = x[offx + 1];
            x[offx] = (uint)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                uint c = x[offx + 1];
                x[offx] = (uint)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (uint)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 32-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, uint[] x, int offx, uint[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            uint a = x[offx];
            uint b = x[offx + 1];
            y[offy] = (uint)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                uint c = x[offx + 1];
                y[offy] = (uint)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (uint)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 32-bit unsigned integers.
        /// </summary>
        /// <param name="source">A sequence of 32-bit unsigned integers values to transform.</param>
        /// <returns>A sequence of 32-bit unsigned integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<uint> Smooth(this IEnumerable<uint> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<uint> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                uint prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    uint prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (uint)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        uint current = iterator.Current;
                        uint result = (uint)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (uint)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of 64-bit signed integers.
        /// </summary>
        /// <param name="source">An array of 64-bit signed integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 64-bit signed integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static long[] Derivative(this long[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            long[] dst = new long[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (long)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 64-bit signed integers.
        /// </summary>
        /// <param name="source">An array of 64-bit signed integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 64-bit signed integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static long[] SecondDerivative(this long[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            long[] dst = new long[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (long)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 64-bit signed integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, long[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            long a = x[offx];
            long b = x[offx + 1];
            x[offx] = (long)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                long c = x[offx + 1];
                x[offx] = (long)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (long)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 64-bit signed integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, long[] x, int offx, long[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            long a = x[offx];
            long b = x[offx + 1];
            y[offy] = (long)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                long c = x[offx + 1];
                y[offy] = (long)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (long)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 64-bit signed integers.
        /// </summary>
        /// <param name="source">A sequence of 64-bit signed integers values to transform.</param>
        /// <returns>A sequence of 64-bit signed integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<long> Smooth(this IEnumerable<long> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<long> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                long prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    long prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (long)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        long current = iterator.Current;
                        long result = (long)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (long)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 64-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 64-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static ulong[] Derivative(this ulong[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            ulong[] dst = new ulong[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (ulong)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of 64-bit unsigned integers.
        /// </summary>
        /// <param name="source">An array of 64-bit unsigned integers. values to calculate the first derivative of.</param>
        /// <returns>An array of 64-bit unsigned integers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static ulong[] SecondDerivative(this ulong[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            ulong[] dst = new ulong[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (ulong)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 64-bit unsigned integers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, ulong[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            ulong a = x[offx];
            ulong b = x[offx + 1];
            x[offx] = (ulong)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                ulong c = x[offx + 1];
                x[offx] = (ulong)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (ulong)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of 64-bit unsigned integers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, ulong[] x, int offx, ulong[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            ulong a = x[offx];
            ulong b = x[offx + 1];
            y[offy] = (ulong)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                ulong c = x[offx + 1];
                y[offy] = (ulong)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (ulong)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of 64-bit unsigned integers.
        /// </summary>
        /// <param name="source">A sequence of 64-bit unsigned integers values to transform.</param>
        /// <returns>A sequence of 64-bit unsigned integers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<ulong> Smooth(this IEnumerable<ulong> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<ulong> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                ulong prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    ulong prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (ulong)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        ulong current = iterator.Current;
                        ulong result = (ulong)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (ulong)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of single-precision floating point numbers.
        /// </summary>
        /// <param name="source">An array of single-precision floating point numbers. values to calculate the first derivative of.</param>
        /// <returns>An array of single-precision floating point numbers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static float[] Derivative(this float[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            float[] dst = new float[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (float)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of single-precision floating point numbers.
        /// </summary>
        /// <param name="source">An array of single-precision floating point numbers. values to calculate the first derivative of.</param>
        /// <returns>An array of single-precision floating point numbers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static float[] SecondDerivative(this float[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            float[] dst = new float[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (float)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of single-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, float[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            float a = x[offx];
            float b = x[offx + 1];
            x[offx] = (float)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                float c = x[offx + 1];
                x[offx] = (float)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (float)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of single-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, float[] x, int offx, float[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            float a = x[offx];
            float b = x[offx + 1];
            y[offy] = (float)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                float c = x[offx + 1];
                y[offy] = (float)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (float)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of single-precision floating point numbers.
        /// </summary>
        /// <param name="source">A sequence of single-precision floating point numbers values to transform.</param>
        /// <returns>A sequence of single-precision floating point numbers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<float> Smooth(this IEnumerable<float> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<float> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                float prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    float prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (float)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        float current = iterator.Current;
                        float result = (float)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (float)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

        /// <summary>
        /// Computes the first derivative of elements in array of double-precision floating point numbers.
        /// </summary>
        /// <param name="source">An array of double-precision floating point numbers. values to calculate the first derivative of.</param>
        /// <returns>An array of double-precision floating point numbers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static double[] Derivative(this double[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            double[] dst = new double[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (double)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of double-precision floating point numbers.
        /// </summary>
        /// <param name="source">An array of double-precision floating point numbers. values to calculate the first derivative of.</param>
        /// <returns>An array of double-precision floating point numbers that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static double[] SecondDerivative(this double[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            double[] dst = new double[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (double)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of double-precision floating point numbers in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, double[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            double a = x[offx];
            double b = x[offx + 1];
            x[offx] = (double)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                double c = x[offx + 1];
                x[offx] = (double)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (double)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of double-precision floating point numbers not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, double[] x, int offx, double[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            double a = x[offx];
            double b = x[offx + 1];
            y[offy] = (double)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                double c = x[offx + 1];
                y[offy] = (double)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (double)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of double-precision floating point numbers.
        /// </summary>
        /// <param name="source">A sequence of double-precision floating point numbers values to transform.</param>
        /// <returns>A sequence of double-precision floating point numbers whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<double> Smooth(this IEnumerable<double> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<double> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                double prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    double prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (double)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        double current = iterator.Current;
                        double result = (double)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (double)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }

    }
}
