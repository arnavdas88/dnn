<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
// -----------------------------------------------------------------------
// <copyright file="Vectors.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

<#
    MethodDescriptor[] methods = new MethodDescriptor[]
        {
        new MethodDescriptor()
        {
            Name = "Copy",
            NativeName = "copy",
            Argument = ArgumentType.Vector,
            Summary = "Copies a range of {0} from an array starting at the specified source index to another array starting at the specified destination index",
            HasIncrement = true,
            Op = "y = x"
            },
        new MethodDescriptor()
        {
            Name = "Move",
            NativeName = "move",
            Argument = ArgumentType.Vector,
            Summary = "Copies an overlapping range of {0} from an array starting at the specified source index to another array starting at the specified destination index",
            Op = "y = x",
            },
        new MethodDescriptor()
        {
            Name = "Set",
            NativeName = "set",
            Argument = ArgumentType.Constant,
            Summary = "Sets all elements in the array of {0} starting at the specified source index to the specified value",
            HasIncrement = true,
            Op = "y[i] = a",
            },
        new MethodDescriptor()
        {
            Name = "Swap",
            NativeName = "swap",
            Argument = ArgumentType.Vector,
            Summary = "Swaps elements of two arrays of {0}",
            Op = "y = x, x = y",
            },
        new MethodDescriptor()
        {
            Name = "Abs",
            NativeName = "abs",
            Argument = ArgumentType.Vector,
            Summary = "Computes an absolute value of elements of an array of {0}",
            HasInPlace = true,
            HasGradient = true,
            Op = "y = abs(x)",
            OpInPlace = "y = abs(y)",
            SupportedTypes = "sbyte;short;int;long;float;double",
            },
        new MethodDescriptor()
        {
            Name = "AddC",
            NativeName = "addc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Adds a constant value to each element of an array of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y[i] = x[i] + a",
            OpInPlace = "y[i] += a",
            },
        new MethodDescriptor()
        {
            Name = "SubC",
            NativeName = "subc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Subtracts a constant value from each element of an array of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y[i] = x[i] - a",
            OpInPlace = "y[i] -= a",
            },
        new MethodDescriptor()
        {
            Name = "MulC",
            NativeName = "mulc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Multiplies each element of an array of {0} by a constant value",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y[i] = x[i] * a",
            OpInPlace = "y[i] *= a",
            },
        new MethodDescriptor()
        {
            Name = "DivC",
            NativeName = "divc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Divides each element of an array of {0} by a constant value",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y[i] = x[i] / a",
            OpInPlace = "y[i] /= a",
            },
        new MethodDescriptor()
        {
            Name = "Add",
            NativeName = "add",
            Argument = ArgumentType.TwoVectors,
            Summary = "Adds the elements of two arrays of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y = a + b",
            OpInPlace = "y += x",
            },
        new MethodDescriptor()
        {
            Name = "Sub",
            NativeName = "sub",
            Argument = ArgumentType.TwoVectors,
            Summary = "Subtracts the elements of two arrays of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y = a - b",
            OpInPlace = "y -= x",
            },
        new MethodDescriptor()
        {
            Name = "Mul",
            NativeName = "mul",
            Argument = ArgumentType.TwoVectors,
            Summary = "Multiplies the elements of two arrays of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y = a * b",
            OpInPlace = "y *= x",
            },
        new MethodDescriptor()
        {
            Name = "Div",
            NativeName = "div",
            Argument = ArgumentType.TwoVectors,
            Summary = "Divides the elements of two arrays of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y = a / b",
            OpInPlace = "y /= x",
            },
        new MethodDescriptor()
        {
            Name = "Square",
            NativeName = "sqr",
            Argument = ArgumentType.Vector,
            Summary = "Squares elements of an array of {0}",
            HasInPlace = true,
            Op = "y[i] = x[i] * x[i]",
            OpInPlace = "y[i] = y[i] * y[i]",
            },
        new MethodDescriptor()
        {
            Name = "Sqrt",
            NativeName = "sqrt",
            Argument = ArgumentType.Vector,
            Summary = "Computes a square root of elements of an array of {0}",
            HasInPlace = true,
            Op = "y[i] = sqrt(x[i])",
            OpInPlace = "y[i] = sqrt(y[i])",
            SupportedTypes = "float;double",
            },
        new MethodDescriptor()
        {
            Name = "Log",
            NativeName = "log",
            Argument = ArgumentType.Vector,
            Summary = "Computes a natural logarithm of elements of an array of {0}",
            HasInPlace = true,
            Op = "y[i] = ln(x[i])",
            OpInPlace = "y[i] = ln(y[i])",
            SupportedTypes = "float;double",
            },
        new MethodDescriptor()
        {
            Name = "Exp",
            NativeName = "exp",
            Argument = ArgumentType.Vector,
            Summary = "Computes an exponential logarithm of elements of an array of {0}",
            HasInPlace = true,
            Op = "y[i] = exp(x[i])",
            OpInPlace = "y[i] = exp(y[i])",
            SupportedTypes = "float;double",
            },
        new MethodDescriptor()
        {
            Name = "Sin",
            NativeName = "sin",
            Argument = ArgumentType.Vector,
            Summary = "Computes a sine logarithm of elements of an array of {0}",
            HasInPlace = true,
            HasGradient = true,
            Op = "y[i] = sin(x[i])",
            OpInPlace = "y[i] = sin(y[i])",
            SupportedTypes = "float;double",
            },
        new MethodDescriptor()
        {
            Name = "Cos",
            NativeName = "cos",
            Argument = ArgumentType.Vector,
            Summary = "Computes a cosine logarithm of elements of an array of {0}",
            HasInPlace = true,
            HasGradient = true,
            Op = "y[i] = cos(x[i])",
            OpInPlace = "y[i] = cos(y[i])",
            SupportedTypes = "float;double",
            },
        new MethodDescriptor()
        {
            Name = "ArgMin",
            NativeName = "argmin",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Returns the position of minimum value in the array of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            HasIncrement = true,
            ReturnType = "int",
            Returns = "The zero-based index of minimum value in the array.",
            OpInPlace = "argmin(x)",
            },
        new MethodDescriptor()
        {
            Name = "Min",
            NativeName = "_min",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Returns the minimum value in the array of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            HasIncrement = true,
            Returns = "The minimum value in the array.",
            OpInPlace = "x[argmin(x)]",
            },
        new MethodDescriptor()
        {
            Name = "ArgMax",
            NativeName = "argmax",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Returns the position of maximum value in the array of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            HasIncrement = true,
            ReturnType = "int",
            Returns = "The zero-based index of maximum value in the array.",
            OpInPlace = "argmax(x)",
            },
        new MethodDescriptor()
        {
            Name = "Max",
            NativeName = "_max",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Returns the maximum value in the array of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            HasIncrement = true,
            Returns = "The maximum value in the array.",
            OpInPlace = "x[argmax(x)]",
            },
        new MethodDescriptor()
        {
            Name = "MinC",
            NativeName = "minc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Computes a smaller of each element of an array of {0} and a constant value",
            HasInPlace = true,
            Op = "y[i] = min(y[i], a)",
            OpInPlace = "y[i] = min(x[i], a)",
            },
        new MethodDescriptor()
        {
            Name = "Min",
            NativeName = "min",
            Argument = ArgumentType.TwoVectors,
            Summary = "Computes a smaller of each element of two arrays of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y = min(a, b)",
            OpInPlace = "y = min(x, y)",
            },
        new MethodDescriptor()
        {
            Name = "MaxC",
            NativeName = "maxc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Computes a larger of each element of an array of {0} and a constant value",
            HasInPlace = true,
            Op = "y[i] = max(y[i], a)",
            OpInPlace = "y[i] = max(x[i], a)",
            },
        new MethodDescriptor()
        {
            Name = "Max",
            NativeName = "max",
            Argument = ArgumentType.TwoVectors,
            Summary = "Computes a larger of each element of two arrays of {0}",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y = max(a, b)",
            OpInPlace = "y = max(x, y)",
        },
        new MethodDescriptor()
        {
            Name = "SwapBits",
            NativeName = "swap_bits",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Reverses the order of groups of bits in each byte an array of {0}",
            HasInPlace = true,
            ConstantName = "bitCount",
            ConstantType = "int",
            ConstantDescription = "The number of bits in a group (1, 2, or 4).",
            Op = "{TBD}",
            OpInPlace = "{TBD}",
            SupportedTypes = "uint;ulong",
        },
        new MethodDescriptor()
        {
            Name = "Not",
            NativeName = "not",
            Argument = ArgumentType.Vector,
            Summary = "Performs logical NOT on array of {0}",
            HasInPlace = true,
            Op = "y[i] = ~x[i]",
            OpInPlace = "y[i] == ~y[i]",
            SupportedTypes = "uint;ulong",
        },
        new MethodDescriptor()
        {
            Name = "OrC",
            NativeName = "orc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Performs logical OR operation between elements of an array of {0} and a constant value",
            HasInPlace = true,
            Op = "y[i] = x[i] | a",
            OpInPlace = "y[i] |= a",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Or",
            NativeName = "or",
            Argument = ArgumentType.TwoVectors,
            Summary = "Performs logical OR operation between elements of two arrays of {0}",
            HasInPlace = true,
            Op = "y = a | b",
            OpInPlace = "y |= x",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Or",
            NativeName = "or3",
            Argument = ArgumentType.ThreeVectors,
            Summary = "Performs logical OR operation between elements of three arrays of {0}",
            Op = "y = a | b | c",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Or",
            NativeName = "or4",
            Argument = ArgumentType.FourVectors,
            Summary = "Performs logical OR operation between elements of four arrays of {0}",
            Op = "y = a | b | c | d",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "AndC",
            NativeName = "andc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Performs logical AND operation between elements of an array of {0} and a constant value",
            HasInPlace = true,
            HasIncrement = true,
            Op = "y[i] = x[i] &amp; a",
            OpInPlace = "y[i] &amp;= a",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "And",
            NativeName = "and",
            Argument = ArgumentType.TwoVectors,
            Summary = "Performs logical AND operation between elements of two arrays of {0}",
            HasInPlace = true,
            Op = "y = a &amp; b",
            OpInPlace = "y &amp;= x",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "And",
            NativeName = "and3",
            Argument = ArgumentType.ThreeVectors,
            Summary = "Performs logical AND operation between elements of three arrays of {0}",
            Op = "y = a &amp; b &amp; c",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "And",
            NativeName = "and4",
            Argument = ArgumentType.FourVectors,
            Summary = "Performs logical AND operation between elements of four arrays of {0}",
            Op = "y = a &amp; b &amp; c &amp; d",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "XorC",
            NativeName = "xorc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Performs logical XOR operation between elements of an array of {0} and a constant value",
            HasInPlace = true,
            Op = "y[i] = x[i] ^ a",
            OpInPlace = "y[i] ^= a",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Xor",
            NativeName = "xor",
            Argument = ArgumentType.TwoVectors,
            Summary = "Performs logical XOR operation between elements of two arrays of {0}",
            HasInPlace = true,
            Op = "y = a ^ b",
            OpInPlace = "y ^= x",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "XandC",
            NativeName = "xandc",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Performs logical XAND (A AND NOT B) operation between elements of an array of {0} and a constant value",
            HasInPlace = true,
            Op = "y[i] = x[i] &amp; ~a",
            OpInPlace = "y[i] &amp;= ~a",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Xand",
            NativeName = "xand",
            Argument = ArgumentType.TwoVectors,
            Summary = "Performs logical XAND (A AND NOT B) operation between elements of two arrays of {0}",
            HasInPlace = true,
            Op = "y = a &amp; ~b",
            OpInPlace = "y &amp;= ~x",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Shr",
            NativeName = "shr",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Shifts bits in the array of {0} to the right (from MSB to LSB)",
            ConstantName = "shift",
            ConstantType = "int",
            ConstantDescription = "The number of bits by which the method shifts each element.",
            HasInPlace = true,
            Op = "y = x &gt;&gt; shift",
            OpInPlace = "y &gt;&gt;= shift",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Shl",
            NativeName = "shl",
            Argument = ArgumentType.ConstantAndVector,
            Summary = "Shifts bits in the array of {0} to the left (from LSB to MSB)",
            ConstantName = "shift",
            ConstantType = "int",
            ConstantDescription = "The number of bits by which the method shifts each element.",
            HasInPlace = true,
            Op = "y = x &lt;&lt; shift",
            OpInPlace = "y &lt;&lt;= shift",
            SupportedTypes = "uint;ulong",
            },
        new MethodDescriptor()
        {
            Name = "Sum",
            NativeName = "sum",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Computes the sum of all elements in the array of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            Returns = "The sum of elements in the array.",
            OpInPlace = "sum(x[i])"
            },
        new MethodDescriptor()
        {
            Name = "CumulativeSum",
            NativeName = "cumulative_sum",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Computes the cumulative sum of elements of an array of {0}",
            HasInPlace = true,
            Returns = "The sum of elements in <paramref name=\"x\"/>",
            Op = "sum(x[i])",
            OpInPlace = "sum(x[i])"
            },
        new MethodDescriptor()
        {
            Name = "Variance",
            NativeName = "variance",
            Argument = ArgumentType.VectorAggregate,
            Summary = "Computes the variance of all elements in the array of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            Returns = "The variance of elements in the array.",
            OpInPlace = "variance(x)",
            SupportedTypes = "float;double",
            },
        new MethodDescriptor()
        {
            Name = "HammingDistance",
            NativeName = "hamming_distance",
            Argument = ArgumentType.TwoVectorsAggregate,
            Summary = "Computes the Hamming distance between the two arrays of {0}",
            HasInPlace = true,
            HasNotInPlace = false,
            Returns = "The computed Hamming distance between the two arrays of {0}.",
            OpInPlace = "popcnt(a ^ b)",
            SupportedTypes = "uint;ulong",
            },
        };
#>

namespace Genix.Core
{
    using System;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;

    /// <summary>
    /// Provides mathematical methods for numeric vectors manipulation.
    /// </summary>
    [CLSCompliant(false)]
    public static class Vectors
    {
<#
	Tuple<string, string, string, bool, bool>[] types = 
	{
		Tuple.Create("sbyte", "s8", "8-bit signed integers", true, false),
		Tuple.Create("byte", "u8", "8-bit unsigned integers", false, false),
		Tuple.Create("short", "s16", "16-bit signed integers", true, false),
		Tuple.Create("ushort", "u16", "16-bit unsigned integers", false, false),
		Tuple.Create("int", "s32", "32-bit signed integers", true, false),
		Tuple.Create("uint", "u32", "32-bit unsigned integers", false, false),
		Tuple.Create("long", "s64", "64-bit signed integers", true, false),
		Tuple.Create("ulong", "u64", "64-bit unsigned integers", false, false),
		Tuple.Create("float", "f32", "single-precision floating point numbers", true, true),
		Tuple.Create("double", "f64", "double-precision floating point numbers", true, true),
	};

	foreach (Tuple<string, string, string, bool, bool> type in types)
	{
		string typeName = type.Item1;
		string nativeSuffix = type.Item2;
		string typeDescription = type.Item3;
		bool isSigned = type.Item4;
		bool isFloating = type.Item5;
#>

        /// <summary>
        /// Creates an array of <#=typeDescription#> with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#>[] Create(int length, <#=typeName#> value)
        {
            <#=typeName#>[] a = new <#=typeName#>[length];
            if (value != default(<#=typeName#>))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of <#=typeDescription#> contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.compare_<#=nativeSuffix#>(length, x, offx, y, offy) == 0;
        }
<#
    foreach (MethodDescriptor method in methods.Where(x => string.IsNullOrEmpty(x.SupportedTypes) || x.SupportedTypes.Split(new char[] {';'}).Contains(typeName)))
    {
        switch (method.Argument) {
            case ArgumentType.Constant:
#>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, 0);
        }
<#            if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy, int incy)
        {
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, 0, incy);
        }
<#            }
              break;
            case ArgumentType.Vector:
                if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
<# if (!string.IsNullOrEmpty(method.Returns)) { #>
        /// <returns><#=method.Returns#></returns>
<# } #>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, y, 0);
        }
<#              } #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, x, 0, y, 0);
        }
<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=typeName#>[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, x, 0, incx, y, 0, incy);
        }
<#             }
               if (method.HasGradient && (typeName == "float" || typeName == "double")) { #>

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient <see cref="<#=method.Name#>(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting element position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>Gradient(int length, <#=typeName#>[] x, <#=typeName#>[] dx, int offx, bool cleardx, <#=typeName#>[] y, <#=typeName#>[] dy, int offdy)
        {
            NativeMethods.<#=method.NativeName#>_gradient_<#=nativeSuffix#>(length, x, dx, offx, cleardx, y, dy, offdy);
        }
<#            }
              break;
            case ArgumentType.VectorAggregate:
               if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, x, offx);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x)
        {
            return NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, x, 0);
        }

<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, x, offx, incx);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x, int incx)
        {
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, x, 0, incx);
        }
<#              }
            }
            if (method.HasNotInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x, <#=typeName#>* y)
        {
            return NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, x, 0, y, 0);
        }

<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=typeName#>[] y, int offy, int incy)
        {
            Debug.Assert(x.Length > offx + ((length - 1) * incx), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=typeName#>* y, int incy)
        {
            return NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, x, 0, incx, y, 0, incy);
        }
<#                  }
                }
                break;
            case ArgumentType.TwoVectorsAggregate:
               if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb)
        {
            Debug.Assert(a.Length > offa + length - 1, "The source array should be big enough.");
            Debug.Assert(b.Length > offb + length - 1, "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, a, offa, b, offb);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b)
        {
            return NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, a, 0, b, 0);
        }

<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, int inca, <#=typeName#>[] b, int offb, int incb)
        {
            Debug.Assert(a.Length > offa + ((length - 1) * inca), "The source array should be big enough.");
            Debug.Assert(b.Length > offb + ((length - 1) * incb), "The source array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, a, offa, inca, b, offb, incb);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.OpInPlace#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, int inca, <#=typeName#>* b, int incb)
        {
            return NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, a, 0, inca, b, 0, incb);
        }
<#              }
            }
            if (method.HasNotInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offa">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(a.Length > offa + length - 1, "The source array should be big enough.");
            Debug.Assert(b.Length > offb + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* y)
        {
            return NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, 0, b, 0, y, 0);
        }

<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>[] a, int offa, int inca, <#=typeName#>[] b, int offb, int incb, <#=typeName#>[] y, int offy, int incy)
        {
            Debug.Assert(a.Length > offa + ((length - 1) * inca), "The source array should be big enough.");
            Debug.Assert(b.Length > offb + ((length - 1) * incb), "The source array should be big enough.");
            Debug.Assert(y.Length > offy + ((length - 1) * incy), "The destination array should be big enough.");
            return NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The first source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <returns><#=method.Returns#></returns>
        /// <remarks>
        /// <para>The method performs operation defined as <c><#=method.Op#></c>.</para>
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe <#=method.GetReturnType(typeName)#> <#=method.Name#>(int length, <#=typeName#>* a, int inca, <#=typeName#>* b, int incb, <#=typeName#>* y, int incy)
        {
            return NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }
<#                  }
                }
                break;
            case ArgumentType.ConstantAndVector:
                if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, 0);
        }
<#                  if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, <#=method.ConstantName#>, y, 0, incy);
        }
<#                  }
                } #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, x, offx, <#=method.ConstantName#>, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, x, 0, <#=method.ConstantName#>, y, 0);
        }
<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, x, offx, incx, <#=method.ConstantName#>, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="<#=method.ConstantName#>"><#=method.ConstantDescription#></param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, x, 0, incx, <#=method.ConstantName#>, y, 0, incy);
        }
<#              }
                break;
            case ArgumentType.TwoVectors:
                if (method.HasInPlace) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The source and destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_ip_<#=nativeSuffix#>(length, x, 0, y, 0);
        }
<#                  if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] x, int offx, int incx, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, x, offx, incx, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="incx">The increment for the elements of <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.OpInPlace#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* x, int incx, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(length, x, 0, incx, y, 0, incy);
        }
<#                  }
                } #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#><#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, 0, b, 0, y, 0);
        }
<#              if (method.HasIncrement) { #>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, int inca, <#=typeName#>[] b, int offb, int incb, <#=typeName#>[] y, int offy, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, a, offa, inca, b, offb, incb, y, offy, incy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#> with increment<#=method.HasInPlace ? " not-in-place" : ""#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="inca">The increment for the elements of <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="incb">The increment for the elements of <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="incy">The increment for the elements of <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, int inca, <#=typeName#>* b, int incb, <#=typeName#>* y, int incy)
        {
            NativeMethods.<#=method.NativeName#>_inc_<#=nativeSuffix#>(length, a, 0, inca, b, 0, incb, y, 0, incy);
        }
<#              }
                break;
            case ArgumentType.ThreeVectors:#>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] c, int offc, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, offa, b, offb, c, offc, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* c, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, 0, b, 0, c, 0, y, 0);
        }
<#              break;
            case ArgumentType.FourVectors:#>

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="offc">The starting element position in <paramref name="c"/>.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="offd">The starting element position in <paramref name="d"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=method.Name#>(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] c, int offc, <#=typeName#>[] d, int offd, <#=typeName#>[] y, int offy)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, offa, b, offb, c, offc, d, offd, y, offy);
        }

        /// <summary>
        /// <#=string.Format(method.Summary, typeDescription)#>.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="c">The third source array.</param>
        /// <param name="d">The fourth source array.</param>
        /// <param name="y">The destination array.</param>
        /// <remarks>
        /// The method performs operation defined as <c><#=method.Op#></c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void <#=method.Name#>(int length, <#=typeName#>* a, <#=typeName#>* b, <#=typeName#>* c, <#=typeName#>* d, <#=typeName#>* y)
        {
            NativeMethods.<#=method.NativeName#>_<#=nativeSuffix#>(length, a, 0, b, 0, c, 0, d, 0, y, 0);
        }
<#               break;
        }
    } 
#>

        /// <summary>
        /// Clips elements of an array of <#=typeDescription#> to a specified minimum and maximum values.
        /// </summary>
        /// <param name="length">The number of elements to clip.</param>
        /// <param name="minValue">The minimum value to clip by.</param>
        /// <param name="maxValue">The maximum value to clip by.</param>
        /// <param name="x">The source destination array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>x(offx + i) := min(max(x(offx + i), minValue), maxValue)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Clip(int length, <#=typeName#> minValue, <#=typeName#> maxValue, <#=typeName#>[] x, int offx)
        {
<#
        if (isFloating)
        {
#>
            if (!<#=typeName#>.IsNaN(minValue))
            {
                Vectors.MaxC(length, minValue, x, offx);
            }

            if (!<#=typeName#>.IsNaN(maxValue))
            {
                Vectors.MinC(length, maxValue, x, offx);
            }
<#
        }
        else
        {
#>
            Vectors.MaxC(length, minValue, x, offx);
            Vectors.MinC(length, maxValue, x, offx);
<#
        }
#>
        }

        /// <summary>
        /// Creates an array of <#=typeDescription#> initialized to one values.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="a">The allocated array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Ones(int length, out <#=typeName#>[] a)
        {
            a = new <#=typeName#>[length];
            Vectors.Set(length, 1, a, 0);
        }

        /// <summary>
        /// Copies a range of values from a array of <#=typeDescription#> starting at the specified source index
        /// to another array starting at the specified destination index
        /// specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Tile(int length, int count, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            for (int i = 0; i < count; i++, offy += length)
            {
                Vectors.Copy(length, x, offx, y, offy);
            }
        }

        /// <summary>
        /// Copies a range of values from a array of <#=typeDescription#> to another array specified number of times.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="count">The number of times to copy <paramref name="x"/>.</param>
        /// <param name="x">The source array.</param>
        /// <param name="y">The destination.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void Tile(int length, int count, <#=typeName#>* x, <#=typeName#>* y)
        {
            for (int i = 0; i < count; i++, y += length)
            {
                Vectors.Copy(length, x, y);
            }
        }

        /// <summary>
        /// Adds product of element of an array of <#=typeDescription#> and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, <#=typeName#>[] x, int offx, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.addproductc_<#=nativeSuffix#>(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of <#=typeDescription#> to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.addproduct_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, <#=typeName#>[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_<#=nativeSuffix#>(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum and maximum values in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, <#=typeName#>[] x, int offx, out <#=typeName#> min, out <#=typeName#> max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Performs thresholding of elements of an array of <#=typeDescription#>.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, <#=typeName#> threshold, <#=typeName#> value, <#=typeName#>[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_<#=nativeSuffix#>(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of <#=typeDescription#>.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, <#=typeName#> threshold, <#=typeName#> value, <#=typeName#>[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_<#=nativeSuffix#>(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of <#=typeDescription#>.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, <#=typeName#> thresholdLT, <#=typeName#> valueLT, <#=typeName#> thresholdGT, <#=typeName#> valueGT, <#=typeName#>[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_<#=nativeSuffix#>(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }
<#
        if (isFloating)
        {
#>

        /// <summary>
        /// Computes the L1-Norm (sum of magnitudes) of the array of <#=typeDescription#> elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L1-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> L1Norm(int length, <#=typeName#>[] x, int offx)
        {
            return NativeMethods.nrm1_<#=nativeSuffix#>(length, x, offx);
        }

        /// <summary>
        /// Computes the L2-Norm (Euclidian norm) of the array of <#=typeDescription#> elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L2-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> L2Norm(int length, <#=typeName#>[] x, int offx)
        {
            return NativeMethods.nrm2_<#=nativeSuffix#>(length, x, offx);
        }

        /// <summary>
        /// Computes the Manhattan distance between elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Manhattan distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum(abs(x[i] - y[i])).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> ManhattanDistance(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.manhattan_distance_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum((x[i] - y[i])^2).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> EuclideanDistanceSquared(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.euclidean_distance_squared_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the Euclidean distance between elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sqrt(sum((x[i] - y[i])^2)).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> EuclideanDistance(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.euclidean_distance_<#=nativeSuffix#>(length, x, offx, y, offy);
        }
<#      }#>

        /// <summary>
        /// Sorts the elements in a range of elements in an array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <param name="x">The array to sort.</param>
        /// <param name="offx">The index in the <paramref name="x"/> at which sorting begins.</param>
        /// <param name="ascending"><b>true</b> to use ascending sorting order; <b>false</b> to use descending sorting order.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sort(int length, <#=typeName#>[] x, int offx, bool ascending)
        {
            NativeMethods.qsort_<#=nativeSuffix#>(length, x, offx, ascending);
        }

        /// <summary>
        /// Sorts the elements in a range of elements in a pair of arrays
        /// (one contains the keys and the other contains the corresponding items)
        /// based on the keys in the first array.
        /// </summary>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <param name="x">The array that contains the keys to sort.</param>
        /// <param name="offx">The index in the <paramref name="x"/> at which sorting begins.</param>
        /// <param name="y">The array that contains the items that correspond to each of the keys in the <paramref name="x"/>.</param>
        /// <param name="offy">The index in the <paramref name="y"/> at which sorting begins.</param>
        /// <param name="ascending"><b>true</b> to use ascending sorting order; <b>false</b> to use descending sorting order.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sort(int length, <#=typeName#>[] x, int offx, int[] y, int offy, bool ascending)
        {
            NativeMethods.qsortv_<#=nativeSuffix#>(length, x, offx, y, offy, ascending);
        }
<#  }#>

        [SuppressUnmanagedCodeSecurity]
        private static class NativeMethods
        {
            private const string DllName = "Genix.Core.Native.dll";
<#
    foreach (Tuple<string, string, string, bool, bool> type in types)
    {
        string typeName = type.Item1;
        string nativeSuffix = type.Item2;
        string typeDescription = type.Item3;
        bool isSigned = type.Item4;
        bool isFloating = type.Item5;
#>

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);
<#
    foreach (MethodDescriptor method in methods.Where(x => string.IsNullOrEmpty(x.SupportedTypes) || x.SupportedTypes.Split(new char[] {';'}).Contains(typeName)))
    {
        switch (method.Argument) {
            case ArgumentType.Constant:
#>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy);
<#              if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy, int incy);
<#              }
                break;
            case ArgumentType.Vector:
                if (method.HasInPlace) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In, Out] <#=typeName#>* y, int offy);
<#              } #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, [Out] <#=typeName#>* y, int offy);
<#              if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, int incx, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, int incx, [Out] <#=typeName#>* y, int offy, int incy);
<#              }
                if (method.HasGradient && (typeName == "float" || typeName == "double")) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_gradient_<#=nativeSuffix#>(
                int n,
                [In] <#=typeName#>[] x,
                [Out] <#=typeName#>[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] <#=typeName#>[] y,
                [In] <#=typeName#>[] dy,
                int offdy);
<#              }
                break;
            case ArgumentType.VectorAggregate:
                if (method.HasInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx);
<#                  if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, int incx);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, int incx);
<#                  }
                }
                if (method.HasNotInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, [In] <#=typeName#>* y, int offy);
<#                  if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, int incx, [In] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, int incx, [In] <#=typeName#>* y, int offy, int incy);
<#                  }
                }
                break;
            case ArgumentType.TwoVectorsAggregate:
                if (method.HasInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb);
<#                  if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, int inca, [In] <#=typeName#>[] b, int offb, int incb);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, int inca, [In] <#=typeName#>* b, int offb, int incb);
<#                  }
                }
                if (method.HasNotInPlace) { #>
            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [In] <#=typeName#>* y, int offy);
<#                  if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, int inca, [In] <#=typeName#>[] b, int offb, int incb, [In] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe <#=method.GetReturnType(typeName)#> <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, int inca, [In] <#=typeName#>* b, int offb, int incb, [In] <#=typeName#>* y, int offy, int incy);
<#                  }
                }
                break;
            case ArgumentType.ConstantAndVector:
                if (method.HasInPlace) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>* y, int offy);
<#                  if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [In, Out] <#=typeName#>* y, int offy, int incy);
<#                  }
                } #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy);
<#              if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, int incx, <#=method.ConstantType ?? typeName#> <#=method.ConstantName#>, [Out] <#=typeName#>* y, int offy, int incy);
<#              }
                break;
            case ArgumentType.TwoVectors:
                if (method.HasInPlace) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, [In, Out] <#=typeName#>* y, int offy);
<#                  if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, int incx, [In, Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>* x, int offx, int incx, [In, Out] <#=typeName#>* y, int offy, int incy);
<#                  }
                } #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [Out] <#=typeName#>* y, int offy);
<#              if (method.HasIncrement) { #>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, int inca, [In] <#=typeName#>[] b, int offb, int incb, [Out] <#=typeName#>[] y, int offy, int incy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_inc_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, int inca, [In] <#=typeName#>* b, int offb, int incb, [Out] <#=typeName#>* y, int offy, int incy);
<#              }
                break;
            case ArgumentType.ThreeVectors:#>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In] <#=typeName#>[] c, int offc, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [In] <#=typeName#>* c, int offc, [Out] <#=typeName#>* y, int offy);
<#              break;
            case ArgumentType.FourVectors:#>

            [DllImport(NativeMethods.DllName)]
            public static extern void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In] <#=typeName#>[] c, int offc, [In] <#=typeName#>[] d, int offd, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern unsafe void <#=method.NativeName#>_<#=nativeSuffix#>(int n, [In] <#=typeName#>* a, int offa, [In] <#=typeName#>* b, int offb, [In] <#=typeName#>* c, int offc, [In] <#=typeName#>* d, int offd, [Out] <#=typeName#>* y, int offy);
<#              break;
        }
    } 
#>

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_<#=nativeSuffix#>(int n, <#=typeName#> threshold, <#=typeName#> value, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_<#=nativeSuffix#>(int n, <#=typeName#> threshold, <#=typeName#> value, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_<#=nativeSuffix#>(int n, <#=typeName#> thresholdLT, <#=typeName#> valueLT, <#=typeName#> thresholdGT, <#=typeName#> valueGT, [In, Out] <#=typeName#>[] y, int offy);
<#      if (isFloating)
        {#>

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> nrm1_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> nrm2_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> manhattan_distance_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> euclidean_distance_squared_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> euclidean_distance_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);
<#      }#>

            [DllImport(NativeMethods.DllName)]
            public static extern void qsort_<#=nativeSuffix#>(
                int n,
                [In, Out] <#=typeName#>[] x,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool ascending);

            [DllImport(NativeMethods.DllName)]
            public static extern void qsortv_<#=nativeSuffix#>(
                int n,
                [In, Out] <#=typeName#>[] x,
                int offx,
                [In, Out] int[] y,
                int offy,
                [MarshalAs(UnmanagedType.Bool)] bool ascending);
<#  }#>
        }
    }
}

<#+
    enum ArgumentType
    {
        Constant = 0,
        Vector = 1,
        VectorAggregate = 2,
        TwoVectorsAggregate = 3,
        ConstantAndVector = 4,
        TwoVectors = 5,
        ThreeVectors = 6,
        FourVectors = 7,
    }

    class MethodDescriptor
    {
        public MethodDescriptor()
        {
            this.HasNotInPlace = true;
            this.ConstantName = "a";
            this.ConstantDescription = "The constant value.";
        }

        public string Name { get; set; }
        public string NativeName { get; set; }
        public ArgumentType Argument { get; set; }
        public string Summary { get; set; }
        public bool HasNotInPlace { get; set; }
        public bool HasInPlace { get; set; }
        public bool HasIncrement { get; set; }
        public bool HasGradient { get; set; }
        public string ConstantType { get; set; }
        public string ConstantName { get; set; }
        public string ConstantDescription { get; set; }
        public string ReturnType { get; set; }
        public string Returns { get; set; }
        public string Op { get; set; }
        public string OpInPlace { get; set; }
        public string SupportedTypes { get; set; }

        public string GetReturnType(string typeName)
        {
            switch (this.Name)
            {
                case "Sum":
                    if (typeName == "byte") return "uint";
                    else if (typeName == "sbyte") return "int";
                    break;
            }

            return this.ReturnType ?? typeName;
        }
    }
#>