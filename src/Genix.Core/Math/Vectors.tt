<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
// -----------------------------------------------------------------------
// <copyright file="Vectors.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Core
{
    using System;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;

    /// <summary>
    /// Provides mathematical methods for numeric vectors manipulation.
    /// </summary>
	[CLSCompliant(false)]
    public static class Vectors
    {
<#
				Tuple<string, string, string, bool, bool>[] types = 
								{
								/*Tuple.Create("sbyte", "s8", "8-bit signed integers", true, false),
								Tuple.Create("byte", "u8", "8-bit unsigned integers", false, false),
								Tuple.Create("short", "s16", "16-bit signed integers", true, false),
								Tuple.Create("ushort", "u16", "16-bit unsigned integers", false, false),*/
								Tuple.Create("int", "s32", "32-bit signed integers", true, false),
								Tuple.Create("uint", "u32", "32-bit unsigned integers", false, false),
								Tuple.Create("long", "s64", "64-bit signed integers", true, false),
								Tuple.Create("ulong", "u64", "64-bit unsigned integers", false, false),
								Tuple.Create("float", "f32", "single-precision floating point numbers", true, true),
								Tuple.Create("double", "f64", "double-precision floating point numbers", true, true),
								};

				foreach (Tuple<string, string, string, bool, bool> type in types)
				{
								string typeName = type.Item1;
								string nativeSuffix = type.Item2;
								string typeDescription = type.Item3;
								bool isSigned = type.Item4;
								bool isFloating = type.Item5;
#>

        /// <summary>
        /// Creates an arrayof <#=typeDescription#> with the specified length and starting value.
        /// </summary>
        /// <param name="length">The number of elements in the array.</param>
        /// <param name="value">The initial value for the array values.</param>
        /// <returns>
        /// The allocated array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#>[] Create(int length, <#=typeName#> value)
        {
            <#=typeName#>[] a = new <#=typeName#>[length];
            if (value != default(<#=typeName#>))
            {
                Vectors.Set(length, value, a, 0);
            }

            return a;
        }

        /// <summary>
        /// Determines whether the two arrays of <#=typeDescription#> contain same data.
        /// </summary>
        /// <param name="length">The number of elements to compare.</param>
        /// <param name="x">The first array to compare.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array to compare.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// <b>true</b> if two arrays contain same data; otherwise, <b>false</b>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Equals(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.compare_<#=nativeSuffix#>(length, x, offx, y, offy) == 0;
        }

        /// <summary>
        /// Copies a range of <#=typeDescription#> from a array starting at the specified source index
        /// to another array starting at the specified destination index.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Copy(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.copy_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Copies a range of values from an array of <#=typeDescription#> starting at the specified source index
        /// to another array starting at the specified destination index.
        /// <paramref name="x"/> and <paramref name="y"/> can overlap.
        /// </summary>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Move(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            Debug.Assert(x.Length > offx + length - 1, "The source array should be big enough.");
            Debug.Assert(y.Length > offy + length - 1, "The destination array should be big enough.");
            NativeMethods.move_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Sets values in the array of <#=typeDescription#>
        /// starting at the specified source index to the specified value.
        /// </summary>
        /// <param name="length">The number of elements to set.</param>
        /// <param name="value">The value to set.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Set(int length, <#=typeName#> value, <#=typeName#>[] y, int offy)
        {
            NativeMethods.set_<#=nativeSuffix#>(length, value, y, offy);
        }

        /// <summary>
        /// Swaps elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to swap.</param>
        /// <param name="x">The first array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The second array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.swap_<#=nativeSuffix#>(length, x, offx, y, offy);
        }
<#
					if (isSigned)
					{
#>

        /// <summary>
        /// Computes the absolute value of elements of an array of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = Math.Abs(y)</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, <#=typeName#>[] y, int offy)
        {
            NativeMethods.abs_ip_<#=nativeSuffix#>(length, y, offy);
        }

        /// <summary>
        /// Computes the absolute value of elements of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The array that receives the data.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Abs(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.abs_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

<#
						if (isFloating)
						{
#>
        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Abs(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Abs(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="y">The <see cref="Abs(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="y"/>.</param>
        /// <param name="dy">The array that contains gradient for <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/> and <paramref name="dy"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>dx[i] += x[i] == y[i] ? dy[i] : -dy[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AbsGradient(int length, <#=typeName#>[] x, <#=typeName#>[] dx, int offx, bool cleardx, <#=typeName#>[] y, <#=typeName#>[] dy, int offy)
        {
            NativeMethods.abs_gradient_<#=nativeSuffix#>(length, x, dx, offx, cleardx, y, dy, offy);
        }
<#
						}
#>
<#
					}
#>
        /// <summary>
        /// Adds a constant value to each element of an array of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.addc_ip_<#=nativeSuffix#>(length, alpha, y, offy);
        }

        /// <summary>
        /// Adds a constant value to each element of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to add.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] + alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddC(int length, <#=typeName#>[] x, int offx, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.addc_<#=nativeSuffix#>(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.add_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Adds the elements of two arrays of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a + b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Add(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.add_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] -= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, [In] <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.subc_ip_<#=nativeSuffix#>(length, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts a constant value from each element of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to subtract.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] - alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SubC(int length, <#=typeName#>[] x, int offx, [In] <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.subc_<#=nativeSuffix#>(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y -= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sub_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Subtracts the elements of two arrays of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to subtract.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a - b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sub(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sub_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of <#=typeDescription#> by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] *= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.mulc_ip_<#=nativeSuffix#>(length, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies each element of an array of <#=typeDescription#> by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] := x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MulC(int length, <#=typeName#>[] x, int offx, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.mulc_<#=nativeSuffix#>(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y *= x</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.mul_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Multiplies the elements of two arrays of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y = a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Mul(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.mul_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of <#=typeDescription#> by a constant value in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] /= alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.divc_ip_<#=nativeSuffix#>(length, alpha, y, offy);
        }

        /// <summary>
        /// Divides each element of an array of <#=typeDescription#> by a constant value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to divide.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to divide.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] / alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DivC(int length, <#=typeName#>[] x, int offx, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.divc_<#=nativeSuffix#>(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of element of an array of <#=typeDescription#> and a constant to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to add.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="alpha">The scalar to multiply.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] += x[i] * alpha</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProductC(int length, <#=typeName#>[] x, int offx, <#=typeName#> alpha, <#=typeName#>[] y, int offy)
        {
            NativeMethods.addproductc_<#=nativeSuffix#>(length, x, offx, alpha, y, offy);
        }

        /// <summary>
        /// Adds product of elements of two arrays of <#=typeDescription#> to the elements of destination array.
        /// </summary>
        /// <param name="length">The number of elements to multiply.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y += a * b</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddProduct(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.addproduct_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = y[i] * y[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sqr_ip_<#=nativeSuffix#>(length, y, offy);
        }

        /// <summary>
        /// Squares elements of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = x[i] * x[i]</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Square(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sqr_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Returns the position of minimum value in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The position of minimum value in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMin(int length, <#=typeName#>[] x, int offx) => NativeMethods.argmin_<#=nativeSuffix#>(length, x, offx);

        /// <summary>
        /// Returns the position of maximum value in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The position of maximum value in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ArgMax(int length, <#=typeName#>[] x, int offx) => NativeMethods.argmax_<#=nativeSuffix#>(length, x, offx);

        /// <summary>
        /// Returns the position of minimum and maximum values in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The position of minimum value in the array.</param>
        /// <param name="max">The position of maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ArgMinMax(int length, <#=typeName#>[] x, int offx, out int min, out int max)
        {
            NativeMethods.argminmax_<#=nativeSuffix#>(length, x, offx, out min, out max);
        }

        /// <summary>
        /// Returns the minimum value in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The index in the <paramref name="x"/> at which evaluation begins.</param>
        /// <returns>
        /// The minimum value in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> Min(int length, <#=typeName#>[] x, int offx) => x[Vectors.ArgMin(length, x, offx)];

        /// <summary>
        /// Returns the maximum value in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The maximum value in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> Max(int length, <#=typeName#>[] x, int offx) => x[Vectors.ArgMax(length, x, offx)];

        /// <summary>
        /// Returns the minimum and maximum values in the array of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to evaluate.</param>
        /// <param name="x">The array that contains data used for evaluation.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="min">The minimum value in the array.</param>
        /// <param name="max">The maximum value in the array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinMax(int length, <#=typeName#>[] x, int offx, out <#=typeName#> min, out <#=typeName#> max)
        {
            Vectors.ArgMinMax(length, x, offx, out int argmin, out int argmax);
            min = x[argmin];
            max = x[argmax];
        }

        /// <summary>
        /// Computes a smaller of each element of an array of <#=typeDescription#> and a scalar value in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="a">The scalar value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, <#=typeName#> a, <#=typeName#>[] y, int offy)
        {
            NativeMethods.minc_ip_<#=nativeSuffix#>(length, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each element of an array of <#=typeDescription#> and a scalar value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="a">The scalar value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MinC(int length, <#=typeName#>[] x, int offx, <#=typeName#> a, <#=typeName#>[] y, int offy)
        {
            NativeMethods.minc_<#=nativeSuffix#>(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each pair of elements of the two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.min_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a smaller of each pair of elements of the two arrays of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Min(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.min_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of <#=typeDescription#> and a scalar value in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="a">The scalar value.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, <#=typeName#> a, <#=typeName#>[] y, int offy)
        {
            NativeMethods.maxc_ip_<#=nativeSuffix#>(length, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each element of an array of <#=typeDescription#> and a scalar value not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="a">The scalar value.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void MaxC(int length, <#=typeName#>[] x, int offx, <#=typeName#> a, <#=typeName#>[] y, int offy)
        {
            NativeMethods.maxc_<#=nativeSuffix#>(length, x, offx, a, y, offy);
        }

        /// <summary>
        /// Computes a larger of each pair of elements of the two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.max_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a larger of each pair of elements of the two arrays of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Max(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.max_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of <#=typeDescription#>.
        /// Elements that are less than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is smaller than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLT(int length, <#=typeName#> threshold, <#=typeName#> value, <#=typeName#>[] y, int offy)
        {
            NativeMethods.threshold_lt_ip_<#=nativeSuffix#>(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of <#=typeDescription#>.
        /// Elements that are greater than the threshold, are set to a specified value.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="threshold">The threshold value to use for each element.</param>
        /// <param name="value">The value to set for each element that is greater than the <paramref name="threshold"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdGT(int length, <#=typeName#> threshold, <#=typeName#> value, <#=typeName#>[] y, int offy)
        {
            NativeMethods.threshold_gt_ip_<#=nativeSuffix#>(length, threshold, value, y, offy);
        }

        /// <summary>
        /// Performs thresholding of elements of an array of <#=typeDescription#>.
        /// Elements that are smaller or greater than the thresholds, are set to a specified values.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="thresholdLT">The lower threshold value to use for each element.</param>
        /// <param name="valueLT">The value to set for each element that is smaller than the <paramref name="thresholdLT"/>.</param>
        /// <param name="thresholdGT">The upper threshold value to use for each element.</param>
        /// <param name="valueGT">The value to set for each element that is greater than the <paramref name="thresholdGT"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ThresholdLTGT(int length, <#=typeName#> thresholdLT, <#=typeName#> valueLT, <#=typeName#> thresholdGT, <#=typeName#> valueGT, <#=typeName#>[] y, int offy)
        {
            NativeMethods.threshold_ltgt_ip_<#=nativeSuffix#>(length, thresholdLT, valueLT, thresholdGT, valueGT, y, offy);
        }
<#
						if (isFloating)
						{
#>

        /// <summary>
        /// Computes a square root of elements of an array of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(y[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sqrt_ip_<#=nativeSuffix#>(length, y, offy);
        }

        /// <summary>
        /// Computes a square root of elements of an array of <#=typeDescription#> not in-place.
        /// </summary>
        /// <param name="length">The number of elements to square.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <remarks>
        /// The method performs operation defined as <c>y[i] = sqrt(x[i])</c>.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sqrt(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sqrt_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a natural logarithm of elements of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.log_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes an exponential of elements of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Exp(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.exp_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes a sines of elements of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Sin(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.sin_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Sin(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Sin(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="dy">The array that contains gradient <see cref="Sin(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SinGradient(int length, <#=typeName#>[] x, <#=typeName#>[] dx, int offx, bool cleardx, <#=typeName#>[] dy, int offdy)
        {
            NativeMethods.sin_gradient_<#=nativeSuffix#>(length, x, dx, offx, cleardx, dy, offdy);
        }

        /// <summary>
        /// Computes a cosines of elements of an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Cos(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.cos_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the derivative of the argument of the <see cref="Cos(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The <see cref="Cos(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <paramref name="x"/>.</param>
        /// <param name="dx">The destination array that receives calculated gradient for <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/> and <paramref name="dx"/>.</param>
        /// <param name="cleardx">Specifies whether <paramref name="dx"/> should be cleared before computation starts.</param>
        /// <param name="dy">The array that contains gradient <see cref="Cos(int, <#=typeName#>[], int, <#=typeName#>[], int)"/> method argument <c>y</c>.</param>
        /// <param name="offdy">The starting position in <paramref name="dy"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CosGradient(int length, <#=typeName#>[] x, <#=typeName#>[] dx, int offx, bool cleardx, <#=typeName#>[] dy, int offdy)
        {
            NativeMethods.cos_gradient_<#=nativeSuffix#>(length, x, dx, offx, cleardx, dy, offdy);
        }

        /// <summary>
        /// Computes the L1-Norm (sum of magnitudes) of the array of <#=typeDescription#> elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L1-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> L1Norm(int length, <#=typeName#>[] x, int offx)
        {
            return NativeMethods.nrm1_<#=nativeSuffix#>(length, x, offx);
        }

        /// <summary>
        /// Computes the L2-Norm (Euclidian norm) of the array of <#=typeDescription#> elements.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <returns>
        /// The L2-Norm of elements in the array.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> L2Norm(int length, <#=typeName#>[] x, int offx)
        {
            return NativeMethods.nrm2_<#=nativeSuffix#>(length, x, offx);
        }

        /// <summary>
        /// Computes the Manhattan distance between elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Manhattan distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum(abs(x[i] - y[i])).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> ManhattanDistance(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.manhattan_distance_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the squared Euclidean distance between elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sum((x[i] - y[i])^2).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> EuclideanDistanceSquared(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.euclidean_distance_squared_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Computes the Euclidean distance between elements of two arrays of <#=typeDescription#>.
        /// </summary>
        /// <param name="length">The number of elements to calculate.</param>
        /// <param name="x">The first array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The first array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        /// <returns>
        /// The Euclidean distance between elements of two arrays.
        /// </returns>
        /// <remarks>
        /// The method performs operation defined as sqrt(sum((x[i] - y[i])^2)).
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typeName#> EuclideanDistance(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            return NativeMethods.euclidean_distance_<#=nativeSuffix#>(length, x, offx, y, offy);
        }
<#
					}
#>
<#
					if (typeName == "uint" || typeName == "ulong")
					{
#>

        /// <summary>
        /// Performs logical OR operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Or(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.or_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void And(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.and_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xor(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.xor_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation on two arrays of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array.</param>
        /// <param name="offx">The starting element position in <paramref name="x"/>.</param>
        /// <param name="y">The source and destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Xand(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            NativeMethods.xand_ip_<#=nativeSuffix#>(length, x, offx, y, offy);
        }

        /// <summary>
        /// Performs logical OR operation on two arrays of <#=typeDescription#> not-in-pace.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [CLSCompliant(false)]
        public static void Or(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.or_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical AND operation on two arrays of <#=typeDescription#> not-in-pace.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [CLSCompliant(false)]
        public static void And(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.and_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical XOR operation on two arrays of <#=typeDescription#> not-in-pace.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [CLSCompliant(false)]
        public static void Xor(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.xor_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }

        /// <summary>
        /// Performs logical XAND (A AND NOT B) operation on two arrays of <#=typeDescription#> not-in-pace.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="a">The first source array.</param>
        /// <param name="offa">The starting element position in <paramref name="a"/>.</param>
        /// <param name="b">The second source array.</param>
        /// <param name="offb">The starting element position in <paramref name="b"/>.</param>
        /// <param name="y">The destination array.</param>
        /// <param name="offy">The starting element position in <paramref name="y"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [CLSCompliant(false)]
        public static void Xand(int length, <#=typeName#>[] a, int offa, <#=typeName#>[] b, int offb, <#=typeName#>[] y, int offy)
        {
            NativeMethods.xand_<#=nativeSuffix#>(length, a, offa, b, offb, y, offy);
        }
<#
					}
#>
<#
				}
#>

        [SuppressUnmanagedCodeSecurity]
        private static class NativeMethods
        {
            private const string DllName = "Genix.Core.Native.dll";
<#
				foreach (Tuple<string, string, string, bool, bool> type in types)
				{
								string typeName = type.Item1;
								string nativeSuffix = type.Item2;
								string typeDescription = type.Item3;
								bool isSigned = type.Item4;
								bool isFloating = type.Item5;
#>

            [DllImport(NativeMethods.DllName)]
            public static extern int compare_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void copy_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void move_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void set_<#=nativeSuffix#>(int n, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void swap_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);
<#
					if (isSigned)
					{
#>

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_ip_<#=nativeSuffix#>(int n, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void abs_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [Out] <#=typeName#>[] y, int offy);

<#
						if (isFloating)
						{
#>
            [DllImport(NativeMethods.DllName)]
            public static extern void abs_gradient_<#=nativeSuffix#>(
                int n,
                [In] <#=typeName#>[] x,
                [Out] <#=typeName#>[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] <#=typeName#>[] y,
                [In] <#=typeName#>[] dy,
                int offy);
<#
						}
#>
<#
					}
#>

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_ip_<#=nativeSuffix#>(int n, <#=typeName#> a, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void add_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#> a, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void subc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sub_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_ip_<#=nativeSuffix#>(int n, <#=typeName#> a, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mulc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void mul_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_ip_<#=nativeSuffix#>(int n, <#=typeName#> a, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void divc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproductc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void addproduct_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_ip_<#=nativeSuffix#>(int n, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqr_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern int argmin_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern int argmax_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern void argminmax_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, out int winmin, out int winmax);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_ip_<#=nativeSuffix#>(int n, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void minc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void min_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_ip_<#=nativeSuffix#>(int n, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void maxc_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, <#=typeName#> a, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_ip_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void max_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_lt_ip_<#=nativeSuffix#>(int n, <#=typeName#> threshold, <#=typeName#> value, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_gt_ip_<#=nativeSuffix#>(int n, <#=typeName#> threshold, <#=typeName#> value, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void threshold_ltgt_ip_<#=nativeSuffix#>(int n, <#=typeName#> thresholdLT, <#=typeName#> valueLT, <#=typeName#> thresholdGT, <#=typeName#> valueGT, [In, Out] <#=typeName#>[] y, int offy);
<#
					if (isFloating)
					{
#>

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_ip_<#=nativeSuffix#>(int n, [In, Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sqrt_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void log_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void exp_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void sin_gradient_<#=nativeSuffix#>(
                int n,
                [In] <#=typeName#>[] x,
                [Out] <#=typeName#>[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] <#=typeName#>[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void cos_gradient_<#=nativeSuffix#>(
                int n,
                [In] <#=typeName#>[] x,
                [Out] <#=typeName#>[] dx,
                int offx,
                [MarshalAs(UnmanagedType.Bool)] bool cleardx,
                [In] <#=typeName#>[] dy,
                int offdy);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> nrm1_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> nrm2_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> manhattan_distance_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> euclidean_distance_squared_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern <#=typeName#> euclidean_distance_<#=nativeSuffix#>(int n, [In] <#=typeName#>[] x, int offx, [In] <#=typeName#>[] y, int offy);
<#
					}
#>
<#
					if (typeName == "uint" || typeName == "ulong")
					{
#>
            [DllImport(NativeMethods.DllName)]
            public static extern void or_ip_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and_ip_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xor_ip_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xand_ip_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] x, int offx, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void or_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void and_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xor_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);

            [DllImport(NativeMethods.DllName)]
            public static extern void xand_<#=nativeSuffix#>(int length, [In] <#=typeName#>[] a, int offa, [In] <#=typeName#>[] b, int offb, [Out] <#=typeName#>[] y, int offy);
<#
					}
#>
<#
				}
#>
        }
    }
}