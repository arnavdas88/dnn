<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>
// -----------------------------------------------------------------------
// <copyright file="Statistic.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Core
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Provides statistical methods for numeric vectors manipulation.
    /// </summary>
    [CLSCompliant(false)]
    public static class Statistic
    {
<#
	Tuple<string, string, string, bool, bool>[] types = 
	{
		//Tuple.Create("sbyte", "s8", "8-bit signed integers", true, false),
		Tuple.Create("byte", "u8", "8-bit unsigned integers", false, false),
		Tuple.Create("short", "s16", "16-bit signed integers", true, false),
		Tuple.Create("ushort", "u16", "16-bit unsigned integers", false, false),
		Tuple.Create("int", "s32", "32-bit signed integers", true, false),
		Tuple.Create("uint", "u32", "32-bit unsigned integers", false, false),
		Tuple.Create("long", "s64", "64-bit signed integers", true, false),
		Tuple.Create("ulong", "u64", "64-bit unsigned integers", false, false),
		Tuple.Create("float", "f32", "single-precision floating point numbers", true, true),
		Tuple.Create("double", "f64", "double-precision floating point numbers", true, true),
	};

	foreach (Tuple<string, string, string, bool, bool> type in types)
	{
		string typeName = type.Item1;
		string nativeSuffix = type.Item2;
		string typeDescription = type.Item3;
		bool isSigned = type.Item4;
		bool isFloating = type.Item5;
#>

        /// <summary>
        /// Computes the first derivative of elements in array of <#=typeDescription#>.
        /// </summary>
        /// <param name="source">An array of <#=typeDescription#>. values to calculate the first derivative of.</param>
        /// <returns>An array of <#=typeDescription#> that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first element in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - <paramref name="source"/>[i - 1].
        /// </para>
        /// </remarks>
        public static <#=typeName#>[] Derivative(this <#=typeName#>[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            <#=typeName#>[] dst = new <#=typeName#>[ii];
            for (int i = 1; i < ii; i++)
            {
                dst[i] = (<#=typeName#>)(source[i] - source[i - 1]);
            }

            return dst;
        }

        /// <summary>
        /// Computes the second derivative of elements in array of <#=typeDescription#>.
        /// </summary>
        /// <param name="source">An array of <#=typeDescription#>. values to calculate the first derivative of.</param>
        /// <returns>An array of <#=typeDescription#> that contains the first derivative of the elements in <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        /// <remarks>
        /// <para>
        /// The derivative of first two elements in <paramref name="source"/> is zero.
        /// For all other elements it is <paramref name="source"/>[i] - (2 * <paramref name="source"/>[i - 1]) + <paramref name="source"/>[i - 2].
        /// </para>
        /// </remarks>
        public static <#=typeName#>[] SecondDerivative(this <#=typeName#>[] source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            int ii = source.Length;
            <#=typeName#>[] dst = new <#=typeName#>[ii];
            for (int i = 2; i < ii; i++)
            {
                dst[i] = (<#=typeName#>)(source[i] - (2 * source[i - 1]) + source[i - 2]);
            }

            return dst;
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of <#=typeDescription#> in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source and destination array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        public static void Smooth(int length, <#=typeName#>[] x, int offx)
        {
            if (length <= 1)
            {
                return;
            }

            // first element
            <#=typeName#> a = x[offx];
            <#=typeName#> b = x[offx + 1];
            x[offx] = (<#=typeName#>)(((3 * a) + b) / 4);
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++)
            {
                <#=typeName#> c = x[offx + 1];
                x[offx] = (<#=typeName#>)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            x[offx] = (<#=typeName#>)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over an array of <#=typeDescription#> not-in-place.
        /// </summary>
        /// <param name="length">The number of elements to compute.</param>
        /// <param name="x">The source array <paramref name="x"/>.</param>
        /// <param name="offx">The starting position in <paramref name="x"/>.</param>
        /// <param name="y">The destination array <paramref name="y"/>.</param>
        /// <param name="offy">The starting position in <paramref name="y"/>.</param>
        public static void Smooth(int length, <#=typeName#>[] x, int offx, <#=typeName#>[] y, int offy)
        {
            if (length == 0)
            {
                return;
            }

            if (length == 1)
            {
                y[offy] = x[offx];
                return;
            }

            // first element
            <#=typeName#> a = x[offx];
            <#=typeName#> b = x[offx + 1];
            y[offy] = (<#=typeName#>)(((3 * a) + b) / 4);
            offy++;
            offx++;

            // middle elements
            for (int i = 1, ii = length - 1; i < ii; i++, offx++, offy++)
            {
                <#=typeName#> c = x[offx + 1];
                y[offy] = (<#=typeName#>)((a + (2 * b) + c) / 4);
                a = b;
                b = c;
            }

            // last element
            y[offy] = (<#=typeName#>)((a + (3 * b)) / 4);
        }

        /// <summary>
        /// Applies a 1*2*1 moving average filter over a sequence of <#=typeDescription#>.
        /// </summary>
        /// <param name="source">A sequence of <#=typeDescription#> values to transform.</param>
        /// <returns>A sequence of <#=typeDescription#> whose elements are the result of transformation.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="source"/> is <b>null</b>.
        /// </exception>
        public static IEnumerable<<#=typeName#>> Smooth(this IEnumerable<<#=typeName#>> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            using (IEnumerator<<#=typeName#>> iterator = source.GetEnumerator())
            {
                if (!iterator.MoveNext())
                {
                    // sequence is empty - break
                    yield break;
                }

                <#=typeName#> prev2 = iterator.Current;

                if (!iterator.MoveNext())
                {
                    // sequence contains one element only - return unchanged value
                    yield return prev2;
                }
                else
                {
                    <#=typeName#> prev1 = iterator.Current;

                    // smooth left-most element
                    yield return (<#=typeName#>)((prev1 + prev2 + prev2 + prev2) / 4);

                    // smooth center elements
                    while (iterator.MoveNext())
                    {
                        <#=typeName#> current = iterator.Current;
                        <#=typeName#> result = (<#=typeName#>)((current + prev1 + prev1 + prev2) / 4);

                        prev2 = prev1;
                        prev1 = current;

                        yield return result;
                    }

                    // smooth right-most element
                    yield return (<#=typeName#>)((prev1 + prev1 + prev1 + prev2) / 4);
                }
            }
        }
<#  }#>

    }
}
