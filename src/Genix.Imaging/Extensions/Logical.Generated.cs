
// -----------------------------------------------------------------------
// <copyright file="Logical.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 10/2/2018 5:30:32 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Imaging
{
    using System;
    using Genix.Core;

    /// <content>
    /// <para>
    /// Provides logical extension methods for the <see cref="Image"/> class.
    /// </para>
    /// <para>
    ///             +---+---+---+---+
    ///    If A is: | 1 | 0 | 1 | 0 |
    ///   and B is: | 1 | 1 | 0 | 0 |
    ///             +---+---+---+---+
    ///     Then:        yields:
    /// +-----------+---+---+---+---+
    /// | FALSE     | 0 | 0 | 0 | 0 |
    /// | A NOR B   | 0 | 0 | 0 | 1 |
    /// | A XAND B  | 0 | 0 | 1 | 0 |
    /// | NOT B     | 0 | 0 | 1 | 1 |
    /// | B XAND A  | 0 | 1 | 0 | 0 |
    /// | NOT A     | 0 | 1 | 0 | 1 |
    /// | A XOR B   | 0 | 1 | 1 | 0 |
    /// | A NAND B  | 0 | 1 | 1 | 1 |
    /// | A AND B   | 1 | 0 | 0 | 0 |
    /// | A XNOR B  | 1 | 0 | 0 | 1 |
    /// | A         | 1 | 0 | 1 | 0 |
    /// | B XNAND A | 1 | 0 | 1 | 1 |
    /// | B         | 1 | 1 | 0 | 0 |
    /// | A XNAND B | 1 | 1 | 0 | 1 |
    /// | A OR B    | 1 | 1 | 1 | 0 |
    /// | TRUE      | 1 | 1 | 1 | 1 |
    /// +-----------+---+---+---+---+.
    /// </para>
    /// </content>
    public partial class Image
    {

        /// <summary>
        /// Performs logical AND operation on this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <para><paramref name="src"/> is <b>null</b>.</para>
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <remarks>
        /// <para>
        /// <paramref name="src"/> and this <see cref="Image"/> do not have to have the same width and height.
        /// If image sizes are different, the operation is performed in this <see cref="Image"/> upper-left corner.
        /// </para>
        /// </remarks>
        public Image And(Image dst, Image src)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            return this.And(
                dst,
                0,
                0,
                Math.Min(this.Width, src.Width),
                Math.Min(this.Height, src.Height),
                src,
                0,
                0);
        }

        /// <summary>
        /// Performs logical AND operation on a rectangular block of pixels from this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="x">The x-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="y">The y-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="width">The width of the source and destination rectangles.</param>
        /// <param name="height">The height of the source and destination rectangles.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <param name="xsrc">The x-coordinate of the upper-left corner of the source rectangle.</param>
        /// <param name="ysrc">The y-coordinate of the upper-left corner of the source rectangle.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="src"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The rectangular area described by <paramref name="x"/>, <paramref name="y"/>, <paramref name="width"/> and <paramref name="height"/> is outside of this <see cref="Image"/> bounds.</para>
        /// <para>-or-</para>
        /// <para>The rectangular area described by <paramref name="xsrc"/>, <paramref name="ysrc"/>, <paramref name="width"/> and <paramref name="height"/> is outside of <paramref name="src"/> bounds.</para>
        /// </exception>
        public Image And(Image dst, int x, int y, int width, int height, Image src, int xsrc, int ysrc)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            this.ValidateArea(x, y, width, height);
            src.ValidateArea(xsrc, ysrc, width, height);

            int bitsPerPixel = this.BitsPerPixel;
            if (src.BitsPerPixel != bitsPerPixel)
            {
                throw new ArgumentException(Properties.Resources.E_DepthNotTheSame);
            }

            // copy to destination image
            dst = this.Copy(dst);

            int stridesrc = src.Stride1;
            int stridedst = dst.Stride1;
            ulong[] bitssrc = src.Bits;
            ulong[] bitsdst = dst.Bits;

            int possrc = (ysrc * stridesrc) + (xsrc * bitsPerPixel);
            int posdst = (y * stridedst) + (x * bitsPerPixel);

            if (x == 0 && xsrc == 0 && stridesrc == stridedst && width == dst.Width)
            {
                // operation is performed on entire pixel line
                // do all lines at once
                Vectors.And(stridesrc * height / 64, bitssrc, possrc / 64, bitsdst, posdst / 64);
            }
            else
            {
                int count = width * bitsPerPixel;
                for (int iy = 0; iy < height; iy++, possrc += stridesrc, posdst += stridedst)
                {
                    BitUtils.And(count, bitssrc, possrc, bitsdst, posdst);
                }
            }

            return dst;
        }

        /// <summary>
        /// Performs logical OR operation on this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <para><paramref name="src"/> is <b>null</b>.</para>
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <remarks>
        /// <para>
        /// <paramref name="src"/> and this <see cref="Image"/> do not have to have the same width and height.
        /// If image sizes are different, the operation is performed in this <see cref="Image"/> upper-left corner.
        /// </para>
        /// </remarks>
        public Image Or(Image dst, Image src)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            return this.Or(
                dst,
                0,
                0,
                Math.Min(this.Width, src.Width),
                Math.Min(this.Height, src.Height),
                src,
                0,
                0);
        }

        /// <summary>
        /// Performs logical OR operation on a rectangular block of pixels from this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="x">The x-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="y">The y-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="width">The width of the source and destination rectangles.</param>
        /// <param name="height">The height of the source and destination rectangles.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <param name="xsrc">The x-coordinate of the upper-left corner of the source rectangle.</param>
        /// <param name="ysrc">The y-coordinate of the upper-left corner of the source rectangle.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="src"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The rectangular area described by <paramref name="x"/>, <paramref name="y"/>, <paramref name="width"/> and <paramref name="height"/> is outside of this <see cref="Image"/> bounds.</para>
        /// <para>-or-</para>
        /// <para>The rectangular area described by <paramref name="xsrc"/>, <paramref name="ysrc"/>, <paramref name="width"/> and <paramref name="height"/> is outside of <paramref name="src"/> bounds.</para>
        /// </exception>
        public Image Or(Image dst, int x, int y, int width, int height, Image src, int xsrc, int ysrc)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            this.ValidateArea(x, y, width, height);
            src.ValidateArea(xsrc, ysrc, width, height);

            int bitsPerPixel = this.BitsPerPixel;
            if (src.BitsPerPixel != bitsPerPixel)
            {
                throw new ArgumentException(Properties.Resources.E_DepthNotTheSame);
            }

            // copy to destination image
            dst = this.Copy(dst);

            int stridesrc = src.Stride1;
            int stridedst = dst.Stride1;
            ulong[] bitssrc = src.Bits;
            ulong[] bitsdst = dst.Bits;

            int possrc = (ysrc * stridesrc) + (xsrc * bitsPerPixel);
            int posdst = (y * stridedst) + (x * bitsPerPixel);

            if (x == 0 && xsrc == 0 && stridesrc == stridedst && width == dst.Width)
            {
                // operation is performed on entire pixel line
                // do all lines at once
                Vectors.Or(stridesrc * height / 64, bitssrc, possrc / 64, bitsdst, posdst / 64);
            }
            else
            {
                int count = width * bitsPerPixel;
                for (int iy = 0; iy < height; iy++, possrc += stridesrc, posdst += stridedst)
                {
                    BitUtils.Or(count, bitssrc, possrc, bitsdst, posdst);
                }
            }

            return dst;
        }

        /// <summary>
        /// Performs logical XOR operation on this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <para><paramref name="src"/> is <b>null</b>.</para>
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <remarks>
        /// <para>
        /// <paramref name="src"/> and this <see cref="Image"/> do not have to have the same width and height.
        /// If image sizes are different, the operation is performed in this <see cref="Image"/> upper-left corner.
        /// </para>
        /// </remarks>
        public Image Xor(Image dst, Image src)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            return this.Xor(
                dst,
                0,
                0,
                Math.Min(this.Width, src.Width),
                Math.Min(this.Height, src.Height),
                src,
                0,
                0);
        }

        /// <summary>
        /// Performs logical XOR operation on a rectangular block of pixels from this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="x">The x-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="y">The y-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="width">The width of the source and destination rectangles.</param>
        /// <param name="height">The height of the source and destination rectangles.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <param name="xsrc">The x-coordinate of the upper-left corner of the source rectangle.</param>
        /// <param name="ysrc">The y-coordinate of the upper-left corner of the source rectangle.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="src"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The rectangular area described by <paramref name="x"/>, <paramref name="y"/>, <paramref name="width"/> and <paramref name="height"/> is outside of this <see cref="Image"/> bounds.</para>
        /// <para>-or-</para>
        /// <para>The rectangular area described by <paramref name="xsrc"/>, <paramref name="ysrc"/>, <paramref name="width"/> and <paramref name="height"/> is outside of <paramref name="src"/> bounds.</para>
        /// </exception>
        public Image Xor(Image dst, int x, int y, int width, int height, Image src, int xsrc, int ysrc)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            this.ValidateArea(x, y, width, height);
            src.ValidateArea(xsrc, ysrc, width, height);

            int bitsPerPixel = this.BitsPerPixel;
            if (src.BitsPerPixel != bitsPerPixel)
            {
                throw new ArgumentException(Properties.Resources.E_DepthNotTheSame);
            }

            // copy to destination image
            dst = this.Copy(dst);

            int stridesrc = src.Stride1;
            int stridedst = dst.Stride1;
            ulong[] bitssrc = src.Bits;
            ulong[] bitsdst = dst.Bits;

            int possrc = (ysrc * stridesrc) + (xsrc * bitsPerPixel);
            int posdst = (y * stridedst) + (x * bitsPerPixel);

            if (x == 0 && xsrc == 0 && stridesrc == stridedst && width == dst.Width)
            {
                // operation is performed on entire pixel line
                // do all lines at once
                Vectors.Xor(stridesrc * height / 64, bitssrc, possrc / 64, bitsdst, posdst / 64);
            }
            else
            {
                int count = width * bitsPerPixel;
                for (int iy = 0; iy < height; iy++, possrc += stridesrc, posdst += stridedst)
                {
                    BitUtils.Xor(count, bitssrc, possrc, bitsdst, posdst);
                }
            }

            return dst;
        }

        /// <summary>
        /// Performs logical XAND operation on this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <para><paramref name="src"/> is <b>null</b>.</para>
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <remarks>
        /// <para>
        /// <paramref name="src"/> and this <see cref="Image"/> do not have to have the same width and height.
        /// If image sizes are different, the operation is performed in this <see cref="Image"/> upper-left corner.
        /// </para>
        /// </remarks>
        public Image Xand(Image dst, Image src)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            return this.Xand(
                dst,
                0,
                0,
                Math.Min(this.Width, src.Width),
                Math.Min(this.Height, src.Height),
                src,
                0,
                0);
        }

        /// <summary>
        /// Performs logical XAND operation on a rectangular block of pixels from this <see cref="Image"/> and the specified <see cref="Image"/>.
        /// </summary>
        /// <param name="dst">The destination <see cref="Image"/>. Can be <b>null</b>.</param>
        /// <param name="x">The x-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="y">The y-coordinate of the upper-left corner of the destination rectangle.</param>
        /// <param name="width">The width of the source and destination rectangles.</param>
        /// <param name="height">The height of the source and destination rectangles.</param>
        /// <param name="src">The right-side operand of this operation.</param>
        /// <param name="xsrc">The x-coordinate of the upper-left corner of the source rectangle.</param>
        /// <param name="ysrc">The y-coordinate of the upper-left corner of the source rectangle.</param>
        /// <returns>
        /// The destination <see cref="Image"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="src"/> is <b>null</b>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The images have a different depth.
        /// The <see cref="Image{T}.BitsPerPixel"/> properties of <paramref name="src"/> and this <see cref="Image"/> are not the same.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para>The rectangular area described by <paramref name="x"/>, <paramref name="y"/>, <paramref name="width"/> and <paramref name="height"/> is outside of this <see cref="Image"/> bounds.</para>
        /// <para>-or-</para>
        /// <para>The rectangular area described by <paramref name="xsrc"/>, <paramref name="ysrc"/>, <paramref name="width"/> and <paramref name="height"/> is outside of <paramref name="src"/> bounds.</para>
        /// </exception>
        public Image Xand(Image dst, int x, int y, int width, int height, Image src, int xsrc, int ysrc)
        {
            if (src == null)
            {
                throw new ArgumentNullException(nameof(src));
            }

            this.ValidateArea(x, y, width, height);
            src.ValidateArea(xsrc, ysrc, width, height);

            int bitsPerPixel = this.BitsPerPixel;
            if (src.BitsPerPixel != bitsPerPixel)
            {
                throw new ArgumentException(Properties.Resources.E_DepthNotTheSame);
            }

            // copy to destination image
            dst = this.Copy(dst);

            int stridesrc = src.Stride1;
            int stridedst = dst.Stride1;
            ulong[] bitssrc = src.Bits;
            ulong[] bitsdst = dst.Bits;

            int possrc = (ysrc * stridesrc) + (xsrc * bitsPerPixel);
            int posdst = (y * stridedst) + (x * bitsPerPixel);

            if (x == 0 && xsrc == 0 && stridesrc == stridedst && width == dst.Width)
            {
                // operation is performed on entire pixel line
                // do all lines at once
                Vectors.Xand(stridesrc * height / 64, bitssrc, possrc / 64, bitsdst, posdst / 64);
            }
            else
            {
                int count = width * bitsPerPixel;
                for (int iy = 0; iy < height; iy++, possrc += stridesrc, posdst += stridedst)
                {
                    BitUtils.Xand(count, bitssrc, possrc, bitsdst, posdst);
                }
            }

            return dst;
        }
	}
}