
// -----------------------------------------------------------------------
// <copyright file="SafeHandles.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 9/13/2018 5:51:56 PM
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Imaging.Leptonica
{
    using System;
    using System.Runtime.ConstrainedExecution;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;

    public sealed partial class Pix : DisposableObject
    {
        /// <summary>
        /// The handle reference for the object.
        /// </summary>
        private readonly SafePixHandle handle;

        /// <summary>
        /// Initializes a new instance of the <see cref="Pix"/> class.
        /// </summary>
        /// <param name="handle">The pointer to Leptonica's <see cref="Pix"/> object.</param>
        internal Pix(SafePixHandle handle)
        {
            this.handle = handle;
        }

        /// <summary>
        /// Gets the pointer to Leptonica's Pix object.
        /// </summary>
        /// <value>
        /// The pointer to Leptonica's Pix object.
        /// </value>
        public SafeHandle Handle => this.handle;

        /// <inheritdoc />
        protected override void Dispose(bool disposing)
        {
            this.handle?.Dispose();
        }
    }

    /// <summary>
    /// Represents a wrapper class for the Leptonica's Pix object.
    /// </summary>
    internal sealed class SafePixHandle : SafeHandle
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SafePixHandle"/> class.
        /// </summary>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafePixHandle()
            : this(IntPtr.Zero, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafePixHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafePixHandle(IntPtr preexistingHandle)
            : this(preexistingHandle, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafePixHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        /// <param name="ownsHandle"><b>true</b> to reliably release the handle during the finalization phase; <b>false</b> to prevent reliable release (not recommended).</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafePixHandle(IntPtr preexistingHandle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            this.SetHandle(preexistingHandle);
        }

        /// <inheritdoc />
        public override bool IsInvalid => this.handle == IntPtr.Zero;

        /// <inheritdoc />
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            // Here, we must obey all rules for constrained execution regions.
            // If ReleaseHandle failed, it can be reported via the "releaseHandleFailed" managed debugging assistant (MDA).
            // This MDA is disabled by default, but can be enabled in a debugger or during testing to diagnose handle corruption problems.
            // We do not throw an exception because most code could not recover from the problem.
            NativeMethods.pixDestroy(ref this.handle);
            return true;
        }
    }

    public sealed partial class Pixa : DisposableObject
    {
        /// <summary>
        /// The handle reference for the object.
        /// </summary>
        private readonly SafePixaHandle handle;

        /// <summary>
        /// Initializes a new instance of the <see cref="Pixa"/> class.
        /// </summary>
        /// <param name="handle">The pointer to Leptonica's <see cref="Pixa"/> object.</param>
        internal Pixa(SafePixaHandle handle)
        {
            this.handle = handle;
        }

        /// <summary>
        /// Gets the pointer to Leptonica's Pixa object.
        /// </summary>
        /// <value>
        /// The pointer to Leptonica's Pixa object.
        /// </value>
        public SafeHandle Handle => this.handle;

        /// <inheritdoc />
        protected override void Dispose(bool disposing)
        {
            this.handle?.Dispose();
        }
    }

    /// <summary>
    /// Represents a wrapper class for the Leptonica's Pixa object.
    /// </summary>
    internal sealed class SafePixaHandle : SafeHandle
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SafePixaHandle"/> class.
        /// </summary>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafePixaHandle()
            : this(IntPtr.Zero, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafePixaHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafePixaHandle(IntPtr preexistingHandle)
            : this(preexistingHandle, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafePixaHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        /// <param name="ownsHandle"><b>true</b> to reliably release the handle during the finalization phase; <b>false</b> to prevent reliable release (not recommended).</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafePixaHandle(IntPtr preexistingHandle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            this.SetHandle(preexistingHandle);
        }

        /// <inheritdoc />
        public override bool IsInvalid => this.handle == IntPtr.Zero;

        /// <inheritdoc />
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            // Here, we must obey all rules for constrained execution regions.
            // If ReleaseHandle failed, it can be reported via the "releaseHandleFailed" managed debugging assistant (MDA).
            // This MDA is disabled by default, but can be enabled in a debugger or during testing to diagnose handle corruption problems.
            // We do not throw an exception because most code could not recover from the problem.
            NativeMethods.pixaDestroy(ref this.handle);
            return true;
        }
    }

    public sealed partial class Box : DisposableObject
    {
        /// <summary>
        /// The handle reference for the object.
        /// </summary>
        private readonly SafeBoxHandle handle;

        /// <summary>
        /// Initializes a new instance of the <see cref="Box"/> class.
        /// </summary>
        /// <param name="handle">The pointer to Leptonica's <see cref="Box"/> object.</param>
        internal Box(SafeBoxHandle handle)
        {
            this.handle = handle;
        }

        /// <summary>
        /// Gets the pointer to Leptonica's Box object.
        /// </summary>
        /// <value>
        /// The pointer to Leptonica's Box object.
        /// </value>
        public SafeHandle Handle => this.handle;

        /// <inheritdoc />
        protected override void Dispose(bool disposing)
        {
            this.handle?.Dispose();
        }
    }

    /// <summary>
    /// Represents a wrapper class for the Leptonica's Box object.
    /// </summary>
    internal sealed class SafeBoxHandle : SafeHandle
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SafeBoxHandle"/> class.
        /// </summary>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafeBoxHandle()
            : this(IntPtr.Zero, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafeBoxHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafeBoxHandle(IntPtr preexistingHandle)
            : this(preexistingHandle, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafeBoxHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        /// <param name="ownsHandle"><b>true</b> to reliably release the handle during the finalization phase; <b>false</b> to prevent reliable release (not recommended).</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafeBoxHandle(IntPtr preexistingHandle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            this.SetHandle(preexistingHandle);
        }

        /// <inheritdoc />
        public override bool IsInvalid => this.handle == IntPtr.Zero;

        /// <inheritdoc />
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            // Here, we must obey all rules for constrained execution regions.
            // If ReleaseHandle failed, it can be reported via the "releaseHandleFailed" managed debugging assistant (MDA).
            // This MDA is disabled by default, but can be enabled in a debugger or during testing to diagnose handle corruption problems.
            // We do not throw an exception because most code could not recover from the problem.
            NativeMethods.boxDestroy(ref this.handle);
            return true;
        }
    }

    public sealed partial class Boxa : DisposableObject
    {
        /// <summary>
        /// The handle reference for the object.
        /// </summary>
        private readonly SafeBoxaHandle handle;

        /// <summary>
        /// Initializes a new instance of the <see cref="Boxa"/> class.
        /// </summary>
        /// <param name="handle">The pointer to Leptonica's <see cref="Boxa"/> object.</param>
        internal Boxa(SafeBoxaHandle handle)
        {
            this.handle = handle;
        }

        /// <summary>
        /// Gets the pointer to Leptonica's Boxa object.
        /// </summary>
        /// <value>
        /// The pointer to Leptonica's Boxa object.
        /// </value>
        public SafeHandle Handle => this.handle;

        /// <inheritdoc />
        protected override void Dispose(bool disposing)
        {
            this.handle?.Dispose();
        }
    }

    /// <summary>
    /// Represents a wrapper class for the Leptonica's Boxa object.
    /// </summary>
    internal sealed class SafeBoxaHandle : SafeHandle
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SafeBoxaHandle"/> class.
        /// </summary>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafeBoxaHandle()
            : this(IntPtr.Zero, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafeBoxaHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafeBoxaHandle(IntPtr preexistingHandle)
            : this(preexistingHandle, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SafeBoxaHandle"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        /// <param name="ownsHandle"><b>true</b> to reliably release the handle during the finalization phase; <b>false</b> to prevent reliable release (not recommended).</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SafeBoxaHandle(IntPtr preexistingHandle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            this.SetHandle(preexistingHandle);
        }

        /// <inheritdoc />
        public override bool IsInvalid => this.handle == IntPtr.Zero;

        /// <inheritdoc />
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            // Here, we must obey all rules for constrained execution regions.
            // If ReleaseHandle failed, it can be reported via the "releaseHandleFailed" managed debugging assistant (MDA).
            // This MDA is disabled by default, but can be enabled in a debugger or during testing to diagnose handle corruption problems.
            // We do not throw an exception because most code could not recover from the problem.
            NativeMethods.boxaDestroy(ref this.handle);
            return true;
        }
    }
}

