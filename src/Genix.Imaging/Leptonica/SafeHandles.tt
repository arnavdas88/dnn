<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="Generated.cs" #>

// -----------------------------------------------------------------------
// <copyright file="SafeHandles.Generated.cs" company="Noname, Inc.">
// Copyright (c) 2018, Alexander Volgunin. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Genix.Imaging.Leptonica
{
    using System;
    using System.Runtime.ConstrainedExecution;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
<#
    ClassDescription[] classes = new ClassDescription[]
    {
        new ClassDescription() { HandleName = "SafePixHandle", ObjectName = "Pix", DestroyMethod = "pixDestroy" },
        new ClassDescription() { HandleName = "SafePixaHandle", ObjectName = "Pixa", DestroyMethod = "pixaDestroy" },
        new ClassDescription() { HandleName = "SafeBoxHandle", ObjectName = "Box", DestroyMethod = "boxDestroy" },
        new ClassDescription() { HandleName = "SafeBoxaHandle", ObjectName = "Boxa", DestroyMethod = "boxaDestroy" },
    };

    foreach (ClassDescription cls in classes)
    {
#>

    public sealed partial class <#=cls.ObjectName#> : DisposableObject
    {
        /// <summary>
        /// The handle reference for the object.
        /// </summary>
        private readonly <#=cls.HandleName#> handle;

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=cls.ObjectName#>"/> class.
        /// </summary>
        /// <param name="handle">The pointer to Leptonica's <see cref="<#=cls.ObjectName#>"/> object.</param>
        internal <#=cls.ObjectName#>(<#=cls.HandleName#> handle)
        {
            this.handle = handle;
        }

        /// <summary>
        /// Gets the pointer to Leptonica's <#=cls.ObjectName#> object.
        /// </summary>
        /// <value>
        /// The pointer to Leptonica's <#=cls.ObjectName#> object.
        /// </value>
        public SafeHandle Handle => this.handle;

        /// <inheritdoc />
        protected override void Dispose(bool disposing)
        {
            this.handle?.Dispose();
        }
    }

    /// <summary>
    /// Represents a wrapper class for the Leptonica's <#=cls.ObjectName#> object.
    /// </summary>
    internal sealed class <#=cls.HandleName#> : SafeHandle
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<#=cls.HandleName#>"/> class.
        /// </summary>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public <#=cls.HandleName#>()
            : this(IntPtr.Zero, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=cls.HandleName#>"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public <#=cls.HandleName#>(IntPtr preexistingHandle)
            : this(preexistingHandle, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=cls.HandleName#>"/> class.
        /// </summary>
        /// <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
        /// <param name="ownsHandle"><b>true</b> to reliably release the handle during the finalization phase; <b>false</b> to prevent reliable release (not recommended).</param>
        [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public <#=cls.HandleName#>(IntPtr preexistingHandle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            this.SetHandle(preexistingHandle);
        }

        /// <inheritdoc />
        public override bool IsInvalid => this.handle == IntPtr.Zero;

        /// <inheritdoc />
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
        protected override bool ReleaseHandle()
        {
            // Here, we must obey all rules for constrained execution regions.
            // If ReleaseHandle failed, it can be reported via the "releaseHandleFailed" managed debugging assistant (MDA).
            // This MDA is disabled by default, but can be enabled in a debugger or during testing to diagnose handle corruption problems.
            // We do not throw an exception because most code could not recover from the problem.
            NativeMethods.<#=cls.DestroyMethod#>(ref this.handle);
            return true;
        }
    }
<#
    }
#>
}

<#+
    class ClassDescription
    {
        public string HandleName { get; set; }
        public string ObjectName { get; set; }
        public string DestroyMethod { get; set; }
    }
#>